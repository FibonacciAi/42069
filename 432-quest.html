<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Fractal + Audio Reactive</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      overflow: hidden;
      background: #000; color: #fff;
      font-family: sans-serif;
    }
    .ui-container {
      position: fixed;
      top: 10px; left: 10px;
      z-index: 999;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 8px;
    }
    label {
      display: block;
      margin: 6px 0;
    }
    input[type=range] {
      width: 200px;
    }
    button {
      margin-top: 10px;
      width: 100%;
    }
  </style>
</head>
<body>
<div class="ui-container">
  <label>
    Frequency: <span id="freqValue">432</span> Hz
    <input id="freqSlider" type="range" min="220" max="880" step="1" value="432">
  </label>
  <button id="playBtn">Play</button>
</div>

<script type="module">
// We'll import from a CDN for simplicity
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js';
import {OrbitControls} from 'https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/controls/OrbitControls.js';

class AudioReactiveFractal {
  constructor() {
    // Scene & camera
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(
      60, window.innerWidth/window.innerHeight, 0.1, 1000
    );
    this.camera.position.set(0, 0, 2.5);

    // Renderer
    this.renderer = new THREE.WebGLRenderer({antialias: true});
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(this.renderer.domElement);

    // Controls (touch / mouse orbit, zoom, etc.)
    this.controls = new OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;  // smoother movement
    this.controls.dampingFactor = 0.05;

    // Audio
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    this.oscillator = null;
    this.isPlaying = false;
    this.freqSlider = document.getElementById('freqSlider');
    this.freqValue  = document.getElementById('freqValue');
    this.playBtn    = document.getElementById('playBtn');

    // Analyser
    this.analyser = this.audioCtx.createAnalyser();
    this.analyser.fftSize = 1024;
    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

    this.initAudioUI();
    this.initFractalPlane();
    this.onResize();
    window.addEventListener('resize', () => this.onResize());

    this.animate();
  }

  initAudioUI() {
    // Frequency slider
    this.freqSlider.addEventListener('input', (e) => {
      const val = e.target.value;
      this.freqValue.textContent = val;
      if (this.oscillator) {
        this.oscillator.frequency.setValueAtTime(val, this.audioCtx.currentTime);
      }
    });

    // Play button
    this.playBtn.addEventListener('click', () => {
      if (!this.isPlaying) {
        this.startOscillator();
        this.playBtn.textContent = 'Stop';
      } else {
        this.stopOscillator();
        this.playBtn.textContent = 'Play';
      }
    });
  }

  startOscillator() {
    this.oscillator = this.audioCtx.createOscillator();
    this.oscillator.type = 'sine';
    const freqVal = parseFloat(this.freqSlider.value);
    this.oscillator.frequency.setValueAtTime(freqVal, this.audioCtx.currentTime);

    // Gain
    const gainNode = this.audioCtx.createGain();
    gainNode.gain.value = 0.2;

    // Connect chain
    this.oscillator.connect(gainNode);
    gainNode.connect(this.analyser);
    this.analyser.connect(this.audioCtx.destination);

    this.oscillator.start();
    this.isPlaying = true;
  }

  stopOscillator() {
    if (this.oscillator) {
      this.oscillator.stop();
      this.oscillator.disconnect();
      this.oscillator = null;
    }
    this.isPlaying = false;
  }

  initFractalPlane() {
    // A plane that spans [-1,1] in UV space. We'll do fractal in a fragment shader
    const planeGeo = new THREE.PlaneGeometry(2, 2);

    // Make a custom shader material
    const fractalUniforms = {
      uTime:        {value: 0.0},
      uResolution:  {value: new THREE.Vector2(window.innerWidth, window.innerHeight)},
      uFrequency:   {value: parseFloat(this.freqSlider.value)},
      uAmplitude:   {value: 128.0}, // average amplitude ~128 for mid
      // You can tweak these base offsets for initial fractal position
      uZoom:        {value: 1.0},
      uColorShift:  {value: 0.0}
    };

    const fractalMaterial = new THREE.ShaderMaterial({
      uniforms: fractalUniforms,
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;  // pass uv coords to fragment shader
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `,
      fragmentShader: `
        precision highp float;

        varying vec2 vUv;
        uniform float uTime;
        uniform vec2  uResolution;
        uniform float uFrequency;
        uniform float uAmplitude;
        uniform float uZoom;
        uniform float uColorShift;

        // Simple 2D Mandelbrot to illustrate approach
        // For heavier fractals (e.g. mandelbulb), you'd do a raymarch approach

        vec3 hsv2rgb(vec3 c) {
          // convert hsv to rgb for color mapping
          vec4 K = vec4(1., 2./3., 1./3., 3.);
          vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);
        }

        void main() {
          // aspect correction
          vec2 coord = (vUv - 0.5) * 2.0;
          coord.x *= uResolution.x / uResolution.y;

          // fractal "zoom" factor
          coord /= (0.7 * uZoom);

          // offset by frequency
          float freqFactor = (uFrequency - 432.) * 0.003;
          // maybe swirl them
          float angle = freqFactor;
          float s = sin(angle), c = cos(angle);
          mat2 rot = mat2(c, -s, s, c);
          coord = rot * coord;

          // center shift based on colorShift
          coord.x += (uColorShift * 0.2);

          // mandelbrot iteration
          float zx = coord.x;
          float zy = coord.y;
          const int MAX_ITER = 150;
          int i = 0;
          float threshold = 4.0;
          for (int n = 0; n < MAX_ITER; n++) {
            float x2 = zx * zx, y2 = zy * zy;
            if (x2 + y2 > threshold) {
              i = n;
              break;
            }
            zy = 2.0 * zx * zy + coord.y;
            zx = x2 - y2 + coord.x;
          }

          // amplitude -> color
          float normI = float(i) / float(MAX_ITER);
          float ampFactor = (uAmplitude - 128.) * 0.01; // shift color by amplitude
          // let's do an HSV ramp
          vec3 hsvColor = vec3(
            0.66 + normI + ampFactor, // hue
            1.0,
            normI * 1.3
          );

          vec3 color = hsv2rgb(hsvColor);

          // If we never escaped => black
          if (i == MAX_ITER) {
            color = vec3(0.);
          }

          gl_FragColor = vec4(color, 1.0);
        }
      `,
      // to see nice fractal details
      side: THREE.DoubleSide
    });

    this.fractalUniforms = fractalUniforms; // store for updates

    const plane = new THREE.Mesh(planeGeo, fractalMaterial);
    this.scene.add(plane);
  }

  onResize() {
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();

    // update uniform
    this.fractalUniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
  }

  animate() {
    requestAnimationFrame(() => this.animate());

    // get amplitude from analyser
    this.analyser.getByteTimeDomainData(this.dataArray);
    let sum = 0;
    for (let i = 0; i < this.dataArray.length; i++) sum += this.dataArray[i];
    const avgAmplitude = sum / this.dataArray.length; // ~128 is quiet

    // update fractal uniforms
    const freqVal = parseFloat(this.freqSlider.value);
    this.fractalUniforms.uTime.value += 0.01;       // if you want time-based motion
    this.fractalUniforms.uFrequency.value = freqVal;
    this.fractalUniforms.uAmplitude.value = avgAmplitude;

    // Example: zoom based on frequency ratio
    // freq=432 => ratio=1 => zoom=1; freq=864 => ratio=2 => zoom=2
    const ratio = freqVal / 432.0;
    this.fractalUniforms.uZoom.value = ratio;

    // Example: color shift from amplitude
    const ampShift = (avgAmplitude - 128.0) * 0.01;  
    this.fractalUniforms.uColorShift.value = ampShift;

    // OrbitControls update
    this.controls.update();

    this.renderer.render(this.scene, this.camera);
  }
}

new AudioReactiveFractal();
</script>
</body>
</html>
