<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>432 Quest — Fractal + Audio (GitHub Pages Ready)</title>
  <style>
    html, body {
      margin: 0; 
      padding: 0;
      overflow: hidden;
      background: #000; 
      color: #fff;
      font-family: sans-serif;
    }
    .ui-container {
      position: fixed;
      top: 10px; 
      left: 10px;
      z-index: 999;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 8px;
    }
    label {
      display: block;
      margin: 6px 0;
      font-weight: 500;
    }
    input[type=range] {
      width: 200px;
    }
    button {
      margin-top: 10px;
      width: 100%;
      font-size: 0.9rem;
      padding: 5px 0;
    }
  </style>
</head>
<body>
<div class="ui-container">
  <label>
    Frequency: <span id="freqValue">432</span> Hz
    <input id="freqSlider" type="range" min="220" max="880" step="1" value="432" />
  </label>
  <button id="playBtn">Play</button>
</div>

<!-- Load Three.js + OrbitControls from a CDN in non-module format -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/OrbitControls.js"></script>

<script>
/**
 * 432 Quest: 3D scene with a plane that runs a Mandelbrot fractal in a fragment shader,
 * with audio-reactive coloring. Works on GitHub Pages if placed in a public folder.
 */
class AudioReactiveFractal {
  constructor() {
    // SCENE & CAMERA
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    // Pull back camera so we see the plane
    this.camera.position.set(0, 0, 2.5);

    // RENDERER
    this.renderer = new THREE.WebGLRenderer({antialias: true});
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(this.renderer.domElement);

    // CONTROLS (Orbit, Zoom, Pan w/ mouse or touch)
    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;

    // AUDIO
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    this.oscillator = null;
    this.isPlaying = false;

    // ANALYSER
    this.analyser = this.audioCtx.createAnalyser();
    this.analyser.fftSize = 1024;
    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

    // UI ELEMENTS
    this.freqSlider = document.getElementById('freqSlider');
    this.freqValue  = document.getElementById('freqValue');
    this.playBtn    = document.getElementById('playBtn');

    // Set up slider
    this.freqSlider.addEventListener('input', (e) => {
      const val = e.target.value;
      this.freqValue.textContent = val;
      if (this.oscillator) {
        this.oscillator.frequency.setValueAtTime(val, this.audioCtx.currentTime);
      }
    });

    // Play / Stop button
    this.playBtn.addEventListener('click', () => {
      if (!this.isPlaying) {
        this.startOscillator();
        this.playBtn.textContent = 'Stop';
      } else {
        this.stopOscillator();
        this.playBtn.textContent = 'Play';
      }
    });

    // FRACTAL PLANE
    this.initFractalPlane();

    // HANDLE RESIZE
    window.addEventListener('resize', () => this.onResize());
    this.onResize();  // set initial sizes

    // START LOOP
    this.animate();
  }

  startOscillator() {
    this.oscillator = this.audioCtx.createOscillator();
    this.oscillator.type = 'sine';

    const freqVal = parseFloat(this.freqSlider.value);
    this.oscillator.frequency.setValueAtTime(freqVal, this.audioCtx.currentTime);

    // Basic gain so it’s not too loud
    const gainNode = this.audioCtx.createGain();
    gainNode.gain.value = 0.2;

    // Connect chain: oscillator -> gain -> analyser -> destination
    this.oscillator.connect(gainNode);
    gainNode.connect(this.analyser);
    this.analyser.connect(this.audioCtx.destination);

    this.oscillator.start();
    this.isPlaying = true;
  }

  stopOscillator() {
    if (this.oscillator) {
      this.oscillator.stop();
      this.oscillator.disconnect();
      this.oscillator = null;
    }
    this.isPlaying = false;
  }

  initFractalPlane() {
    const planeGeo = new THREE.PlaneGeometry(2, 2);

    // We'll store the fractal parameters in these uniforms
    this.fractalUniforms = {
      uTime:        { value: 0.0 },
      uResolution:  { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
      uFrequency:   { value: parseFloat(this.freqSlider.value) },
      uAmplitude:   { value: 128.0 }, // ~mid-level amplitude
      uZoom:        { value: 1.0 },
      uColorShift:  { value: 0.0 }
    };

    // Simple Mandelbrot in fragment shader
    const fractalMaterial = new THREE.ShaderMaterial({
      uniforms: this.fractalUniforms,
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv; 
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;

        varying vec2 vUv;
        uniform vec2  uResolution;
        uniform float uTime;
        uniform float uFrequency;
        uniform float uAmplitude;
        uniform float uZoom;
        uniform float uColorShift;

        // Basic helper: HSV -> RGB
        vec3 hsv2rgb(vec3 c) {
          vec4 K = vec4(1., 2./3., 1./3., 3.);
          vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);
        }

        void main() {
          // Convert vUv => [-1,1], correct aspect
          vec2 coord = (vUv - 0.5) * 2.0;
          coord.x *= uResolution.x / uResolution.y;

          // Zoom
          coord /= (0.7 * uZoom);

          // Slight swirl with freq & time
          float freqFactor = (uFrequency - 432.) * 0.003;
          float angle = freqFactor + (uTime * 0.1);
          float s = sin(angle), c = cos(angle);
          mat2 rot = mat2(c, -s, s, c);
          coord = rot * coord;

          // Shift fractal center horizontally
          coord.x += (uColorShift * 0.2);

          // Mandelbrot iteration
          float zx = coord.x;
          float zy = coord.y;
          const int MAX_ITER = 120;
          int i = 0;
          float threshold = 4.0;
          for (int n=0; n<MAX_ITER; n++) {
            float x2 = zx*zx, y2=zy*zy;
            if (x2 + y2 > threshold) {
              i = n;
              break;
            }
            zy = 2.0*zx*zy + coord.y;
            zx = x2 - y2 + coord.x;
          }

          float normI = float(i) / float(MAX_ITER);
          // Use amplitude to shift color
          float ampShift = (uAmplitude - 128.) * 0.01;

          // HSV coloring
          vec3 hsv = vec3(
            0.66 + normI + ampShift, 
            1.0,
            normI * 1.3
          );
          vec3 color = hsv2rgb(hsv);

          // If never escaped => black
          if (i == MAX_ITER) {
            color = vec3(0.);
          }

          gl_FragColor = vec4(color, 1.0);
        }
      `,
      side: THREE.DoubleSide
    });

    const plane = new THREE.Mesh(planeGeo, fractalMaterial);
    this.scene.add(plane);
  }

  onResize() {
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    if (this.fractalUniforms && this.fractalUniforms.uResolution) {
      this.fractalUniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
    }
  }

  animate() {
    requestAnimationFrame(() => this.animate());

    // If audio is playing, update amplitude from Analyser
    if (this.isPlaying) {
      this.analyser.getByteTimeDomainData(this.dataArray);
      let sum = 0;
      for (let i=0; i<this.dataArray.length; i++) {
        sum += this.dataArray[i];
      }
      const avgAmp = sum / this.dataArray.length;  // ~128 if quiet
      this.fractalUniforms.uAmplitude.value = avgAmp;
    }

    // Update fractal uniforms
    this.fractalUniforms.uTime.value += 0.01;

    const freqVal = parseFloat(this.freqSlider.value);
    this.fractalUniforms.uFrequency.value = freqVal;

    // Zoom formula => freq=432 => ratio=1 => zoom=1
    // freq=864 => ratio=2 => zoom=2, etc.
    const ratio = freqVal / 432.0;
    this.fractalUniforms.uZoom.value = ratio;

    // color shift from amplitude
    const ampShift = (this.fractalUniforms.uAmplitude.value - 128.0) * 0.01;
    this.fractalUniforms.uColorShift.value = ampShift;

    // Update controls
    this.controls.update();
    // Render
    this.renderer.render(this.scene, this.camera);
  }
}

window.addEventListener('load', () => {
  new AudioReactiveFractal();
});
</script>
</body>
</html>
