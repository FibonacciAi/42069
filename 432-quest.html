<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Fractal + Audio Reactive (Single-File)</title>
  <style>
    html, body {
      margin: 0; 
      padding: 0;
      overflow: hidden;
      background: #000; 
      color: #fff;
      font-family: sans-serif;
    }
    .ui-container {
      position: fixed;
      top: 10px; 
      left: 10px;
      z-index: 999;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 8px;
    }
    label {
      display: block;
      margin: 6px 0;
    }
    input[type=range] {
      width: 200px;
    }
    button {
      margin-top: 10px;
      width: 100%;
    }
  </style>
</head>
<body>
<div class="ui-container">
  <label>
    Frequency: <span id="freqValue">432</span> Hz
    <input id="freqSlider" type="range" min="220" max="880" step="1" value="432">
  </label>
  <button id="playBtn">Play</button>
</div>

<!-- Load Three.js + OrbitControls (non-module) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.0/examples/js/controls/OrbitControls.js"></script>

<script>
class AudioReactiveFractal {
  constructor() {
    // =============== THREE.JS SETUP ===============

    // 1) Scene & Camera
    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(
      60, window.innerWidth / window.innerHeight, 0.1, 1000
    );
    // Pull back the camera a bit so we can see our fractal plane
    this.camera.position.set(0, 0, 2.5);

    // 2) Renderer
    this.renderer = new THREE.WebGLRenderer({antialias: true});
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(this.renderer.domElement);

    // 3) OrbitControls (mouse/touch/trackpad)
    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
    this.controls.enableDamping = true;
    this.controls.dampingFactor = 0.05;

    // =============== AUDIO SETUP ===============
    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    this.oscillator = null;  // we'll create it on demand
    this.isPlaying = false;

    // Analyzer for audio
    this.analyser = this.audioCtx.createAnalyser();
    this.analyser.fftSize = 1024;
    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

    // =============== UI ELEMENTS ===============
    this.freqSlider = document.getElementById('freqSlider');
    this.freqValue  = document.getElementById('freqValue');
    this.playBtn    = document.getElementById('playBtn');

    // Hook up slider
    this.freqSlider.addEventListener('input', (e) => {
      const val = e.target.value;
      this.freqValue.textContent = val;
      if (this.oscillator) {
        this.oscillator.frequency.setValueAtTime(val, this.audioCtx.currentTime);
      }
    });

    // Hook up Play/Stop
    this.playBtn.addEventListener('click', () => {
      if (!this.isPlaying) {
        this.startOscillator();
        this.playBtn.textContent = 'Stop';
      } else {
        this.stopOscillator();
        this.playBtn.textContent = 'Play';
      }
    });

    // =============== FRACTAL PLANE ===============
    this.initFractalPlane();

    // Handle window resizing
    window.addEventListener('resize', () => this.onResize());
    this.onResize(); // set initial sizes

    // Kick off the animation loop
    this.animate();
  }

  startOscillator() {
    this.oscillator = this.audioCtx.createOscillator();
    this.oscillator.type = 'sine';

    const freqVal = parseFloat(this.freqSlider.value);
    this.oscillator.frequency.setValueAtTime(freqVal, this.audioCtx.currentTime);

    // Gain node so itâ€™s not too loud
    const gainNode = this.audioCtx.createGain();
    gainNode.gain.value = 0.2;

    // Connect: oscillator -> gain -> analyser -> destination
    this.oscillator.connect(gainNode);
    gainNode.connect(this.analyser);
    this.analyser.connect(this.audioCtx.destination);

    this.oscillator.start();
    this.isPlaying = true;
  }

  stopOscillator() {
    if (this.oscillator) {
      this.oscillator.stop();
      this.oscillator.disconnect();
      this.oscillator = null;
    }
    this.isPlaying = false;
  }

  initFractalPlane() {
    // Create a plane that covers the view: geometry, then a custom fractal-shader material
    const planeGeo = new THREE.PlaneGeometry(2, 2);

    // We'll store our uniforms in an object so we can update them in animate()
    this.fractalUniforms = {
      uTime:       { value: 0.0 },
      uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
      uFrequency:  { value: parseFloat(this.freqSlider.value) },
      uAmplitude:  { value: 128.0 }, // about mid-level
      uZoom:       { value: 1.0 },
      uColorShift: { value: 0.0 }
    };

    const fractalMaterial = new THREE.ShaderMaterial({
      uniforms: this.fractalUniforms,
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv; 
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;

        varying vec2 vUv;
        uniform vec2  uResolution;
        uniform float uTime;
        uniform float uFrequency;
        uniform float uAmplitude;
        uniform float uZoom;
        uniform float uColorShift;

        // Simple function: HSV -> RGB for flexible coloring
        vec3 hsv2rgb(vec3 c) {
          vec4 K = vec4(1., 2./3., 1./3., 3.);
          vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);
        }

        void main() {
          // Normalized coords: (vUv - 0.5)*2 => [-1,1], but aspect-correct
          vec2 coord = (vUv - 0.5) * 2.0;
          coord.x *= uResolution.x / uResolution.y;

          // Zoom
          coord /= (0.7 * uZoom);

          // We'll swirl by freq
          float freqFactor = (uFrequency - 432.) * 0.003;
          float angle = freqFactor + (uTime * 0.1); // animate swirl a bit
          float s = sin(angle), c = cos(angle);
          mat2 rot = mat2(c, -s, s, c);
          coord = rot * coord;

          // shift based on colorShift => fractal center moves left-right
          coord.x += (uColorShift * 0.2);

          // Mandelbrot iteration
          float zx = coord.x;
          float zy = coord.y;
          const int MAX_ITER = 120;
          int i = 0;
          float threshold = 4.0;
          for (int n = 0; n < MAX_ITER; n++) {
            float x2 = zx * zx, y2 = zy * zy;
            if (x2 + y2 > threshold) {
              i = n;
              break;
            }
            zy = 2.0 * zx * zy + coord.y;
            zx = x2 - y2 + coord.x;
          }

          float normI = float(i) / float(MAX_ITER);
          float ampFactor = (uAmplitude - 128.) * 0.01; // from ~-1.28 to +1.28

          vec3 hsv = vec3(
            0.66 + normI + ampFactor, // hue
            1.0,
            normI * 1.3
          );

          vec3 color = hsv2rgb(hsv);

          // If we never escaped => black
          if (i == MAX_ITER) {
            color = vec3(0.);
          }

          gl_FragColor = vec4(color, 1.0);
        }
      `,
      side: THREE.DoubleSide
    });

    const plane = new THREE.Mesh(planeGeo, fractalMaterial);
    this.scene.add(plane);
  }

  onResize() {
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    if (this.fractalUniforms && this.fractalUniforms.uResolution) {
      this.fractalUniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
    }
  }

  animate() {
    requestAnimationFrame(() => this.animate());

    // Update audio data if playing
    if (this.isPlaying) {
      this.analyser.getByteTimeDomainData(this.dataArray);
      let sum = 0.0;
      for (let i = 0; i < this.dataArray.length; i++) {
        sum += this.dataArray[i];
      }
      const avgAmp = sum / this.dataArray.length; // ~128 is quiet
      this.fractalUniforms.uAmplitude.value = avgAmp;
    }

    // Update fractal uniforms
    this.fractalUniforms.uTime.value += 0.01;
    const freqVal = parseFloat(this.freqSlider.value);
    this.fractalUniforms.uFrequency.value = freqVal;

    // Zoom formula: freq ratio => freq=432 => zoom=1; freq=864 => zoom=2
    const ratio = freqVal / 432.0;
    this.fractalUniforms.uZoom.value = ratio;

    // color shift from amplitude
    const ampShift = (this.fractalUniforms.uAmplitude.value - 128.0) * 0.01;
    this.fractalUniforms.uColorShift.value = ampShift;

    // Update controls
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
  }
}

window.addEventListener('load', () => {
  new AudioReactiveFractal();
});
</script>
</body>
</html>
