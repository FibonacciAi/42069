<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="description" content="Cycle Resonance Visualization (NFA)" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cycle Resonance + Advanced UI (Fibonacci Subcycles)</title>
  <style>
    :root {
      --bg-color: #0f0f13;
      --text-color: #ffffff;
      --panel-bg: rgba(15, 15, 19, 0.85);
      --highlight: #2196F3;

      /* Color references */
      --red-color: rgba(255, 0, 0, 0.8);
      --gold-color: #FFD700;
      --skyblue-color: #87CEFA;
      --limegreen-color: #32CD32;
      --orange-color: #FFA500;
      --pink-color: #FF69B4;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: var(--bg-color);
      color: var(--text-color);
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #cycleCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .panel {
      position: absolute;
      background: var(--panel-bg);
      padding: 1.25rem;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
      z-index: 2;
    }

    /* FPS Panel, top-left */
    .stats {
      top: 20px;
      left: 20px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.7);
    }

    /* Control panel, top-right (desktop) */
    .controls {
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    /* Date display, bottom-left */
    .date-panel {
      bottom: 20px;
      left: 20px;
      font-size: 0.9rem;
    }

    button {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s, transform 0.2s;
    }
    button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(33, 150, 243, 0.4);
    }

    /* Mobile: stack controls at bottom */
    @media (max-width: 600px) {
      .controls {
        top: auto;
        bottom: 20px;
        right: 20px;
        flex-direction: column;
        gap: 8px;
      }
      .stats {
        top: 20px;
        left: 20px;
      }
      .date-panel {
        bottom: 100px; 
        left: 20px;
      }
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="cycleCanvas"></canvas>

    <!-- FPS Panel (stats) -->
    <div class="stats panel" id="stats">FPS: 60</div>

    <!-- Controls Panel -->
    <div class="controls panel" id="controls">
      <button id="pause-btn">Pause</button>
      <button id="reset-btn">Reset</button>
      <button id="speed-down-btn">Slower</button>
      <button id="speed-up-btn">Faster</button>
    </div>

    <!-- Date Display Panel -->
    <div class="date-panel panel" id="date-display">
      Current: 01/28/2021
    </div>
  </div>

  <script>
    /****************************************************
     * Cycle Resonance + Shorter Fibonacci Subcycles Code
     ****************************************************/
    const canvas = document.getElementById('cycleCanvas');
    const ctx = canvas.getContext('2d');

    const statsPanel = document.getElementById('stats');
    const dateDisplayPanel = document.getElementById('date-display');
    const pauseBtn = document.getElementById('pause-btn');
    const resetBtn = document.getElementById('reset-btn');
    const speedDownBtn = document.getElementById('speed-down-btn');
    const speedUpBtn = document.getElementById('speed-up-btn');

    // Playback / scrubbing
    let isPaused = false;
    let isScrubbing = false;
    let scrubStartX = 0;

    // FPS tracking
    let lastTime = performance.now();
    let frameCount = 0;

    // Slower starting speed
    let speedMultiplier = 0.1;

    /**
     * Define cycle lengths (days):
     *  - e.g. 4-year main cycle, plus fib subcycles
     */
    const CYCLES = [
      { name: 'MAIN(4yrs)', length: 1461, color: 'var(--limegreen-color)' },
      { name: '741-day',    length: 741,  color: 'var(--limegreen-color)' },
      { name: '147-day',    length: 147,  color: 'var(--limegreen-color)' },
      { name: '55-day',     length: 55,   color: 'var(--limegreen-color)' },
      { name: '35-day',     length: 35,   color: 'var(--limegreen-color)' },
      { name: '21-day',     length: 21,   color: 'var(--limegreen-color)' }
    ];

    /**
     * Key dates (crucial or speculative)
     */
    const START_DATE = new Date(2021, 0, 28);
    const CRUCIAL_DATES = [
      new Date(2025, 0, 9),
      new Date(2025, 0, 12),
      new Date(2025, 0, 23), 
      new Date(2025, 0, 28),
      new Date(2024, 4, 1)
    ];

    // Time in “days since START_DATE”
    let time = 0;

    /** Resize the canvas to fill the window */
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    /** Utility to format date in a readable form */
    function formatDate(date) {
      return date.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
    }

    /**
     * Draw a single cycle ring + its “progress” marker
     * -> The ring uses cycleColor
     * -> The marker is set to white so it’s clearly visible
     */
    function drawCycleRing(x, y, radius, progress, cycleColor) {
      const angle = progress * 2 * Math.PI;
      // Outer circle
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.strokeStyle = cycleColor;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Marker dot: White fill so it doesn't blend into the background
      const markerX = x + Math.cos(angle) * radius;
      const markerY = y + Math.sin(angle) * radius;
      ctx.beginPath();
      ctx.arc(markerX, markerY, 6, 0, 2 * Math.PI);
      ctx.fillStyle = '#fff'; // White marker
      ctx.fill();
    }

    /**
     * Check if date is near a “crucial” date or if 2 cycles align
     */
    function checkResonance(x, y, radius, progressA, progressB, currentDate) {
      const threshold = 0.02;
      const diff = Math.abs(progressA - progressB);

      // Is currentDate near any crucial date?
      const nearCrucial = CRUCIAL_DATES.some(cd => {
        const dayDiff = Math.abs(currentDate - cd) / (1000 * 60 * 60 * 24);
        return dayDiff < 1;
      });

      // If cycles line up or near crucial date, highlight with green glow
      if (diff < threshold || Math.abs(1 - diff) < threshold || nearCrucial) {
        ctx.beginPath();
        ctx.arc(x, y, radius * 1.2, 0, 2 * Math.PI);
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
    }

    /**
     * Draw all cycles & check resonances
     */
    function drawAllCycles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      // Space out rings based on how many cycles we have
      const ringSpacing = Math.min(canvas.width, canvas.height) / (2 * CYCLES.length);

      // Convert “time” to date object
      const currentDate = new Date(START_DATE.getTime() + time * 24 * 60 * 60 * 1000);

      // 1) Compute cycle progress & draw each ring
      let cycleProgresses = [];
      CYCLES.forEach((cycle, idx) => {
        const progress = (time % cycle.length) / cycle.length;
        cycleProgresses.push(progress);

        // Largest radius for the first cycle, smaller for subsequent
        const ringRadius = ringSpacing * (CYCLES.length - idx);
        drawCycleRing(centerX, centerY, ringRadius, progress, cycle.color);
      });

      // 2) Check resonances between every pair of cycles
      for (let i = 0; i < CYCLES.length; i++) {
        for (let j = i + 1; j < CYCLES.length; j++) {
          const ringRadius = ringSpacing * (CYCLES.length - i);
          checkResonance(centerX, centerY, ringRadius, cycleProgresses[i], cycleProgresses[j], currentDate);
        }
      }

      // Update the date display
      dateDisplayPanel.textContent = `Current: ${formatDate(currentDate)}`;
    }

    /**
     * Main animation loop
     */
    function animate() {
      drawAllCycles();

      // FPS tracking
      frameCount++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        statsPanel.textContent = `FPS: ${frameCount}`;
        frameCount = 0;
        lastTime = now;
      }

      // Advance time if not paused/scrubbing
      if (!isPaused && !isScrubbing) {
        time += speedMultiplier;
      }

      requestAnimationFrame(animate);
    }

    /** Canvas resizing */
    function onResize() {
      resizeCanvas();
    }

    /** Touch-based scrubbing */
    function onTouchStart(e) {
      isScrubbing = true;
      scrubStartX = e.touches[0].clientX;
    }

    function onTouchMove(e) {
      if (!isScrubbing) return;
      const currentX = e.touches[0].clientX;
      const deltaX = currentX - scrubStartX;
      const dayDelta = deltaX / 10; // horizontal drag sensitivity
      time += dayDelta;
      scrubStartX = currentX;
    }

    function onTouchEnd() {
      isScrubbing = false;
    }

    /** Button event handlers */
    function togglePause() {
      isPaused = !isPaused;
      pauseBtn.textContent = isPaused ? 'Play' : 'Pause';
    }

    function resetTime() {
      time = 0;
    }

    function speedDown() {
      speedMultiplier = Math.max(speedMultiplier / 2, 0.01);
    }

    function speedUp() {
      speedMultiplier = Math.min(speedMultiplier * 2, 16);
    }

    /* Attach listeners */
    window.addEventListener('resize', onResize);
    canvas.addEventListener('touchstart', onTouchStart);
    canvas.addEventListener('touchmove', onTouchMove);
    canvas.addEventListener('touchend', onTouchEnd);

    pauseBtn.addEventListener('click', togglePause);
    resetBtn.addEventListener('click', resetTime);
    speedDownBtn.addEventListener('click', speedDown);
    speedUpBtn.addEventListener('click', speedUp);

    /* Init */
    resizeCanvas();
    animate();
  </script>
</body>
</html>
