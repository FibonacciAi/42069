<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Grift Network â€“ USAID Unmasked</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Unmask USAID grift with an interactive 3D network. Dig into NGO funding connections and expose fraud." />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><path fill='%23fff' d='M12 2L2 22h20L12 2zm0 4l6.5 14h-13L12 6z'/></svg>" />
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "axios": "https://unpkg.com/axios/dist/esm/axios.min.js"
    }
  }
  </script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      overflow: hidden;
      line-height: 1.6;
    }
    .top-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(20, 20, 20, 0.9);
      backdrop-filter: blur(10px);
      padding: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      z-index: 100;
      border-bottom: 1px solid #404040;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.6);
    }
    .control-group {
      display: flex;
      gap: 8px;
      align-items: center;
      flex: 1;
      min-width: 280px;
    }
    .btn {
      background: #252525;
      color: #fff;
      border: 1px solid #505050;
      border-radius: 5px;
      padding: 6px 12px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
    }
    .btn:hover { background: #353535; border-color: #707070; transform: translateY(-1px); }
    .btn:active { transform: translateY(1px); }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .input {
      background: #151515;
      color: #e0e0e0;
      border: 1px solid #404040;
      border-radius: 5px;
      padding: 6px 10px;
      flex: 1;
      font-size: 14px;
    }
    .input:focus { border-color: #00aaff; outline: none; }
    .slider-container { display: flex; align-items: center; gap: 5px; }
    input[type=range] { width: 80px; accent-color: #00aaff; }
    #strengthValue { width: 32px; text-align: center; font-family: monospace; }
    .status-box {
      position: fixed;
      bottom: 15px;
      left: 15px;
      background: rgba(20, 20, 20, 0.9);
      backdrop-filter: blur(10px);
      padding: 10px 15px;
      border-radius: 6px;
      border: 1px solid #404040;
      z-index: 100;
      max-width: 40vw;
      font-size: 13px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    .analysis-log {
      position: fixed;
      bottom: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(20, 20, 20, 0.9);
      backdrop-filter: blur(10px);
      width: 400px;
      max-height: 40vh;
      border: 1px solid #404040;
      border-radius: 6px;
      padding: 10px;
      overflow-y: auto;
      z-index: 150;
      display: none;
      font-size: 13px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    .thought-panel {
      position: fixed;
      right: 15px;
      top: 80px;
      background: rgba(20, 20, 20, 0.9);
      backdrop-filter: blur(10px);
      padding: 15px;
      border-radius: 6px;
      border: 1px solid #404040;
      width: 300px;
      max-height: 60vh;
      overflow-y: auto;
      z-index: 90;
      display: none;
      font-size: 13px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    .thought-item {
      background: #1a1a1a;
      padding: 8px 12px;
      border-radius: 4px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .thought-item:hover { background: #252525; }
    #threeCanvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    .suggestions-panel {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      flex-wrap: wrap;
    }
    .suggestion-btn {
      background: #303030;
      color: #e0e0e0;
      border: 1px solid #505050;
      border-radius: 4px;
      padding: 4px 10px;
      cursor: pointer;
      font-size: 12px;
    }
    .suggestion-btn:hover { background: #404040; border-color: #707070; }
    .lightbox {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }
    .lightbox-content {
      background: #151515;
      padding: 20px;
      border-radius: 8px;
      max-width: 80vw;
      max-height: 80vh;
      overflow-y: auto;
      color: #e0e0e0;
      font-size: 14px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.7);
    }
    #closeLightboxBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      font-size: 24px;
      color: #fff;
      cursor: pointer;
    }
    #closeLightboxBtn:hover { color: #00aaff; }
    .hidden { display: none; }
    @media (max-width: 600px) {
      .top-bar { padding: 8px; }
      .control-group { min-width: 100%; }
      .status-box { max-width: 80vw; font-size: 12px; }
      .analysis-log { width: 90vw; }
      .thought-panel { width: 90vw; right: 5vw; }
    }
    @font-face {
      font-family: 'Inter';
      src: url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap') format('woff2');
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div class="control-group">
      <input type="text" class="input" id="thoughtInput" placeholder="Enter a Thought & Press Enter" />
    </div>
    <div class="control-group">
      <input type="password" class="input" id="apiKeyInput" placeholder="Enter API Key (sk-...)" />
      <button class="btn" id="connectKeyBtn">Connect</button>
      <button class="btn" id="changeApiBtn">Reset</button>
      <button class="btn" id="loadPredefinedBtn">Load Sample NGOs</button>
    </div>
    <div class="control-group">
      <div class="slider-container">
        <label for="linkStrength">Link:</label>
        <input type="range" id="linkStrength" min="0" max="100" value="50" />
        <span id="strengthValue">0.50</span>
      </div>
      <button class="btn" id="toggleAnalysisLogBtn">Analysis</button>
      <button class="btn" id="toggleThoughtsPanelBtn">Thoughts</button>
      <button class="btn" id="exportBtn">Export</button>
      <button class="btn" id="shareXBtn">Share</button>
    </div>
  </div>
  <div class="status-box" id="statusBox">
    <strong>@DataRepublican ðŸ§µ USAID GRIFT UNMASKED:</strong><br />
    Connect your API key to start exposing the grift!
  </div>
  <div class="analysis-log" id="analysisLog">
    <strong style="color: #00aaff;">Ongoing Analysis</strong>
    <button id="closeAnalysisLogBtn" class="btn">Ã—</button>
    <div id="analysisLogMessages"></div>
  </div>
  <div class="thought-panel" id="thoughtPanel">
    <h3 style="margin: 0; color: #00aaff;">Thoughts</h3>
    <div id="thoughtsList"></div>
  </div>
  <canvas id="threeCanvas"></canvas>
  <div id="lightboxAnalysis" class="lightbox hidden">
    <div class="lightbox-content">
      <button id="closeLightboxBtn">Ã—</button>
      <div id="lightboxContent"></div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import axios from 'axios';

    let scene, camera, renderer, controls, networkGroup;
    let thoughts = [];
    let connections = [];
    let linkStrength = 0.5;
    let apiKey = "";
    let sampleNGOsLoaded = false;
    let selectedNode = null;

    const preloaded = [
      { name: "NATIONAL ENDOWMENT FOR DEMOCRACY\n(EIN: 52-1344831)", data: "Gross receipts: $363M\nTaxpayer funds: $362M", lines: [] },
      { name: "CONSORTIUM FOR ELECTIONS &\n(EIN: 52-1943638)", data: "Gross receipts: $165M\nTaxpayer funds: $165M", lines: [] },
      { name: "INTERNATIONAL FOUNDATION FOR\n(EIN: 52-1527835)", data: "Gross receipts: $78M\nTaxpayer funds: $59M", lines: [] },
      { name: "NATIONAL DEMOCRATIC INSTITUTE\n(EIN: 52-1338892)", data: "Gross receipts: $172M\nTaxpayer funds: $168M", lines: [] },
      { name: "CENTER FOR INTERNATIONAL\n(EIN: 52-1398742)", data: "Gross receipts: $50M\nTaxpayer funds: $50M", lines: [] },
      { name: "INTERNATIONAL REPUBLICAN INSTITUTE\n(EIN: 52-1340267)", data: "Gross receipts: $135M\nTaxpayer funds: $131M", lines: [] },
      { name: "INTERNEWS NETWORK\n(EIN: 94-3027961)", data: "Gross receipts: $124M\nTaxpayer funds: $94M", lines: [] }
    ];
    preloaded[0].lines.push({ target: 1, amount: 49137537 });
    preloaded[0].lines.push({ target: 2, amount: 107669 });
    preloaded[0].lines.push({ target: 3, amount: 51707077 });
    preloaded[0].lines.push({ target: 4, amount: 39199882 });
    preloaded[0].lines.push({ target: 5, amount: 33751325 });
    preloaded[0].lines.push({ target: 6, amount: 497201 });
    preloaded[1].lines.push({ target: 3, amount: 64298125 });
    preloaded[2].lines.push({ target: 3, amount: 2284520 });
    preloaded[3].lines.push({ target: 5, amount: 1088062 });
    preloaded[3].lines.push({ target: 6, amount: 0 });
    preloaded[5].lines.push({ target: 6, amount: 0 });

    function setStatus(msg) { document.getElementById('statusBox').innerHTML = msg; }
    function logAnalysis(msg, isError = false) {
      const container = document.getElementById('analysisLogMessages');
      const div = document.createElement('div');
      div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      div.style.color = isError ? '#ff5555' : '#e0e0e0';
      container.appendChild(div);
      container.scrollTop = container.scrollHeight;
    }

    function initThree() {
      const canvas = document.getElementById('threeCanvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a0a0a);
      scene.fog = new THREE.Fog(0x0a0a0a, 500, 2000);

      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2500);
      camera.position.set(0, 200, 800);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.dampingFactor = 0.1;
      controls.enableDamping = true;
      controls.maxDistance = 1500;
      controls.minDistance = 100;

      networkGroup = new THREE.Group();
      scene.add(networkGroup);

      const ambientLight = new THREE.AmbientLight(0x404040, 1.2);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
      directionalLight.position.set(300, 400, 500);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const particleCount = 300;
      const particles = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 1500;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 1500;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 1500;
      }
      particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const particleMaterial = new THREE.PointsMaterial({
        color: 0x00aaff,
        size: 2,
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending
      });
      scene.add(new THREE.Points(particles, particleMaterial));

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      updateLayout();
      thoughts.forEach(t => {
        const dist = camera.position.distanceTo(t.mesh.position);
        t.mesh.visible = dist < 1500;
        t.mesh.rotation.y += t.mesh.userData.hover ? 0.05 : 0.01;
      });
      renderer.render(scene, camera);
    }

    function updateLayout() {
      thoughts.forEach(n => {
        n.velocity = n.velocity || new THREE.Vector3();
        thoughts.forEach(n2 => {
          if (n === n2) return;
          const diff = n2.mesh.position.clone().sub(n.mesh.position);
          const dist = diff.length();
          const force = dist < 250 ? -0.05 / (dist + 1) : 0;
          n.velocity.addScaledVector(diff, force);
        });
        connections.forEach(c => {
          if (c.from === n || c.to === n) {
            const other = c.from === n ? c.to : c.from;
            const pull = other.mesh.position.clone().sub(n.mesh.position).normalize().multiplyScalar(c.strength * 0.2);
            n.velocity.add(pull);
          }
          // Optimized connection rendering: update positions without recreating geometry
          if (!c.curve) c.curve = new THREE.CatmullRomCurve3([c.from.mesh.position, c.to.mesh.position]);
          c.curve.points[0].copy(c.from.mesh.position);
          c.curve.points[1].copy(c.to.mesh.position);
          c.line.geometry.computeBoundingSphere(); // Update bounding sphere for frustum culling
          c.line.geometry.attributes.position.needsUpdate = true; // Flag position updates
          c.line.material.opacity = Math.min(1, Math.max(0.2, c.strength)); // Ensure visibility
          c.line.material.emissiveIntensity = Math.sin(Date.now() * 0.002) * 0.4 + 0.6;
          c.line.visible = c.strength >= linkStrength; // Toggle visibility based on threshold
        });
        n.velocity.multiplyScalar(0.95);
        n.mesh.position.add(n.velocity);
        if (n.preloaded && n.mesh.position.length() > 350) n.mesh.position.multiplyScalar(0.98);
      });
    }

    function createTextSprite(text) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const lines = text.split("\n");
      const fontSize = 24;
      const pad = 10;
      ctx.font = `bold ${fontSize}px Inter`;
      const maxWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
      canvas.width = maxWidth + pad * 2;
      canvas.height = fontSize * lines.length + pad * 2;
      ctx.font = `bold ${fontSize}px Inter`;
      ctx.fillStyle = '#e0e0e0';
      ctx.shadowColor = '#00aaff';
      ctx.shadowBlur = 6;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      lines.forEach((line, i) => ctx.fillText(line, pad, pad + fontSize * i + fontSize / 2));
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, transparent: true }));
      sprite.scale.set(0.3 * canvas.width, 0.3 * canvas.height, 1);
      return sprite;
    }

    function createNodeMesh(title, details, fraudScore = 0, preloaded = false) {
      const geo = new THREE.SphereGeometry(12 + fraudScore / 8, 32, 32);
      const mat = new THREE.MeshPhongMaterial({
        color: fraudScore > 75 ? 0xff5555 : 0x00aaff,
        emissive: fraudScore > 75 ? 0x550000 : 0x002244,
        emissiveIntensity: 0.5,
        shininess: 100,
        specular: 0x888888
      });
      const sphere = new THREE.Mesh(geo, mat);
      sphere.castShadow = true;
      const label = createTextSprite(`${title}\n${details}\nFraud: ${fraudScore}%`);
      label.position.set(0, 25 + fraudScore / 10, 0);
      sphere.add(label);
      sphere.position.set((Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150, (Math.random() - 0.5) * 150);
      sphere.preloaded = preloaded;
      sphere.userData.hover = false;
      networkGroup.add(sphere);
      return sphere;
    }

    function createConnectionLine(fromObj, toObj, strength, fraudScore) {
      const curve = new THREE.CatmullRomCurve3([fromObj.mesh.position.clone(), toObj.mesh.position.clone()]);
      const geo = new THREE.TubeGeometry(curve, 20, Math.max(3, fraudScore / 15), 8, false);
      const mat = new THREE.MeshPhongMaterial({
        color: fraudScore > 75 ? 0xff5555 : 0x00ffaa,
        transparent: true,
        opacity: Math.min(1, Math.max(0.2, strength)),
        emissive: fraudScore > 75 ? 0x330000 : 0x004422,
        emissiveIntensity: 0.6,
        shininess: 80
      });
      const tube = new THREE.Mesh(geo, mat);
      tube.visible = strength >= linkStrength; // Initial visibility
      networkGroup.add(tube);
      return tube;
    }

    function loadPredefinedNGOs() {
      if (sampleNGOsLoaded) return;
      sampleNGOsLoaded = true;
      preloaded.forEach((org, i) => {
        const node = {
          id: Date.now() + i,
          text: org.name,
          mesh: createNodeMesh(org.name, org.data, 0, true),
          analysis: { type: "preloaded", keywords: [] },
          timestamp: Date.now(),
          source: "",
          preloaded: true
        };
        node.mesh.userData.thoughtId = node.id;
        thoughts.push(node);
      });
      preloaded.forEach((org, i) => {
        const fromObj = thoughts[i];
        org.lines.forEach(l => {
          const toObj = thoughts[l.target];
          const scaled = Math.min(1, Math.max(0.4, l.amount / 50000000));
          if (scaled >= linkStrength) {
            connections.push({
              from: fromObj,
              to: toObj,
              strength: scaled,
              fraudScore: 0,
              line: createConnectionLine(fromObj, toObj, scaled, 0),
              curve: null // Will be initialized in updateLayout
            });
          }
        });
      });
      updateThoughtsList();
      setStatus("Sample NGOs loaded! Start digging.");
      reanalyzeAllConns().then(updateNetworkAnalysis);
    }

    async function fetchLiveData(query) {
      setStatus(`Fetching data for "${query}"...`);
      try {
        const res = await axios.get(`https://api.usaspending.gov/v2/awards/?keyword=${encodeURIComponent(query)}&limit=5`);
        const awards = res.data.results.slice(0, 5).map(award => ({
          name: award.recipient.recipient_name,
          data: `Award: $${(award.total_obligation / 1e6).toFixed(1)}M\nDate: ${new Date(award.date_signed).toLocaleDateString()}`,
          source: `https://www.usaspending.gov/award/${award.award_id}`
        }));
        awards.forEach(award => addThought(`${award.name}\n${award.data}`, award.source));
        setStatus(`Loaded ${awards.length} records!`);
      } catch (err) {
        logAnalysis(`Fetch failed: ${err.message}`, true);
        setStatus("Data fetch failed. Try again!");
      }
    }

    async function reanalyzeAllConns() {
      connections.forEach(c => networkGroup.remove(c.line));
      connections = [];

      // Restore preloaded connections
      preloaded.forEach((org, i) => {
        const fromObj = thoughts.find(t => t.text === org.name);
        if (!fromObj) return;
        org.lines.forEach(l => {
          const toObj = thoughts[l.target];
          if (!toObj) return;
          const scaled = Math.min(1, Math.max(0.4, l.amount / 50000000));
          if (scaled >= linkStrength) {
            connections.push({
              from: fromObj,
              to: toObj,
              strength: scaled,
              fraudScore: 0,
              line: createConnectionLine(fromObj, toObj, scaled, 0),
              curve: null
            });
          }
        });
      });

      // Analyze non-preloaded or mixed connections
      for (let i = 0; i < thoughts.length; i++) {
        for (let j = i + 1; j < thoughts.length; j++) {
          const t1 = thoughts[i];
          const t2 = thoughts[j];
          if (t1.preloaded && t2.preloaded) continue; // Skip preloaded pairs
          const res = await makeAnalysisCall(t1.text, t2.text);
          if (res.strength >= linkStrength) {
            connections.push({
              from: t1,
              to: t2,
              strength: res.strength,
              fraudScore: res.fraudScore,
              line: createConnectionLine(t1, t2, res.strength, res.fraudScore),
              curve: null
            });
          }
        }
      }
    }

    async function makeAnalysisCall(t1, t2) {
      if (!apiKey) return { strength: Math.random() * 0.5 + 0.4, fraudScore: Math.random() * 100, type: "mock", keywords: ["test"] }; // Mock for testing
      logAnalysis(`Analyzing "${t1.slice(0, 15)}..." vs "${t2.slice(0, 15)}..."`);
      const prompt = `Analyze these texts for fraud or corruption (e.g., circular funding, shell entities). Return JSON with:
- "strength": (0-1) connection strength,
- "fraudScore": (0-100) likelihood of fraud,
- "type": "suspicious" if fraud detected, else "contextual",
- "keywords": relevant terms.
Text 1: "${t1}"
Text 2: "${t2}"`;
      try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            messages: [{ role: "system", content: "Youâ€™re a fraud detection expert." }, { role: "user", content: prompt }],
            temperature: 0.3
          })
        });
        const data = await response.json();
        const result = JSON.parse(data.choices[0].message.content);
        logAnalysis(`Strength: ${result.strength.toFixed(2)}, Fraud: ${result.fraudScore}%`);
        return result;
      } catch (err) {
        logAnalysis(`Analysis error: ${err.message}`, true);
        return { strength: 0, fraudScore: 0, type: "none", keywords: [] };
      }
    }

    async function makeSuggestionCall(currentThoughts) {
      if (!apiKey) return [];
      const combinedTexts = currentThoughts.map(t => t.text).join("\n");
      const prompt = `Based on these NGO funding texts, suggest 3 new terms or entities (e.g., agencies, people) not mentioned to uncover USAID connections. Return JSON array of strings.
Texts:
${combinedTexts}`;
      try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            messages: [{ role: "system", content: "Youâ€™re an investigative journalist." }, { role: "user", content: prompt }],
            temperature: 0.5
          })
        });
        const data = await response.json();
        const suggestions = JSON.parse(data.choices[0].message.content).slice(0, 3);
        logAnalysis(`Suggested: ${suggestions.join(", ")}`);
        return suggestions;
      } catch (err) {
        logAnalysis(`Suggestion error: ${err.message}`, true);
        return [];
      }
    }

    async function updateNetworkAnalysis() {
      if (thoughts.length < 1) return;
      const suspicious = connections.filter(c => c.fraudScore > 75).length;
      const total = connections.length;
      const summary = `Nodes: ${thoughts.length} | Links: ${total}<br>Suspicious Links: ${suspicious}`;
      document.getElementById('analysisLogMessages').innerHTML = summary;
      const suggestions = await makeSuggestionCall(thoughts);
      renderSuggestions(suggestions);
    }

    function renderSuggestions(list) {
      const panel = document.createElement('div');
      panel.className = "suggestions-panel";
      panel.innerHTML = "<strong style='color: #00aaff;'>Suggested:</strong>";
      list.forEach(item => {
        const btn = document.createElement('button');
        btn.className = "suggestion-btn";
        btn.textContent = item;
        btn.onclick = () => addThought(item);
        panel.appendChild(btn);
      });
      const statusBox = document.getElementById('statusBox');
      statusBox.innerHTML = statusBox.innerHTML.split('<div')[0];
      statusBox.appendChild(panel);
    }

    async function addThought(txt, source = "") {
      if (thoughts.length >= 50) {
        setStatus("Max nodes (50) reached! Export or reset.");
        return;
      }
      const tObj = {
        id: Date.now(),
        text: txt,
        mesh: createNodeMesh(txt, source ? `Source: ${source}` : "", 0),
        analysis: null,
        timestamp: Date.now(),
        source,
        preloaded: false
      };
      tObj.mesh.userData.thoughtId = tObj.id;
      thoughts.push(tObj);
      updateThoughtsList();
      controls.target.copy(tObj.mesh.position);
      if (thoughts.length > 1) {
        for (const older of thoughts.slice(0, -1)) {
          const res = await makeAnalysisCall(tObj.text, older.text);
          tObj.analysis = res;
          if (res.strength >= linkStrength) {
            connections.push({
              from: tObj,
              to: older,
              strength: res.strength,
              fraudScore: res.fraudScore,
              line: createConnectionLine(tObj, older, res.strength, res.fraudScore),
              curve: null
            });
          }
        }
        await reanalyzeAllConns();
      }
      updateNetworkAnalysis();
      fetchLiveData(txt);
      setStatus(`Added "${txt.slice(0, 20)}..."!`);
    }

    function removeThought(id) {
      const idx = thoughts.findIndex(t => t.id === id);
      if (idx < 0) return;
      const rem = thoughts[idx];
      connections = connections.filter(c => {
        if (c.from === rem || c.to === rem) {
          networkGroup.remove(c.line);
          return false;
        }
        return true;
      });
      networkGroup.remove(rem.mesh);
      thoughts.splice(idx, 1);
      updateThoughtsList();
      updateNetworkAnalysis();
    }

    function updateThoughtsList() {
      const container = document.getElementById('thoughtsList');
      container.innerHTML = "";
      thoughts.forEach(t => {
        const div = document.createElement('div');
        div.className = "thought-item";
        div.innerHTML = `<span>${t.text.replace(/\n/g, '<br>')}</span><button class="btn" onclick="removeThought(${t.id})">Ã—</button>`;
        container.appendChild(div);
      });
    }

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    function onClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(networkGroup.children, true);
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        if (obj.userData?.thoughtId) {
          const thought = thoughts.find(t => t.id === obj.userData.thoughtId);
          if (thought) showLightboxAnalysis(thought);
        }
      }
    }

    function onMouseMove(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(networkGroup.children, true);
      thoughts.forEach(t => t.mesh.userData.hover = false);
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        if (obj.userData?.thoughtId) {
          thoughts.find(t => t.id === obj.userData.thoughtId).mesh.userData.hover = true;
        }
      }
    }

    async function showLightboxAnalysis(thought) {
      const lightbox = document.getElementById('lightboxAnalysis');
      const content = document.getElementById('lightboxContent');
      content.innerHTML = "<p>Analyzing...</p>";
      lightbox.classList.remove('hidden');
      const analysis = await getDetailedNodeAnalysis(thought);
      content.innerHTML = `<h2 style="color: #00aaff;">${thought.text}</h2><p>${analysis.replace(/\n/g, '<br>')}</p>`;
      selectedNode = thought;
    }

    async function getDetailedNodeAnalysis(thought) {
      if (!apiKey) return "No API key connected!";
      const related = connections.filter(c => c.from === thought || c.to === thought)
                                 .map(c => `${c.from === thought ? c.to.text : c.from.text} (Fraud: ${c.fraudScore}%)`);
      const prompt = `Analyze this thought and its connections for USAID funding corruption. Suggest 2-3 next steps. Return concise text.
Thought: "${thought.text}"
Connected: ${related.join("; ") || "None"}`;
      try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            messages: [{ role: "system", content: "Youâ€™re an expert investigator." }, { role: "user", content: prompt }],
            temperature: 0.4
          })
        });
        const data = await response.json();
        return data.choices[0].message.content;
      } catch (err) {
        return `Analysis failed: ${err.message}`;
      }
    }

    window.addEventListener('click', onClick);
    window.addEventListener('mousemove', onMouseMove);
    window.removeThought = removeThought;

    document.getElementById('connectKeyBtn').addEventListener('click', () => {
      apiKey = document.getElementById('apiKeyInput').value.trim();
      setStatus(apiKey ? "API Key connected! Ready to dig." : "No key entered!");
    });
    document.getElementById('changeApiBtn').addEventListener('click', () => {
      apiKey = "";
      document.getElementById('apiKeyInput').value = "";
      thoughts.forEach(t => networkGroup.remove(t.mesh));
      thoughts = [];
      connections.forEach(c => networkGroup.remove(c.line));
      connections = [];
      updateThoughtsList();
      setStatus("Reset complete! Add a new API key.");
      sampleNGOsLoaded = false;
      document.getElementById('loadPredefinedBtn').disabled = false;
    });
    document.getElementById('thoughtInput').addEventListener('keypress', (ev) => {
      if (ev.key === "Enter" && ev.target.value.trim()) {
        if (!apiKey) return setStatus("Connect an API key first!");
        addThought(ev.target.value.trim());
        ev.target.value = "";
      }
    });
    document.getElementById('linkStrength').addEventListener('input', (ev) => {
      linkStrength = ev.target.value / 100;
      document.getElementById('strengthValue').textContent = linkStrength.toFixed(2);
      reanalyzeAllConns().then(updateNetworkAnalysis);
    });
    document.getElementById('loadPredefinedBtn').addEventListener('click', () => {
      loadPredefinedNGOs();
      document.getElementById('loadPredefinedBtn').disabled = true;
    });
    document.getElementById('toggleAnalysisLogBtn').addEventListener('click', () => {
      const log = document.getElementById('analysisLog');
      log.style.display = log.style.display === "none" ? "block" : "none";
      if (log.style.display === "block") updateNetworkAnalysis();
    });
    document.getElementById('toggleThoughtsPanelBtn').addEventListener('click', () => {
      const panel = document.getElementById('thoughtPanel');
      panel.style.display = panel.style.display === "none" ? "block" : "none";
    });
    document.getElementById('closeAnalysisLogBtn').addEventListener('click', () => {
      document.getElementById('analysisLog').style.display = "none";
    });
    document.getElementById('closeLightboxBtn').addEventListener('click', () => {
      document.getElementById('lightboxAnalysis').classList.add('hidden');
    });
    document.getElementById('exportBtn').addEventListener('click', () => {
      const data = JSON.stringify({ thoughts, connections }, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `usaid-grift-${new Date().toISOString().slice(0, 10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    });
    document.getElementById('shareXBtn').addEventListener('click', () => {
      const topFraud = connections.reduce((max, c) => c.fraudScore > max.fraudScore ? c : max, { fraudScore: 0 });
      const tweet = `@DataRepublican USAID grift: ${thoughts.length} nodes, ${connections.length} links. Top fraud: ${topFraud.fraudScore}% - ${window.location.href}`;
      window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(tweet)}`, '_blank');
    });

    window.addEventListener("DOMContentLoaded", () => {
      initThree();
      setStatus("Connect your API key to unmask USAID grift!");
    });
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹â€‹
