<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fibonacci Seed of Life - Three.js 3D Experience</title>
  <style>
    body {
      margin: 0;
      overflow: hidden; /* Remove scrollbars */
      background-color: #000; /* black background */
      font-family: sans-serif;
    }
    #infoPanel {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      z-index: 999;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
      user-select: none;
    }
    button {
      cursor: pointer;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 5px 10px;
      margin: 2px 0;
      border-radius: 3px;
      transition: all 0.3s ease;
    }
    button:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    #tooltip {
      position: absolute;
      pointer-events: none;
      display: none;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.9);
      color: #000;
      font-size: 14px;
      border-radius: 5px;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="infoPanel">
    <button id="btnReset">Reset View</button>
    <button id="btnRandomize">Randomize Colors</button>
    <button id="btnToggleRotation">Toggle Auto-Rotation</button>
  </div>
  <div id="tooltip"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    /**********************************************************
     * Basic Three.js Setup
     **********************************************************/
    let scene, camera, renderer, controls;
    let seedGroup; // will contain circles, text, lines
    let autoRotate = true; // camera auto-rotation
    let rotationSpeed = 0.002; // how fast the camera auto-rotates
    const toolTip = document.getElementById('tooltip');

    init();
    animate();

    function init() {
      // Create scene
      scene = new THREE.Scene();

      // Set up camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
      camera.position.set(0, 0, 1000);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // OrbitControls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 300; // how close can zoom
      controls.maxDistance = 2000; // how far can zoom

      // Lights (ambient + point)
      scene.add(new THREE.AmbientLight(0xffffff, 0.4));
      const pointLight = new THREE.PointLight(0xffffff, 0.8);
      pointLight.position.set(1000, 1000, 1000);
      scene.add(pointLight);

      // Add the seed group
      seedGroup = new THREE.Group();
      scene.add(seedGroup);

      // Generate the pattern
      createSeedOfLife();

      // Listen to window resize
      window.addEventListener('resize', onWindowResize, false);

      // Hook up UI
      document.getElementById('btnReset').addEventListener('click', resetView);
      document.getElementById('btnRandomize').addEventListener('click', randomizeColors);
      document.getElementById('btnToggleRotation').addEventListener('click', () => {
        autoRotate = !autoRotate;
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    /**********************************************************
     * Fibonacci Sequence & Pattern Construction
     **********************************************************/
    function generateFibonacciSequence(n) {
      const seq = [0, 1];
      for (let i = 2; i < n; i++) {
        seq[i] = (seq[i - 1] + seq[i - 2]) % 10; // keep last digit
      }
      return seq;
    }
    const fibSequence = generateFibonacciSequence(60);

    function createSeedOfLife() {
      const radius = 300;

      // Outer circle
      const outerCircle = makeCircle(radius, 0xff00ff);
      seedGroup.add(outerCircle);

      // 6 circles for Seed of Life
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI * 2) / 6;
        const cx = Math.cos(angle) * radius * 0.5;
        const cy = Math.sin(angle) * radius * 0.5;
        const c = makeCircle(radius * 0.5, 0x00ffff);
        c.position.set(cx, cy, 0);
        seedGroup.add(c);
      }

      // Center circle
      const centerCircle = makeCircle(radius * 0.5, 0x00ff00);
      seedGroup.add(centerCircle);

      // 216 Fibonacci digits
      // 108 in outer ring, 108 in inner ring (0.75 * radius)
      // We'll also store each digit's 3D position for connecting lines.
      for (let i = 0; i < 216; i++) {
        const ringRadius = i < 108 ? radius : radius * 0.75;
        const angle = (i * 2 * Math.PI) / 108;
        const x = Math.cos(angle) * ringRadius;
        const y = Math.sin(angle) * ringRadius;
        const fibVal = fibSequence[i % 60];

        // Create the text sprite
        const colorHex = i < 108 ? 0xffff00 : 0xff00ff;
        const fibText = makeFibonacciText(fibVal, colorHex, i);
        fibText.position.set(x, y, 0);
        seedGroup.add(fibText);
      }
    }

    /**********************************************************
     * Geometry-Building Helpers
     **********************************************************/
    // Create a circle (wireframe ring)
    function makeCircle(r, colorHex) {
      const circleGeom = new THREE.CircleGeometry(r, 128);
      // Convert circle to wireframe ring
      // We'll use line segments to show edges only
      const edges = new THREE.EdgesGeometry(circleGeom);
      const mat = new THREE.LineBasicMaterial({ color: colorHex });
      const circle = new THREE.LineSegments(edges, mat);
      return circle;
    }

    // Create a text sprite for Fibonacci digits
    function makeFibonacciText(val, colorHex, index) {
      // We'll use a CSS-like sprite approach
      const canvas = document.createElement('canvas');
      const size = 64;
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#' + colorHex.toString(16).padStart(6, '0');
      ctx.font = 'bold 48px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(val, size / 2, size / 2);

      const tex = new THREE.Texture(canvas);
      tex.needsUpdate = true;
      const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sprite = new THREE.Sprite(spriteMat);
      // Scale it down so it's not huge in the scene
      sprite.scale.set(40, 40, 1);

      // Custom data for interactivity
      sprite.userData = {
        digitValue: val,
        index: index
      };

      // Mouse events: We'll do raycasting
      // (for simplicity, we handle tooltips in the animate() with a raycast)
      return sprite;
    }

    /**********************************************************
     * Interactivity: Raycasting for tooltips, etc.
     **********************************************************/
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('click', onDocumentClick, false);

    function onDocumentMouseMove(event) {
      // Convert mouse to normalized device coords
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    }

    function onDocumentClick() {
      // On click, find what we clicked
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(seedGroup.children, true);

      if (intersects.length > 0) {
        const obj = intersects[0].object;
        if (obj instanceof THREE.Sprite) {
          // It's a Fibonacci text sprite
          handleNumberClick(obj);
        }
      }
    }

    function handleNumberClick(sprite) {
      // Clear any old lines
      clearConnections();

      // Find all identical numbers
      const val = sprite.userData.digitValue;
      // console.log("Clicked digit:", val);

      // Connect lines to all matching digits
      const matchedSprites = seedGroup.children.filter(ch => {
        return (ch instanceof THREE.Sprite) && (ch.userData.digitValue === val);
      });

      // Draw lines from clicked sprite to each matching sprite
      matchedSprites.forEach(target => {
        if (target !== sprite) {
          const line = makeConnection(sprite.position, target.position, sprite.material.color.getHex());
          seedGroup.add(line);
        }
      });
    }

    // Make a line from p1 to p2
    function makeConnection(p1, p2, colorHex) {
      const geo = new THREE.BufferGeometry().setFromPoints([p1.clone(), p2.clone()]);
      const mat = new THREE.LineBasicMaterial({ color: colorHex });
      const line = new THREE.Line(geo, mat);
      line.userData.isConnection = true;
      return line;
    }

    function clearConnections() {
      // Remove any child with userData.isConnection === true
      const toRemove = [];
      seedGroup.children.forEach(ch => {
        if (ch.userData.isConnection) {
          toRemove.push(ch);
        }
      });
      toRemove.forEach(ch => seedGroup.remove(ch));
    }

    /**********************************************************
     * Tooltip Handling in Animate (via Raycaster)
     **********************************************************/
    function updateTooltip() {
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(seedGroup.children, true);

      if (intersects.length > 0) {
        const obj = intersects[0].object;
        if (obj instanceof THREE.Sprite) {
          toolTip.style.display = 'block';
          toolTip.style.left = (event.clientX + 10) + 'px';
          toolTip.style.top = (event.clientY + 10) + 'px';
          const digit = obj.userData.digitValue;
          const idx = obj.userData.index;
          toolTip.innerHTML = `
            <strong>Fibonacci digit:</strong> ${digit}<br/>
            Position: ${idx + 1} / 216
          `;
        } else {
          // Not a sprite
          toolTip.style.display = 'none';
        }
      } else {
        // No intersect
        toolTip.style.display = 'none';
      }
    }

    /**********************************************************
     * Animate Loop
     **********************************************************/
    function animate() {
      requestAnimationFrame(animate);

      // Auto-rotate camera around Y (to the left or right)
      if (autoRotate) {
        // We'll orbit by adjusting controls' azimuthAngle
        // Negative value to spin in the "other" direction
        controls.azimuthAngle -= rotationSpeed;
      }

      controls.update();
      updateTooltip();
      renderer.render(scene, camera);
    }

    /**********************************************************
     * UI Buttons
     **********************************************************/
    function resetView() {
      // Reset camera, controls, clear lines
      camera.position.set(0, 0, 1000);
      controls.target.set(0, 0, 0);
      controls.update();
      clearConnections();
    }

    function randomizeColors() {
      // Re-draw circles + text with random colors
      seedGroup.children.forEach(obj => {
        if (obj instanceof THREE.LineSegments) {
          // It's a circle or a connection line
          if (!obj.userData.isConnection) {
            obj.material.color.setHSL(Math.random(), 1.0, 0.5);
          }
        } else if (obj instanceof THREE.Sprite) {
          // Recreate text
          const val = obj.userData.digitValue;
          const idx = obj.userData.index;
          const newColor = new THREE.Color().setHSL(Math.random(), 1.0, 0.5);
          const canvas = document.createElement('canvas');
          const size = 64;
          canvas.width = size;
          canvas.height = size;
          const ctx = canvas.getContext('2d');
          ctx.fillStyle = '#' + newColor.getHexString();
          ctx.font = 'bold 48px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(val, size / 2, size / 2);

          const tex = new THREE.Texture(canvas);
          tex.needsUpdate = true;
          obj.material.map = tex;
          obj.material.color = newColor; // set base color too
        }
      });
    }
  </script>
</body>
</html>
