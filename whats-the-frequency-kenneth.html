<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vortex Mathematics Matrix</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
        }

        #container {
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .overlay {
            position: fixed;
            padding: 20px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            z-index: 1000;
        }

        #info-panel {
            top: 20px;
            left: 20px;
            max-width: 300px;
        }

        #controls {
            top: 20px;
            right: 20px;
        }

        .button {
            background: #1a1a1a;
            color: #fff;
            border: 1px solid #333;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .button:hover {
            background: #333;
            border-color: #88ccff;
        }

        .button.active {
            background: #88ccff;
            color: #000;
        }

        .analyzer-container {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(5px);
        }

        #frequency-spectrum {
            width: 100%;
            height: 150px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }

        .spectrum-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 12px;
            color: #88ccff;
        }

        #waveform {
            width: 100%;
            height: 80px;
            margin-top: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }

        .filter-controls {
            position: fixed;
            left: 20px;
            bottom: 20px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 300px;
            z-index: 1000;
        }

        .filter-slider {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-slider label {
            display: flex;
            justify-content: space-between;
            color: #88ccff;
            font-size: 14px;
        }

        .filter-slider input[type="range"] {
            width: 100%;
            height: 20px;
            -webkit-appearance: none;
            background: rgba(136, 204, 255, 0.2);
            border-radius: 10px;
            outline: none;
        }

        .filter-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #88ccff;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .filter-slider input[type="range"]::-webkit-slider-thumb:hover {
            background: #aaddff;
            transform: scale(1.1);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 5px;
        }

        .preset-button {
            background: rgba(136, 204, 255, 0.2);
            border: 1px solid #88ccff;
            color: #88ccff;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preset-button:hover {
            background: rgba(136, 204, 255, 0.4);
        }

        .filter-response {
            width: 100%;
            height: 60px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            margin-top: 5px;
        }
        /* Add to your existing CSS */
.button {
    /* ... existing styles ... */
    transition: all 0.3s ease;
}

#visualMode-default {
    background: linear-gradient(45deg, #00ff9d, #00ffb7);
    border-color: #00ff9d;
}

#visualMode-wireframe {
    background: linear-gradient(45deg, #ff00ee, #ff1493);
    border-color: #ff00ee;
}

#visualMode-particles {
    background: linear-gradient(45deg, #ff6b6b, #ffd700);
    border-color: #ff6b6b;
}

#visualMode-ribbons {
    background: linear-gradient(45deg, #4169e1, #00bfff);
    border-color: #4169e1;
}

.button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

.button.active {
    transform: translateY(1px);
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}
.control-group {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
}

.slider {
    width: 150px;
    height: 5px;
    -webkit-appearance: none;
    background: #333;
    outline: none;
    border-radius: 5px;
}

.slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 15px;
    height: 15px;
    border-radius: 50%;
    background: #4169E1;
    cursor: pointer;
}

.slider::-moz-range-thumb {
    width: 15px;
    height: 15px;
    border-radius: 50%;
    background: #4169E1;
    cursor: pointer;
}

#speedValue {
    color: white;
    font-size: 14px;
    min-width: 80px;
}
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="info-panel" class="overlay">
        <h2>Vortex Mathematics</h2>
        <p>Spirit is latent potential energy manifesting through numerical patterns.</p>
    </div>

   <div id="controls" class="overlay">
    <!-- Add these elements with your existing controls -->
    <div class="control-group">
        <button class="button" id="toggleRotation">Toggle Rotation</button>
        <input type="range" id="rotationSpeed" min="0" max="100" value="50" class="slider">
        <span id="speedValue">Speed: 0.01</span>
    </div>
</div>

    <div class="analyzer-container">
        <canvas id="frequency-spectrum"></canvas>
        <div class="spectrum-labels">
            <span>20 Hz</span>
            <span>100 Hz</span>
            <span>500 Hz</span>
            <span>1 kHz</span>
            <span>5 kHz</span>
            <span>20 kHz</span>
        </div>
        <canvas id="waveform"></canvas>
    </div>

    <div class="filter-controls">
        <h3 style="color: #88ccff; margin-bottom: 10px;">Frequency Filters</h3>
        
        <div class="filter-slider">
            <label>
                <span>Low-Pass Cutoff</span>
                <span id="lpf-value">20000 Hz</span>
            </label>
            <input type="range" id="lpf-frequency" min="20" max="20000" step="1" value="20000">
            <canvas id="lpf-response" class="filter-response"></canvas>
        </div>

        <div class="filter-slider">
            <label>
                <span>High-Pass Cutoff</span>
                <span id="hpf-value">20 Hz</span>
            </label>
            <input type="range" id="hpf-frequency" min="20" max="20000" step="1" value="20">
            <canvas id="hpf-response" class="filter-response"></canvas>
        </div>

        <div class="filter-slider">
            <label>
                <span>Peak Frequency</span>
                <span id="peak-value">1000 Hz</span>
            </label>
            <input type="range" id="peak-frequency" min="20" max="20000" step="1" value="1000">
            <input type="range" id="peak-gain" min="-12" max="12" step="0.1" value="0">
            <canvas id="peak-response" class="filter-response"></canvas>
        </div>

        <div class="preset-buttons">
            <button class="preset-button" data-preset="flat">Flat</button>
            <button class="preset-button" data-preset="bass">Bass Boost</button>
            <button class="preset-button" data-preset="vocal">Vocal Boost</button>
            <button class="preset-button" data-preset="air">Air Boost</button>
        </div>
    </div>

    <!-- Script tags will be added in the next parts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/FilmPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.137.0/examples/js/shaders/FilmShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script>
// Core Audio Engine Class
class AudioEngine {
    constructor() {
        this.initializeAudioContext();
        this.setupNodes();
        this.setupAnalyzers();
    }

    initializeAudioContext() {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        this.started = false;
    }

    setupNodes() {
        // Oscillator
        this.oscillator = this.audioCtx.createOscillator();
        this.oscillator.type = 'sine';
        this.oscillator.frequency.setValueAtTime(432, this.audioCtx.currentTime);

        // Gain
        this.masterGain = this.audioCtx.createGain();
        this.masterGain.gain.setValueAtTime(0.5, this.audioCtx.currentTime);

        // Compressor
        this.compressor = this.audioCtx.createDynamicsCompressor();
        this.compressor.threshold.setValueAtTime(-24, this.audioCtx.currentTime);
        this.compressor.knee.setValueAtTime(30, this.audioCtx.currentTime);
        this.compressor.ratio.setValueAtTime(12, this.audioCtx.currentTime);
        this.compressor.attack.setValueAtTime(0.003, this.audioCtx.currentTime);
        this.compressor.release.setValueAtTime(0.25, this.audioCtx.currentTime);
    }

    setupAnalyzers() {
        // FFT Analyzer
        this.fftAnalyzer = this.audioCtx.createAnalyser();
        this.fftAnalyzer.fftSize = 2048;
        this.fftBufferLength = this.fftAnalyzer.frequencyBinCount;
        this.fftDataArray = new Uint8Array(this.fftBufferLength);

        // Waveform Analyzer
        this.waveAnalyzer = this.audioCtx.createAnalyser();
        this.waveAnalyzer.fftSize = 1024;
        this.waveBufferLength = this.waveAnalyzer.frequencyBinCount;
        this.waveDataArray = new Uint8Array(this.waveBufferLength);

        // Connect nodes
        this.oscillator.connect(this.masterGain);
        this.masterGain.connect(this.compressor);
        this.compressor.connect(this.fftAnalyzer);
        this.fftAnalyzer.connect(this.waveAnalyzer);
        this.waveAnalyzer.connect(this.audioCtx.destination);
    }

    start() {
        if (!this.started) {
            this.oscillator.start();
            this.started = true;
        }
    }

    setFrequency(freq) {
        this.oscillator.frequency.setValueAtTime(freq, this.audioCtx.currentTime);
    }

    setVolume(volume) {
        this.masterGain.gain.setValueAtTime(volume, this.audioCtx.currentTime);
    }
}
// Add this BEFORE VisualizationEngine class definition
const visualModes = {
    default: {
        mesh: 0x00ff9d, // Vibrant cyan-green
        emissive: 0x005c36,
        alternate: {
            option1: 0x00ffb7, // Bright turquoise
            option2: 0x39ff14, // Electric green
            option3: 0x7fff00  // Chartreuse
        }
    },
    wireframe: {
        mesh: 0xff00ee, // Neon pink
        emissive: 0x800077,
        alternate: {
            option1: 0xff1493, // Deep pink
            option2: 0xff00ff, // Magenta
            option3: 0xff69b4  // Hot pink
        }
    },
    particles: {
        primary: 0xff6b6b, // Coral
        alternate: {
            option1: 0xffd700, // Gold
            option2: 0xff4500, // Orange red
            option3: 0xff8c00  // Dark orange
        }
    },
    ribbons: {
        primary: 0x4169e1, // Royal blue
        alternate: {
            option1: 0x00bfff, // Deep sky blue
            option2: 0x1e90ff, // Dodger blue
            option3: 0x87ceeb  // Sky blue
        }
    }
};
// Visualization Engine Class
class VisualizationEngine {
    constructor(audioEngine) {
    this.audioEngine = audioEngine;
    this.mode = 'default';
    this.setupCanvases();
    this.initializeThree();
    this.createParticleSystems();
    this.createRibbons();
    this.createOrbitRings(); // Add this line
    this.setupPostProcessing();
    this.animate();
}

    setupCanvases() {
        // [Previous canvas setup code remains the same]
    }

    initializeThree() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('container').appendChild(this.renderer.domElement);

        // Base geometry
        this.baseGeometry = new THREE.TorusKnotGeometry(2, 0.5, 256, 64, 2, 3);
        this.vertices = this.baseGeometry.attributes.position.array;
        this.originalVertices = [...this.vertices];

        // Materials
        // Update the materials section in initializeThree()
this.materials = {
    default: new THREE.MeshStandardMaterial({
        color: 0x4169E1,         // Royal Blue
        metalness: 0.8,
        roughness: 0.2,
        emissive: 0x1E90FF,      // Dodger Blue
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.9
    }),
    wireframe: new THREE.MeshStandardMaterial({
        color: 0x00BFFF,         // Deep Sky Blue
        wireframe: true,
        emissive: 0x87CEEB,      // Sky Blue
        emissiveIntensity: 0.7
    })
};

// Update the base geometry
this.baseGeometry = new THREE.TorusKnotGeometry(2, 0.6, 300, 80, 2, 3);

        // Main mesh
        this.vortexMesh = new THREE.Mesh(this.baseGeometry, this.materials.default);
        this.scene.add(this.vortexMesh);

        // Lighting
        this.setupLighting();

        // Camera position
        this.camera.position.z = 5;
        
        // Orbit controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;

        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            this.camera.aspect = width / height;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(width, height);
            this.composer.setSize(width, height);
        });
    }
createOrbitRings() {
    // First ring (top)
    this.createOrbitRing(0, 2.5, 0, 0);
    
    // Second ring (middle-right)
    this.createOrbitRing(1.5, 0, 45, Math.PI / 4);
    
    // Third ring (bottom-left)
    this.createOrbitRing(-1.5, -1.5, -30, -Math.PI / 6);
}

createOrbitRing(x, y, rotation, tilt) {
    const geometry = new THREE.TorusGeometry(3, 0.02, 16, 100);
    const material = new THREE.MeshBasicMaterial({
        color: 0xff3333,
        transparent: true,
        opacity: 0.6
    });
    const ring = new THREE.Mesh(geometry, material);
    ring.position.set(x, y, 0);
    ring.rotation.x = tilt;
    ring.rotation.z = rotation * Math.PI / 180;
    this.scene.add(ring);
    return ring;
}
    setupLighting() {
        this.ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(this.ambientLight);

        this.pointLights = [];
        const colors = [0x88ccff, 0xff88cc, 0xccff88];
        
        for (let i = 0; i < 3; i++) {
            const light = new THREE.PointLight(colors[i], 1, 10);
            light.position.set(
                Math.cos(i * Math.PI * 2 / 3) * 5,
                Math.sin(i * Math.PI * 2 / 3) * 5,
                2
            );
            this.pointLights.push(light);
            this.scene.add(light);
        }
    }

    createParticleSystems() {
    const particleCount = 15000;  // Increased particle count
    const particleGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        positions[i3] = (Math.random() - 0.5) * 10;
        positions[i3 + 1] = (Math.random() - 0.5) * 10;
        positions[i3 + 2] = (Math.random() - 0.5) * 10;

        colors[i3] = Math.random();
        colors[i3 + 1] = Math.random();
        colors[i3 + 2] = Math.random();
    }

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const particleMaterial = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });

    this.particleSystem = new THREE.Points(particleGeometry, particleMaterial);
    this.scene.add(this.particleSystem);
    this.particleSystem.visible = false;
}

    createRibbons() {
        this.ribbons = [];
        const ribbonCount = 12;
        
        for (let i = 0; i < ribbonCount; i++) {
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-5, 0, 0),
                new THREE.Vector3(0, 2, 2),
                new THREE.Vector3(5, 0, 0),
                new THREE.Vector3(0, -2, -2)
            ]);

            const geometry = new THREE.TubeGeometry(curve, 100, 0.1, 8, false);
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color().setHSL(i / ribbonCount, 0.8, 0.5),
                metalness: 0.8,
                roughness: 0.2
            });

            const ribbon = new THREE.Mesh(geometry, material);
            ribbon.rotation.z = (i / ribbonCount) * Math.PI * 2;
            this.ribbons.push(ribbon);
            this.scene.add(ribbon);
            ribbon.visible = false;
        }
    }

    setupPostProcessing() {
        this.composer = new THREE.EffectComposer(this.renderer);
        
        // Render pass
        const renderPass = new THREE.RenderPass(this.scene, this.camera);
        this.composer.addPass(renderPass);

        // Bloom pass
        this.bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5,  // strength
            0.4,  // radius
            0.85  // threshold
        );
        this.composer.addPass(this.bloomPass);

        // Film pass for grain effect
        this.filmPass = new THREE.FilmPass(
            0.35,  // noise intensity
            0.025, // scanline intensity
            648,   // scanline count
            false  // grayscale
        );
        this.composer.addPass(this.filmPass);
    }

    setVisualizationMode(mode) {
    this.mode = mode;
    this.vortexMesh.visible = mode === 'default' || mode === 'wireframe';
    this.particleSystem.visible = mode === 'particles';
    this.ribbons.forEach(ribbon => ribbon.visible = mode === 'ribbons');

    if (mode === 'wireframe') {
        this.vortexMesh.material = this.materials.wireframe;
        this.vortexMesh.material.color.setHex(visualModes.wireframe.mesh);
        this.vortexMesh.material.emissive.setHex(visualModes.wireframe.emissive);
    } else if (mode === 'default') {
        this.vortexMesh.material = this.materials.default;
        this.vortexMesh.material.color.setHex(visualModes.default.mesh);
        this.vortexMesh.material.emissive.setHex(visualModes.default.emissive);
    }
}

    updateGeometryDistortion() {
        const positions = this.baseGeometry.attributes.position.array;
        const frequency = this.audioEngine.oscillator.frequency.value;
        const analyser = this.audioEngine.fftAnalyzer;
        const dataArray = this.audioEngine.fftDataArray;
        analyser.getByteFrequencyData(dataArray);

        // Calculate average frequency intensity
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
        }
        const average = sum / dataArray.length;
        const intensity = average / 255;

        // Apply distortion
        for (let i = 0; i < positions.length; i += 3) {
            const offset = Math.sin(this.originalVertices[i] * frequency * 0.01 + Date.now() * 0.001);
            positions[i] = this.originalVertices[i] + offset * intensity * 0.2;
            positions[i + 1] = this.originalVertices[i + 1] + offset * intensity * 0.2;
            positions[i + 2] = this.originalVertices[i + 2] + offset * intensity * 0.2;
        }

        this.baseGeometry.attributes.position.needsUpdate = true;

        // Update color based on frequency
        const hue = (frequency % 1000) / 1000;
        this.vortexMesh.material.color.setHSL(hue, 0.8, 0.5);
        this.vortexMesh.material.emissive.setHSL(hue, 0.8, 0.3);
    }

    updateParticles() {
    if (this.mode === 'particles') {
        const positions = this.particleSystem.geometry.attributes.position.array;
        const colors = this.particleSystem.geometry.attributes.color.array;
        const time = Date.now() * 0.001;
        
        for (let i = 0; i < positions.length; i += 3) {
            // Slower movement and larger radius
            const radius = 5;
            const speed = 0.2;
            const offset = i * 0.0001;
            
            // Spiral motion pattern
            positions[i] = Math.cos(time * speed + offset) * radius * (1 + Math.sin(time * 0.1));
            positions[i + 1] = Math.sin(time * speed + offset) * radius * (1 + Math.cos(time * 0.1));
            positions[i + 2] = Math.cos(time * speed + offset + Math.PI) * radius * 0.5;

            // Color cycling with better persistence
            const hue = (Math.sin(time * 0.1 + i * 0.001) + 1) * 0.5;
            const color = new THREE.Color().setHSL(hue, 0.8, 0.5);
            colors[i] = color.r;
            colors[i + 1] = color.g;
            colors[i + 2] = color.b;
        }

        this.particleSystem.geometry.attributes.position.needsUpdate = true;
        this.particleSystem.geometry.attributes.color.needsUpdate = true;
    }
}

    updateRibbons() {
        if (this.mode === 'ribbons') {
            const time = Date.now() * 0.001;
            this.ribbons.forEach((ribbon, i) => {
                ribbon.rotation.x = Math.sin(time * 0.5 + i) * 0.3;
                ribbon.rotation.y = Math.cos(time * 0.3 + i) * 0.2;
                
                const hue = (i / this.ribbons.length + time * 0.1) % 1;
                ribbon.material.color.setHSL(hue, 0.8, 0.5);
            });
        }
    }

    animate() {
    requestAnimationFrame(() => this.animate());
    
    this.updateGeometryDistortion();
    this.updateParticles();
    this.updateRibbons();
    this.controls.update();
    this.composer.render();
}
</script>
<script>
// Frequency Filter System
class FrequencyFilter {
    constructor(audioEngine) {
        this.audioEngine = audioEngine;
        this.setupFilters();
        this.setupControls();
        this.setupPresets();
        this.setupResponseVisualizers();
    }

    setupFilters() {
        const ctx = this.audioEngine.audioCtx;

        // Low-pass filter
        this.lowPassFilter = ctx.createBiquadFilter();
        this.lowPassFilter.type = 'lowpass';
        this.lowPassFilter.frequency.value = 20000;
        this.lowPassFilter.Q.value = 0.707;

        // High-pass filter
        this.highPassFilter = ctx.createBiquadFilter();
        this.highPassFilter.type = 'highpass';
        this.highPassFilter.frequency.value = 20;
        this.highPassFilter.Q.value = 0.707;

        // Peak filter
        this.peakFilter = ctx.createBiquadFilter();
        this.peakFilter.type = 'peaking';
        this.peakFilter.frequency.value = 1000;
        this.peakFilter.gain.value = 0;
        this.peakFilter.Q.value = 1;

        // Reconnect audio chain
        this.audioEngine.compressor.disconnect();
        this.audioEngine.compressor.connect(this.highPassFilter);
        this.highPassFilter.connect(this.lowPassFilter);
        this.lowPassFilter.connect(this.peakFilter);
        this.peakFilter.connect(this.audioEngine.fftAnalyzer);
    }

    setupControls() {
        // Low-pass filter controls
        const lpfSlider = document.getElementById('lpf-frequency');
        const lpfValue = document.getElementById('lpf-value');
        
        lpfSlider.addEventListener('input', (e) => {
            const frequency = this.logScale(e.target.value);
            this.lowPassFilter.frequency.setValueAtTime(frequency, this.audioEngine.audioCtx.currentTime);
            lpfValue.textContent = `${Math.round(frequency)} Hz`;
            this.updateFilterResponses();
        });

        // High-pass filter controls
        const hpfSlider = document.getElementById('hpf-frequency');
        const hpfValue = document.getElementById('hpf-value');
        
        hpfSlider.addEventListener('input', (e) => {
            const frequency = this.logScale(e.target.value);
            this.highPassFilter.frequency.setValueAtTime(frequency, this.audioEngine.audioCtx.currentTime);
            hpfValue.textContent = `${Math.round(frequency)} Hz`;
            this.updateFilterResponses();
        });

        // Peak filter controls
        const peakFreqSlider = document.getElementById('peak-frequency');
        const peakGainSlider = document.getElementById('peak-gain');
        const peakValue = document.getElementById('peak-value');
        
        peakFreqSlider.addEventListener('input', (e) => {
            const frequency = this.logScale(e.target.value);
            this.peakFilter.frequency.setValueAtTime(frequency, this.audioEngine.audioCtx.currentTime);
            peakValue.textContent = `${Math.round(frequency)} Hz`;
            this.updateFilterResponses();
        });

        peakGainSlider.addEventListener('input', (e) => {
            this.peakFilter.gain.setValueAtTime(parseFloat(e.target.value), this.audioEngine.audioCtx.currentTime);
            this.updateFilterResponses();
        });
    }

    setupPresets() {
        const presets = {
            flat: {
                lowPass: 20000,
                highPass: 20,
                peakFreq: 1000,
                peakGain: 0
            },
            bass: {
                lowPass: 20000,
                highPass: 20,
                peakFreq: 60,
                peakGain: 6
            },
            vocal: {
                lowPass: 20000,
                highPass: 100,
                peakFreq: 3000,
                peakGain: 3
            },
            air: {
                lowPass: 20000,
                highPass: 20,
                peakFreq: 12000,
                peakGain: 6
            }
        };

        document.querySelectorAll('.preset-button').forEach(button => {
            button.addEventListener('click', () => {
                const preset = presets[button.dataset.preset];
                this.applyPreset(preset);
            });
        });
    }

    applyPreset(preset) {
        const ctx = this.audioEngine.audioCtx;
        
        // Update filter values
        this.lowPassFilter.frequency.setValueAtTime(preset.lowPass, ctx.currentTime);
        this.highPassFilter.frequency.setValueAtTime(preset.highPass, ctx.currentTime);
        this.peakFilter.frequency.setValueAtTime(preset.peakFreq, ctx.currentTime);
        this.peakFilter.gain.setValueAtTime(preset.peakGain, ctx.currentTime);

        // Update UI
        document.getElementById('lpf-frequency').value = this.inverseLogScale(preset.lowPass);
        document.getElementById('hpf-frequency').value = this.inverseLogScale(preset.highPass);
        document.getElementById('peak-frequency').value = this.inverseLogScale(preset.peakFreq);
        document.getElementById('peak-gain').value = preset.peakGain;

        document.getElementById('lpf-value').textContent = `${Math.round(preset.lowPass)} Hz`;
        document.getElementById('hpf-value').textContent = `${Math.round(preset.highPass)} Hz`;
        document.getElementById('peak-value').textContent = `${Math.round(preset.peakFreq)} Hz`;

        this.updateFilterResponses();
    }

    setupResponseVisualizers() {
        this.responseCanvases = {
            lpf: document.getElementById('lpf-response'),
            hpf: document.getElementById('hpf-response'),
            peak: document.getElementById('peak-response')
        };

        Object.values(this.responseCanvases).forEach(canvas => {
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        });

        this.updateFilterResponses();
    }

    updateFilterResponses() {
        this.drawFilterResponse(this.responseCanvases.lpf, this.lowPassFilter);
        this.drawFilterResponse(this.responseCanvases.hpf, this.highPassFilter);
        this.drawFilterResponse(this.responseCanvases.peak, this.peakFilter);
    }

    drawFilterResponse(canvas, filter) {
        const ctx = canvas.getContext('2d');
        const width = canvas.width / window.devicePixelRatio;
        const height = canvas.height / window.devicePixelRatio;

        ctx.clearRect(0, 0, width, height);
        ctx.beginPath();
        ctx.strokeStyle = '#88ccff';
        ctx.lineWidth = 2;

        for (let x = 0; x < width; x++) {
            const frequency = this.logScale(x / width * 20000);
            const response = this.getFilterResponse(filter, frequency);
            const y = height / 2 - (response * height / 4);
            
            if (x === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }

        ctx.stroke();
    }

    getFilterResponse(filter, frequency) {
        const resonance = filter.Q ? filter.Q.value : 1;
        const filterFreq = filter.frequency.value;
        
        if (filter.type === 'lowpass') {
            return 1 / (1 + Math.pow(frequency / filterFreq, 2 * resonance));
        } else if (filter.type === 'highpass') {
            return 1 / (1 + Math.pow(filterFreq / frequency, 2 * resonance));
        } else if (filter.type === 'peaking') {
            const gain = filter.gain.value;
            const bandwidth = 2 / resonance;
            return 1 + (gain / 20) * (1 / (1 + Math.pow((frequency - filterFreq) / (bandwidth * filterFreq), 2)));
        }
        return 1;
    }

    logScale(value) {
        return Math.exp(Math.log(20) + (Math.log(20000) - Math.log(20)) * value / 20000);
    }

    inverseLogScale(value) {
        return 20000 * (Math.log(value) - Math.log(20)) / (Math.log(20000) - Math.log(20));
    }
}

// Main Application Class
class VortexApp {
    constructor() {
        this.audioEngine = new AudioEngine();
        this.visualizer = new VisualizationEngine(this.audioEngine);
        this.filter = new FrequencyFilter(this.audioEngine);
        this.setupControls();
    }

    setupControls() {
    // Store rotation state and speed as class properties
    this.isRotating = true;
    this.rotationSpeed = 0.01;

    const toggleRotation = document.getElementById('toggleRotation');
    const rotationSpeedSlider = document.getElementById('rotationSpeed');
    const speedValue = document.getElementById('speedValue');

    // Toggle rotation
    toggleRotation.addEventListener('click', () => {
        this.isRotating = !this.isRotating;
        toggleRotation.classList.toggle('active');
    });

    // Update rotation speed
    rotationSpeedSlider.addEventListener('input', (e) => {
        this.rotationSpeed = (e.target.value / 2500); // Convert slider value to reasonable speed
        speedValue.textContent = `Speed: ${this.rotationSpeed.toFixed(4)}`;
    });

    // Update the visualizer's animate method to use these controls
    const originalAnimate = this.visualizer.animate.bind(this.visualizer);
    this.visualizer.animate = () => {
        if (this.isRotating) {
            this.visualizer.vortexMesh.rotation.x += this.rotationSpeed;
            this.visualizer.vortexMesh.rotation.y += this.rotationSpeed;
        }
        originalAnimate();
    };

    // Add your other existing control setup code here
    ['default', 'wireframe', 'particles', 'ribbons'].forEach(mode => {
        document.getElementById(`visualMode-${mode}`).addEventListener('click', () => {
            this.visualizer.setVisualizationMode(mode);
            document.querySelectorAll('#controls .button').forEach(btn => 
                btn.classList.remove('active'));
            document.getElementById(`visualMode-${mode}`).classList.add('active');
        });
    });
}

// Initialize the application
window.addEventListener('DOMContentLoaded', () => {
    window.vortexApp = new VortexApp();
});
</script>
</body>
</html>
