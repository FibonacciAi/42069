<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Black Hole Merger - Enhanced Edition v3</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a cleaner look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Basic body styles */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            color: #e5e7eb;
        }
        canvas { display: block; }

        /* Custom styles for lil-gui */
        .lil-gui {
            --font-size: 14px;
            --width: 320px;
            --background-color: rgba(0, 0, 0, 0.6);
            --widget-color: #a78bfa; /* violet-400 */
            --hover-color: #c4b5fd; /* violet-300 */
            --text-color: #e5e7eb; /* gray-200 */
            --font-family: 'Roboto Mono', monospace;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
        }
        .lil-gui.root > .title {
            color: #fff;
            background-color: rgba(255,255,255,0.05);
        }
        .lil-gui .name {
            font-weight: 500;
        }
        .lil-gui .controller.boolean .label {
            border-left-color: rgba(255,255,255,0.2);
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            font-family: 'Roboto Mono', monospace;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }
    </style>
    <!-- Using the latest stable version of Three.js as of July 2025 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/"
        }
    }
    </script>
</head>
<body class="bg-black">
    <!-- Loading overlay -->
    <div id="loader">Initializing Simulation...</div>

    <!-- Enhanced UI Container -->
    <div id="ui-container" class="fixed inset-0 p-4 sm:p-6 lg:p-8 pointer-events-none text-gray-200 font-mono text-sm">
        <!-- Top-left Info Panel -->
        <div id="info-panel" class="absolute top-4 left-4 sm:top-6 sm:left-6 lg:top-8 lg:left-8 bg-black/60 backdrop-blur-md p-4 rounded-lg border border-white/10 shadow-lg pointer-events-auto transition-all duration-300 opacity-100">
            <!-- Info content will be populated by JS -->
        </div>

        <!-- Bottom Controls -->
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 w-full max-w-lg px-4">
            <!-- Timeline -->
            <div id="timeline-container" class="bg-black/60 backdrop-blur-md p-3 rounded-lg border border-white/10 shadow-lg mb-4 pointer-events-auto">
                <div id="phase" class="text-center text-xs font-bold tracking-widest uppercase mb-2 text-cyan-300 transition-colors duration-500">INSPIRAL</div>
                <div id="progress" class="w-full h-2 bg-white/10 rounded-full overflow-hidden shadow-inner">
                    <div id="progressBar" class="h-full bg-gradient-to-r from-cyan-400 to-purple-500 transition-all duration-500 ease-out" style="width: 0%;"></div>
                </div>
            </div>
            <!-- Control Buttons -->
            <div id="controls" class="flex justify-center items-center gap-2 bg-black/60 backdrop-blur-md p-2 rounded-lg border border-white/10 shadow-lg pointer-events-auto">
                <!-- Buttons will be populated by JS -->
            </div>
        </div>
    </div>

    <!-- Audio for merger sound -->
    <audio id="mergerSound" src="https://gwosc.org/GW150914data/GW150914_H1_shifted.wav" preload="auto"></audio>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- Enhanced Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000011, 0.0003);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, // SMAA pass handles anti-aliasing
            powerPreference: "high-performance",
            alpha: false,
            stencil: false,
            depth: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Camera Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 800;
        controls.maxPolarAngle = Math.PI * 0.85;
        camera.position.set(0, 40, 90);

        // --- Ultra HD Galaxy Background ---
        const starfieldMaterial = new THREE.ShaderMaterial({
            uniforms: { 
                time: { value: 0.0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                nebulaDensity: { value: 2.0 },
                starDensity: { value: 3.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                varying vec3 vPosition;
                void main() { 
                    vUv = uv; 
                    vPosition = position;
                    gl_Position = vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                uniform float nebulaDensity;
                uniform float starDensity;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                // High quality noise functions
                float hash(vec3 p) { 
                    p = fract(p * vec3(443.8975, 397.2973, 491.1871));
                    p += dot(p, p.yxz + 19.19);
                    return fract((p.x + p.y) * p.z);
                }
                
                float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    return mix(mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
                                   mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                               mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                   mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                }
                
                float fbm(vec3 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    float frequency = 1.0;
                    for(int i = 0; i < 6; i++) {
                        value += amplitude * noise(p * frequency);
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }
                    return value;
                }
                
                void main() {
                    vec3 color = vec3(0.0);
                    vec2 uv = vUv;
                    vec3 pos = vPosition;
                    
                    // Ultra HD star field
                    for(int i = 0; i < 5; i++) {
                        float scale = 100.0 + float(i) * 200.0;
                        vec2 starUv = uv * scale;
                        float star = hash(vec3(floor(starUv), float(i)));
                        
                        if(star > 0.98 - float(i) * 0.01) {
                            vec2 starPos = fract(starUv) - 0.5;
                            float dist = length(starPos);
                            float brightness = 1.0 - smoothstep(0.0, 0.02, dist);
                            brightness *= (0.5 + 0.5 * sin(time * (1.0 + star * 5.0)));
                            
                            // Star color variation
                            vec3 starColor = vec3(1.0);
                            float colorType = hash(vec3(floor(starUv), float(i) + 100.0));
                            if(colorType < 0.3) starColor = vec3(1.0, 0.8, 0.6); // Yellow
                            else if(colorType < 0.6) starColor = vec3(0.8, 0.8, 1.0); // Blue-white
                            else if(colorType < 0.8) starColor = vec3(1.0, 0.6, 0.4); // Red
                            
                            color += starColor * brightness * starDensity / float(i + 1);
                        }
                    }
                    
                    // High detail nebula
                    vec3 nebulaPos = pos * 0.001;
                    float nebula1 = fbm(nebulaPos + vec3(time * 0.01, 0.0, 0.0));
                    float nebula2 = fbm(nebulaPos * 2.0 - vec3(0.0, time * 0.02, 0.0));
                    float nebula3 = fbm(nebulaPos * 4.0 + vec3(0.0, 0.0, time * 0.03));
                    
                    float nebulaMask = nebula1 * 0.5 + nebula2 * 0.3 + nebula3 * 0.2;
                    nebulaMask = pow(nebulaMask, 2.0) * nebulaDensity;
                    
                    // Nebula color gradients
                    vec3 nebulaColor1 = vec3(0.1, 0.0, 0.4) * nebula1;
                    vec3 nebulaColor2 = vec3(0.0, 0.1, 0.3) * nebula2;
                    vec3 nebulaColor3 = vec3(0.2, 0.0, 0.2) * nebula3;
                    vec3 nebulaColor = (nebulaColor1 + nebulaColor2 + nebulaColor3) * 0.5;
                    
                    color += nebulaColor * nebulaMask;
                    
                    // Milky way band
                    float band = 1.0 - abs(pos.y * 0.005);
                    band = pow(band, 4.0) * 0.2;
                    vec3 bandColor = mix(vec3(0.05, 0.03, 0.08), vec3(0.1, 0.08, 0.15), noise(pos * 0.01));
                    color += bandColor * band;
                    
                    // Distant galaxies
                    float galaxyNoise = hash(vec3(uv * 50.0, 0.0));
                    if(galaxyNoise > 0.999) {
                        float galaxyBrightness = pow(galaxyNoise, 10.0) * 0.5;
                        color += vec3(0.8, 0.7, 0.9) * galaxyBrightness;
                    }
                    
                    // Final color grading
                    color = pow(color, vec3(0.85));
                    color = mix(color, vec3(dot(color, vec3(0.299, 0.587, 0.114))), -0.2);
                    
                    gl_FragColor = vec4(color, 1.0);
                }`,
            side: THREE.BackSide
        });
        const starfieldSphere = new THREE.Mesh(new THREE.IcosahedronGeometry(2000, 4), starfieldMaterial);
        scene.add(starfieldSphere);

        // --- Advanced Ambient Lighting ---
        const ambientLight = new THREE.AmbientLight(0x0a0a0a, 0.5);
        scene.add(ambientLight);

        // --- High Quality Spacetime Grid ---
        class SpacetimeGrid {
            constructor() {
                this.gridSize = 300;
                this.gridDivisions = 60;
                this.group = new THREE.Group();
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        bhPositions: { value: [new THREE.Vector3(), new THREE.Vector3()] },
                        bhMasses: { value: [0, 0] },
                        time: { value: 0 },
                        opacity: { value: 0.3 },
                        waveAmplitude: { value: 0.0 },
                        waveOrigin: { value: new THREE.Vector3() },
                        waveTime: { value: 0.0 }
                    },
                    vertexShader: `
                        uniform vec3 bhPositions[2];
                        uniform float bhMasses[2];
                        uniform float time;
                        uniform float waveAmplitude;
                        uniform vec3 waveOrigin;
                        uniform float waveTime;
                        
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            vec3 pos = position;
                            float totalDistortion = 0.0;
                            
                            // Black hole warping
                            for(int i = 0; i < 2; i++) {
                                if(bhMasses[i] > 0.0) {
                                    vec3 delta = pos - bhPositions[i];
                                    delta.y = 0.0;
                                    float dist = length(delta);
                                    float warp = bhMasses[i] / (dist + 5.0);
                                    float falloff = exp(-dist * 0.05);
                                    pos.y -= warp * 3.0 * falloff;
                                    totalDistortion += warp;
                                }
                            }
                            
                            // Gravitational wave ripples
                            float waveDist = length(pos.xz - waveOrigin.xz);
                            float wave = sin(waveDist * 0.3 - waveTime * 15.0) * waveAmplitude;
                            wave *= exp(-waveDist * 0.01) * exp(-waveTime * 2.0);
                            pos.y += wave * 5.0;
                            vWave = wave;
                            
                            // Orbital motion distortion
                            float orbitalEffect = sin(time * 2.0 + length(pos.xz) * 0.05) * 0.2;
                            pos.y += orbitalEffect * totalDistortion;
                            
                            vDistortion = totalDistortion;
                            vColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.0, 0.5), totalDistortion * 0.2);
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            float intensity = 0.3 + vDistortion * 0.7 + abs(vWave) * 2.0;
                            vec3 color = vColor;
                            
                            // Pulsing effect
                            float pulse = sin(time * 3.0 + vDistortion * 10.0) * 0.1 + 0.9;
                            intensity *= pulse;
                            
                            // Wave color enhancement
                            if(abs(vWave) > 0.01) {
                                color = mix(color, vec3(0.5, 0.0, 1.0), abs(vWave) * 5.0);
                            }
                            
                            gl_FragColor = vec4(color, opacity * intensity);
                        }`,
                    transparent: true,
                    wireframe: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const geometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize, this.gridDivisions, this.gridDivisions);
                geometry.rotateX(-Math.PI / 2);
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.position.y = -10;
                this.group.add(this.mesh);
                
                scene.add(this.group);
                this.group.visible = false;
            }
            
            update(blackHoles, deltaTime) {
                if (blackHoles.length > 0) {
                    this.material.uniforms.bhPositions.value[0].copy(blackHoles[0].position);
                    this.material.uniforms.bhMasses.value[0] = blackHoles[0].mass;
                }
                if (blackHoles.length > 1) {
                    this.material.uniforms.bhPositions.value[1].copy(blackHoles[1].position);
                    this.material.uniforms.bhMasses.value[1] = blackHoles[1].mass;
                } else {
                    this.material.uniforms.bhMasses.value[1] = 0;
                }
                this.material.uniforms.time.value += deltaTime;
                this.material.uniforms.waveTime.value += deltaTime;
            }
            
            triggerWave(origin, amplitude) {
                this.material.uniforms.waveOrigin.value.copy(origin);
                this.material.uniforms.waveAmplitude.value = amplitude;
                this.material.uniforms.waveTime.value = 0;
            }
        }

        // --- Physics & Simulation State ---
        const G = 0.1;
        let blackHoles = [];
        let massStream = null;
        let jets = [];
        let simulationActive = true;
        let spacetimeGrid = new SpacetimeGrid();
        let particleSystems = [];
        let initialDistance = 70;
        let simulationTime = 0;
        let mergerTime = -1;
        
        const params = {
            mass1: 40, 
            mass2: 25, 
            distance: 70, 
            timeScale: 1.0, 
            isPaused: false,
            orbitalDecay: 0.005,
            diskEmissivity: 3.0, 
            bloomIntensity: 1.5, 
            finalSpin: 0.9, 
            cameraShake: true, 
            cinematicCamera: false,
            showGrid: false, 
            showInfo: true, 
            quality: 'ultra',
            particleDensity: 1.5, 
            lensingStrength: 1.0,
            playSound: true, // New parameter for sound
            focusBH1: () => setCameraFocus(0),
            focusBH2: () => setCameraFocus(1),
            focusCenter: () => setCameraFocus(-1),
            resetCamera: () => {
                setCameraFocus(-1);
                controls.reset();
                camera.position.set(0, 40, 90);
            },
            start: () => initSimulation(),
            preset1: () => applyPreset(40, 25, 70),
            preset2: () => applyPreset(30, 30, 80),
            preset3: () => applyPreset(50, 10, 100),
            preset4: () => applyPreset(140, 100, 120) // New 2025 massive merger preset
        };
        
        let cameraTarget = new THREE.Object3D();
        scene.add(cameraTarget);

        // --- Ultra HD BlackHole Class (with enhanced Doppler shift) ---
        class BlackHole {
            constructor(mass, position, velocity, isPrimary = false) {
                this.mass = mass; 
                this.position = position; 
                this.velocity = velocity;
                this.isPrimary = isPrimary;
                this.isMerged = false; 
                this.radius = Math.pow(mass, 1/3);
                this.spin = new THREE.Vector3(0, 1, 0).multiplyScalar(Math.random() * 0.5 + 0.5);
                this.spinMagnitude = 0;
                this.precessionAxis = new THREE.Vector3(0, 1, 0);
                
                this.group = new THREE.Group();
                
                // Schwarzschild radius event horizon
                const eventHorizonGeometry = new THREE.SphereGeometry(this.radius, 128, 64);
                this.eventHorizon = new THREE.Mesh(eventHorizonGeometry, new THREE.MeshBasicMaterial({ 
                    color: 0x000000
                }));
                this.eventHorizon.castShadow = true;
                this.eventHorizon.receiveShadow = true;
                this.group.add(this.eventHorizon);
                
                // Multi-layer glow effect
                for(let i = 0; i < 3; i++) {
                    const glowScale = 1.1 + i * 0.05;
                    const glowGeometry = new THREE.SphereGeometry(this.radius * glowScale, 64, 32);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: isPrimary ? 0xff6600 : 0x0066ff,
                        transparent: true,
                        opacity: 0.1 / (i + 1),
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.group.add(glow);
                }
                
                // Dynamic light sources
                this.light = new THREE.PointLight(isPrimary ? 0xffaa66 : 0x6699ff, 2, 300, 2);
                this.light.castShadow = true;
                this.light.shadow.mapSize.width = 1024;
                this.light.shadow.mapSize.height = 1024;
                this.group.add(this.light);
                
                // Rim lighting
                const rimLight = new THREE.PointLight(isPrimary ? 0xff6600 : 0x0066ff, 1, 200, 2);
                rimLight.position.set(0, this.radius * 2, 0);
                this.group.add(rimLight);

                // Ultra HD accretion disk with enhanced Doppler
                this.createAccretionDisk();
                
                scene.add(this.group);
                
                // HD Particle systems
                this.createParticleSystem();
                this.createPhotonSphere();
            }
            
            createAccretionDisk() {
                const diskInner = this.radius * 1.5; 
                const diskOuter = this.radius * 4;
                
                this.diskMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        innerRadius: { value: diskInner },
                        outerRadius: { value: diskOuter },
                        emissiveIntensity: { value: params.diskEmissivity },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xff8800) : new THREE.Color(0x0088ff) },
                        rotationSpeed: { value: 1.0 },
                        temperature: { value: 1.0 },
                        ringdown: { value: 0.0 },
                        tidalForce: { value: new THREE.Vector3() },
                        cameraPos: { value: new THREE.Vector3() }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float ringdown;
                        uniform vec3 tidalForce;
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;

                        void main() {
                            vUv = uv;
                            vPos = position;
                            vNormal = normal;
                            vec3 pos = position;
                            
                            // Tidal Disruption Effect
                            float tidalMagnitude = length(tidalForce);
                            if (tidalMagnitude > 0.01) {
                                vec3 dirToForce = normalize(tidalForce);
                                float alignment = dot(normalize(pos.xz), normalize(dirToForce.xz));
                                float stretch = smoothstep(0.5, 1.0, alignment) * tidalMagnitude * 5.0;
                                pos += dirToForce * stretch;
                            }

                            // Ringdown oscillation effect
                            if (ringdown > 0.0) {
                                float r = length(pos.xz);
                                float angle = atan(pos.z, pos.x);
                                float wobble = sin(r * 0.5 - time * 10.0) * sin(angle * 4.0); // Quadrupole oscillation
                                pos.y += wobble * ringdown * r * 0.1; // Amplitude proportional to radius
                            }
                            
                            vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float time;
                        uniform float innerRadius;
                        uniform float outerRadius;
                        uniform float emissiveIntensity;
                        uniform vec3 primaryColor;
                        uniform float rotationSpeed;
                        uniform float temperature;
                        uniform vec3 cameraPos;
                        
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vWorldPosition;
                        
                        // High quality noise
                        float noise(vec2 p) {
                            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                        }
                        
                        float turbulence(vec2 p) {
                            float value = 0.0;
                            float scale = 1.0;
                            for(int i = 0; i < 5; i++) {
                                value += noise(p * scale) / scale;
                                scale *= 2.0;
                            }
                            return value;
                        }
                        
                        vec3 blackbody(float temp) {
                            vec3 color;
                            float t = temp * 4000.0;
                            
                            if(t < 6600.0) {
                                color.r = 1.0;
                                color.g = 0.39 * log(t / 100.0) - 0.63;
                                color.b = 0.54 * log(t / 100.0 - 10.0) - 1.19;
                            } else {
                                color.r = 1.29 * pow(t / 100.0 - 60.0, -0.13);
                                color.g = 1.29 * pow(t / 100.0 - 60.0, -0.07);
                                color.b = 1.0;
                            }
                            
                            return clamp(color, 0.0, 1.0);
                        }
                        
                        void main() {
                            float dist = length(vPos);
                            float angle = atan(vPos.z, vPos.x);
                            
                            // Complex spiral arms
                            float spiral1 = sin(angle * 2.0 - time * rotationSpeed + dist * 0.3);
                            float spiral2 = sin(angle * 3.0 + time * rotationSpeed * 0.7 - dist * 0.2);
                            float spiralPattern = (spiral1 * 0.7 + spiral2 * 0.3) * 0.5 + 0.5;
                            
                            // Turbulence
                            float turb = turbulence(vec2(angle * 5.0, dist * 0.1) + time * 0.1);
                            spiralPattern = mix(spiralPattern, turb, 0.3);
                            
                            // Radial profile
                            float innerEdge = smoothstep(innerRadius - 1.0, innerRadius + 1.0, dist);
                            float outerEdge = 1.0 - smoothstep(outerRadius - 5.0, outerRadius, dist);
                            float radialFade = innerEdge * outerEdge;
                            
                            // Temperature gradient
                            float temp = temperature * (1.0 - (dist - innerRadius) / (outerRadius - innerRadius));
                            temp = pow(temp, 2.0);
                            
                            // Relativistic Doppler Beaming
                            vec3 tangent = normalize(vec3(-vPos.z, 0.0, vPos.x));
                            float speed = 0.3; // Relativistic speed factor
                            vec3 velocity = tangent * speed;
                            vec3 viewDir = normalize(cameraPos - vWorldPosition);
                            float dopplerFactor = dot(velocity, viewDir);
                            float brightnessBoost = pow(1.0 + dopplerFactor, 4.0);
                            temp *= (1.0 + dopplerFactor * 0.5); // Temperature shift
                            
                            // Color from temperature
                            vec3 color = blackbody(temp) * primaryColor;
                            
                            // Hot spots and flares
                            float hotSpot = pow(noise(vec2(angle * 10.0 + time, dist * 0.5)), 3.0);
                            color += color * hotSpot * 2.0;
                            
                            // Rim brightening
                            float innerRim = 1.0 - smoothstep(innerRadius, innerRadius + 2.0, dist);
                            color += primaryColor * pow(innerRim, 2.0) * 5.0;
                            
                            // Final composition
                            float intensity = radialFade * (0.6 + spiralPattern * 0.4) * emissiveIntensity * brightnessBoost;
                            color *= intensity;
                            
                            // Add glow
                            color += primaryColor * 0.1 * intensity;
                            
                            gl_FragColor = vec4(color, radialFade * 0.9);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const diskSegments = params.quality === 'ultra' ? 256 : 128;
                const diskGeometry = new THREE.RingGeometry(diskInner, diskOuter, diskSegments, 16);
                diskGeometry.rotateX(-Math.PI / 2);
                
                this.accretionDisk = new THREE.Mesh(diskGeometry, this.diskMaterial);
                this.group.add(this.accretionDisk);
            }
            
            createParticleSystem() {
                const particleCount = params.quality === 'ultra' ? 2000 : 1000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                const lifetimes = new Float32Array(particleCount);
                const sizes = new Float32Array(particleCount);
                const customColors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = this.radius * 1.5 + Math.random() * this.radius * 2.5;
                    const height = (Math.random() - 0.5) * 4;
                    
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = height * Math.exp(-radius / (this.radius * 3));
                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    const speed = Math.sqrt(G * this.mass / radius) * (0.8 + Math.random() * 0.4);
                    velocities[i * 3] = -Math.sin(angle) * speed;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                    velocities[i * 3 + 2] = Math.cos(angle) * speed;
                    
                    lifetimes[i] = Math.random();
                    sizes[i] = Math.random() * 2 + 0.5;
                    
                    const temp = 1.0 - (radius - this.radius) / (this.radius * 3);
                    customColors[i * 3] = temp;
                    customColors[i * 3 + 1] = temp * 0.5;
                    customColors[i * 3 + 2] = temp * 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xffaa66) : new THREE.Color(0x6699ff) },
                        opacity: { value: 1.0 }
                    },
                    vertexShader: `
                        attribute float lifetime;
                        attribute float size;
                        attribute vec3 customColor;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vLifetime = lifetime;
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z) * vLifetime;
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform vec3 primaryColor;
                        uniform float opacity;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * vLifetime * 0.8 * opacity;
                            vec3 finalColor = mix(primaryColor, vec3(1.0), vColor.r);
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.particles.userData.type = 'accretion';
                this.particles.userData.parentBH = this;
                this.group.add(this.particles);
                particleSystems.push(this.particles);
            }
            
            createPhotonSphere() {
                // Photon sphere at 1.5x Schwarzschild radius
                const photonRadius = this.radius * 1.5;
                const photonGeometry = new THREE.TorusGeometry(photonRadius, 0.1, 8, 64);
                const photonMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                this.photonSphere = new THREE.Mesh(photonGeometry, photonMaterial);
                this.photonSphere.rotation.x = Math.PI / 2;
                this.group.add(this.photonSphere);
            }
            
            update(deltaTime) {
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.group.position.copy(this.position);
                this.light.intensity = this.mass * 0.05 * params.diskEmissivity;
                
                // Update disk
                this.diskMaterial.uniforms.time.value += deltaTime;
                this.diskMaterial.uniforms.cameraPos.value.copy(camera.position);
                this.accretionDisk.rotation.y += deltaTime * 0.3;
                
                // Photon sphere rotation
                if(this.photonSphere) {
                    this.photonSphere.rotation.z += deltaTime * 2;
                }
                
                if (this.isMerged) {
                    this.diskMaterial.uniforms.emissiveIntensity.value = THREE.MathUtils.lerp(
                        this.diskMaterial.uniforms.emissiveIntensity.value, 
                        params.diskEmissivity, 
                        deltaTime * 0.5
                    );
                }
            }
            
            dispose() {
                // Remove associated particle systems from the global array
                particleSystems = particleSystems.filter(p => p.userData.parentBH !== this);

                // Dispose of all geometries and materials to free up GPU memory
                this.group.traverse(child => {
                    if (child.isMesh || child.isPoints) {
                        child.geometry.dispose();
                        // If material is an array, dispose each one
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                scene.remove(this.group);
            }
        }
        
        // --- Ultra HD MassStream Class ---
        class MassStream {
            constructor() {
                this.particleCount = 1000;
                this.geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particleCount * 3);
                const customColors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);
                
                for (let i = 0; i < this.particleCount; i++) {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                    
                    const t = i / this.particleCount;
                    customColors[i * 3] = 1.0;
                    customColors[i * 3 + 1] = 0.5 + t * 0.5;
                    customColors[i * 3 + 2] = t;
                    
                    sizes[i] = Math.random() * 2 + 0.5;
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 0.8 }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 customColor;
                        varying vec3 vColor;
                        
                        void main() {
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (200.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * opacity;
                            vec3 finalColor = vColor * (1.0 + 0.5 * sin(time * 10.0));
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
            }
            
            update(p1, p2, v1, distance, deltaTime) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.customColor.array;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const t = i / this.particleCount;
                    
                    // Bezier curve for stream path
                    const midPoint = new THREE.Vector3().lerpVectors(p1, p2, 0.5);
                    const offset = new THREE.Vector3().crossVectors(
                        new THREE.Vector3().subVectors(p2, p1).normalize(),
                        new THREE.Vector3(0, 1, 0)
                    ).multiplyScalar(distance * 0.1 * Math.sin(t * Math.PI));
                    midPoint.add(offset);
                    
                    // Quadratic bezier interpolation
                    const t2 = 1 - t;
                    const point = new THREE.Vector3()
                        .addScaledVector(p1, t2 * t2)
                        .addScaledVector(midPoint, 2 * t2 * t)
                        .addScaledVector(p2, t * t);
                    
                    // Add turbulence
                    const turbulence = new THREE.Vector3(
                        Math.sin(t * 10 + this.material.uniforms.time.value * 5) * 2,
                        Math.cos(t * 8 + this.material.uniforms.time.value * 3) * 2,
                        Math.sin(t * 12 + this.material.uniforms.time.value * 4) * 2
                    );
                    point.add(turbulence);
                    
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                    
                    // Dynamic coloring based on distance
                    const heat = 1.0 - distance / 100;
                    colors[i * 3] = heat;
                    colors[i * 3 + 1] = heat * 0.5;
                    colors[i * 3 + 2] = (1 - heat) * 0.5;
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.customColor.needsUpdate = true;
                
                const opacity = 1.0 - THREE.MathUtils.smoothstep(distance, 40, 100);
                this.material.uniforms.opacity.value = opacity * 0.8;
                this.material.uniforms.time.value += deltaTime;
            }
            
            hide() { 
                this.material.uniforms.opacity.value = 0; 
            }
            
            dispose() {
                this.geometry.dispose();
                this.material.dispose();
                scene.remove(this.mesh);
            }
        }

        // --- Physics & Merger Logic ---
        function updatePhysics(deltaTime) {
            if (mergerTime < 0 && blackHoles.length > 1) {
                // Pre-merger physics
                simulationTime += deltaTime;
                
                const bh1 = blackHoles[0], bh2 = blackHoles[1];
                const distanceVec = new THREE.Vector3().subVectors(bh2.position, bh1.position);
                const distance = distanceVec.length();
                
                updateInfoDisplay(distance);
                
                const progress = 1.0 - (distance / initialDistance);
                document.getElementById('progressBar').style.width = `${progress * 100}%`;
                
                const phaseEl = document.getElementById('phase');
                if (distance < 30) {
                    phaseEl.textContent = 'MERGER PHASE';
                    phaseEl.style.color = '#f472b6'; // pink-400
                } else if (distance < 50) {
                    phaseEl.textContent = 'FINAL INSPIRAL';
                    phaseEl.style.color = '#f59e0b'; // amber-500
                }
                
                if (distance < bh1.radius + bh2.radius) { 
                    mergeBlackHoles(); 
                    return; 
                }
                
                // Newtonian gravity
                const forceMag = G * (bh1.mass * bh2.mass) / (distance * distance);
                const forceVec = distanceVec.normalize().multiplyScalar(forceMag);
                
                bh1.velocity.add(forceVec.clone().divideScalar(bh1.mass).multiplyScalar(deltaTime));
                bh2.velocity.add(forceVec.clone().multiplyScalar(-1).divideScalar(bh2.mass).multiplyScalar(deltaTime));
                
                // GW energy loss (orbital decay)
                const totalMass = bh1.mass + bh2.mass;
                const v = Math.sqrt(G * totalMass / distance);
                const mu = (bh1.mass * bh2.mass) / totalMass;
                const gwLuminosity = (32/5) * Math.pow(G, 4) * Math.pow(mu, 2) * Math.pow(totalMass, 3) / Math.pow(distance, 5);
                const energyLoss = gwLuminosity * deltaTime * 0.000005;
                const decayRate = energyLoss / (mu * v * v) + params.orbitalDecay * deltaTime;
                
                const decayVec = distanceVec.clone().normalize().multiplyScalar(-decayRate);
                bh1.position.add(decayVec.clone().multiplyScalar(bh2.mass / totalMass));
                bh2.position.add(decayVec.clone().multiplyScalar(-bh1.mass / totalMass));
                
                // Update tidal forces for disk deformation
                const tidalForceOn1 = forceVec.clone().multiplyScalar(1 / (distance * distance * 1000));
                bh1.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1);
                bh2.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1.negate());

                massStream.update(bh1.position, bh2.position, bh1.velocity, distance, deltaTime);
            }
            
            blackHoles.forEach(bh => bh.update(deltaTime));
            spacetimeGrid.update(blackHoles, deltaTime);
        }
        
        function updateInfoDisplay(distance) {
            if (!params.showInfo) return;
            const infoPanel = document.getElementById('info-panel');
            if (!infoPanel) return;

            if (blackHoles.length > 1) {
                const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(distance, 3) / (G * totalMass));
                const kineticEnergy = 0.5 * blackHoles[0].mass * blackHoles[0].velocity.lengthSq() + 
                                      0.5 * blackHoles[1].mass * blackHoles[1].velocity.lengthSq();
                const potentialEnergy = -G * blackHoles[0].mass * blackHoles[1].mass / distance;
                const totalEnergy = kineticEnergy + potentialEnergy;
                const gwFrequency = 2 / orbitalPeriod;
                
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">${distance.toFixed(1)} Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">${orbitalPeriod.toFixed(2)} s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">${totalEnergy.toFixed(0)} E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">${gwFrequency.toFixed(3)} Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">${simulationTime.toFixed(1)} s</span>
                    </div>`;
            } else if (blackHoles.length === 1) {
                const bh = blackHoles[0];
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">Remnant Black Hole</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Status:</span> <span class="text-green-400 font-bold text-right">Ringdown</span>
                        <span class="text-gray-400">Mass:</span> <span class="text-cyan-300 font-bold text-right">${bh.mass.toFixed(1)} M</span>
                        <span class="text-gray-400">Spin:</span> <span class="text-cyan-300 font-bold text-right">${bh.spinMagnitude.toFixed(2)} a/M</span>
                        <span class="text-gray-400">Kick Vel:</span> <span class="text-cyan-300 font-bold text-right">${bh.velocity.length().toFixed(1)} km/s</span>
                    </div>`;
            }
        }
        
        function mergeBlackHoles() {
            simulationActive = false; 
            massStream.hide();
            mergerTime = simulationTime;
            
            const bh1 = blackHoles[0], bh2 = blackHoles[1];
            const newMass = (bh1.mass + bh2.mass) * 0.95; // 5% radiated as GWs
            const newPosition = new THREE.Vector3().addVectors(
                bh1.position.clone().multiplyScalar(bh1.mass), 
                bh2.position.clone().multiplyScalar(bh2.mass)
            ).divideScalar(bh1.mass + bh2.mass);
            
            // GW recoil kick
            const kickVelocity = new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5
            );
            
            triggerGravitationalWave(newPosition); 
            triggerBloomFlash(30.0);
            triggerGodRayFlash(newPosition);
            if (params.cameraShake) triggerCameraShake(1.0, newMass / 50);
            
            createMergerFlash(newPosition);
            spacetimeGrid.triggerWave(newPosition, 0.5);
            
            // Play merger sound if enabled
            if (params.playSound) {
                document.getElementById('mergerSound').play();
            }
            
            bh1.dispose();
            bh2.dispose();
            
            const mergedBH = new BlackHole(newMass, newPosition, kickVelocity, true);
            mergedBH.isMerged = true;
            mergedBH.spinMagnitude = params.finalSpin;
            mergedBH.precessionAxis = new THREE.Vector3(Math.random() - 0.5, 1, Math.random() - 0.5).normalize();
            mergedBH.diskMaterial.uniforms.emissiveIntensity.value = 10.0;
            mergedBH.diskMaterial.uniforms.temperature.value = 2.0;
            mergedBH.diskMaterial.uniforms.ringdown.value = 1.0; // Start ringdown effect
            blackHoles = [mergedBH];
            
            createJets(mergedBH);
            
            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'RINGDOWN PHASE';
            phaseEl.style.color = '#4ade80'; // green-400
            document.getElementById('progressBar').style.width = '100%';
        }
        
        function createMergerFlash(position) {
            // Particle burst
            createParticleBurst(position);
        }
        
        function createParticleBurst(position) {
            const burstCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(burstCount * 3);
            const velocities = new Float32Array(burstCount * 3);
            const customColors = new Float32Array(burstCount * 3);
            
            for(let i = 0; i < burstCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const speed = 20 + Math.random() * 30;
                
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                velocities[i * 3] = Math.sin(phi) * Math.cos(theta) * speed;
                velocities[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * speed;
                velocities[i * 3 + 2] = Math.cos(phi) * speed;
                
                const color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.6, 1.0, 0.5);
                customColors[i * 3] = color.r;
                customColors[i * 3 + 1] = color.g;
                customColors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            const burst = new THREE.Points(geometry, material);
            burst.userData.type = 'burst';
            scene.add(burst);
            particleSystems.push(burst);
        }

        // --- Ultra HD Jet Creation ---
        function createJets(parentBH) {
            const jetLength = 800;
            const jetRadius = parentBH.radius * 0.15;
            
            // Jet shader material
            const jetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 1.0 },
                    jetLength: { value: jetLength },
                    primaryColor: { value: new THREE.Color(0x4444ff) },
                    secondaryColor: { value: new THREE.Color(0xff44ff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vY = position.y;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }`,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    uniform float jetLength;
                    uniform vec3 primaryColor;
                    uniform vec3 secondaryColor;
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453);
                    }
                    
                    void main() {
                        float height = abs(vY) / jetLength;
                        
                        // Jet structure
                        float radialFade = 1.0 - smoothstep(0.0, 1.0, vUv.x);
                        float heightFade = 1.0 - smoothstep(0.3, 1.0, height);
                        
                        // Pulsing waves
                        float pulse1 = sin(vY * 0.05 - time * 5.0) * 0.5 + 0.5;
                        float pulse2 = sin(vY * 0.08 + time * 3.0) * 0.5 + 0.5;
                        float combinedPulse = pulse1 * 0.7 + pulse2 * 0.3;
                        
                        // Turbulence
                        float turb = noise(vPosition * 0.1 + time);
                        
                        // Color mixing
                        vec3 color = mix(primaryColor, secondaryColor, combinedPulse + turb * 0.2);
                        color = mix(color, vec3(1.0), heightFade * 0.3);
                        
                        // Shock fronts
                        float shock = step(0.98, sin(vY * 0.02 - time * 2.0));
                        color += vec3(0.5, 0.3, 0.8) * shock;

                        // Brighter Core
                        float coreBrightness = pow(1.0 - vUv.x, 10.0);
                        color += vec3(1.0, 1.0, 1.5) * coreBrightness * 2.0;
                        
                        float alpha = opacity * radialFade * heightFade * (0.5 + combinedPulse * 0.5);
                        
                        gl_FragColor = vec4(color, alpha);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            // Create tapered jet geometry
            const jetGeometry = new THREE.CylinderGeometry(jetRadius, jetRadius * 0.1, jetLength, 32, 32, true);
            
            // Add twist to geometry
            const positions = jetGeometry.attributes.position.array;
            for(let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                const angle = y * 0.01;
                const x = positions[i];
                const z = positions[i + 2];
                positions[i] = x * Math.cos(angle) - z * Math.sin(angle);
                positions[i + 2] = x * Math.sin(angle) + z * Math.cos(angle);
            }
            jetGeometry.attributes.position.needsUpdate = true;
            
            const jetTop = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetTop.position.y = jetLength / 2;
            
            const jetBottom = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetBottom.position.y = -jetLength / 2;
            jetBottom.rotation.x = Math.PI;
            
            parentBH.group.add(jetTop, jetBottom);
            jets = [jetTop, jetBottom];
            
            // Jet particles
            createJetParticles(parentBH, jetLength);
        }
        
        function createJetParticles(parentBH, jetLength) {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const isTop = i < particleCount / 2;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * parentBH.radius * 0.15;
                const height = Math.random() * jetLength;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = isTop ? height : -height;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                const speed = 3 + Math.random() * 2;
                velocities[i * 3] = (Math.random() - 0.5) * 0.2;
                velocities[i * 3 + 1] = isTop ? speed : -speed;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                
                lifetimes[i] = Math.random();
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    jetLength: { value: jetLength }
                },
                vertexShader: `
                    attribute float lifetime;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vLifetime = lifetime;
                        vHeight = abs(position.y) / ${jetLength.toFixed(1)};
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (1.0 + vHeight * 3.0) * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }`,
                fragmentShader: `
                    uniform float time;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        if(dist > 0.5) discard;
                        
                        float opacity = smoothstep(0.5, 0.0, dist) * vLifetime * (1.0 - vHeight * 0.5);
                        vec3 color = mix(vec3(0.4, 0.4, 1.0), vec3(1.0, 0.4, 1.0), vHeight);
                        color += vec3(0.2) * (1.0 + sin(time * 10.0 + vHeight * 20.0));
                        
                        gl_FragColor = vec4(color, opacity);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const jetParticles = new THREE.Points(geometry, material);
            jetParticles.userData.type = 'jet';
            jetParticles.userData.parentBH = parentBH;
            parentBH.group.add(jetParticles);
            particleSystems.push(jetParticles);
        }

        // --- Post-Processing Pipeline ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // Gravitational Lensing Pass
        const lensingPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null }, 
                resolution: { value: new THREE.Vector2() }, 
                aspect: { value: 1.0 },
                bhPositions: { value: Array(10).fill(0).map(() => new THREE.Vector2()) },
                bhMasses: { value: new Float32Array(10) }, 
                bhCount: { value: 0 },
                strength: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform vec2 resolution; 
                uniform float aspect;
                uniform vec2 bhPositions[10]; 
                uniform float bhMasses[10]; 
                uniform int bhCount; 
                uniform float strength;
                varying vec2 vUv;
                
                vec2 computeLensing(vec2 uv) {
                    vec2 totalOffset = vec2(0.0);
                    
                    for (int i = 0; i < 10; i++) {
                        if (i >= bhCount) break;
                        
                        vec2 pos = uv - bhPositions[i]; 
                        pos.x *= aspect;
                        float dist = length(pos);
                        
                        // Einstein ring radius approximation
                        float einsteinRadius = sqrt(bhMasses[i] * 0.0005 * strength);
                        float deflection = einsteinRadius * einsteinRadius / (dist + 0.0001);
                        
                        totalOffset += normalize(pos) * deflection;
                    }
                    
                    totalOffset.x /= aspect;
                    return totalOffset;
                }
                
                void main() {
                    vec2 offset = computeLensing(vUv);
                    
                    // Chromatic aberration for strong lensing
                    float aberration = length(offset) * 3.0;
                    
                    vec3 color;
                    color.r = texture2D(tDiffuse, vUv - offset * (1.0 + aberration * 0.1)).r;
                    color.g = texture2D(tDiffuse, vUv - offset).g;
                    color.b = texture2D(tDiffuse, vUv - offset * (1.0 - aberration * 0.1)).b;
                    
                    // Edge darkening for extreme lensing
                    float edgeDark = 1.0 - smoothstep(0.0, 0.05, length(offset));
                    color *= edgeDark;
                    
                    gl_FragColor = vec4(color, 1.0);
                }`
        });
        lensingPass.uniforms.strength.value = params.lensingStrength;
        composer.addPass(lensingPass);
        
        // Gravitational Wave Pass
        const wavePass = new ShaderPass({
             uniforms: { 
                tDiffuse: { value: null }, 
                time: { value: -1.0 }, 
                origin: { value: new THREE.Vector2() }, 
                amplitude: { value: 0.0 },
                frequency: { value: 50.0 },
                decay: { value: 2.0 }
            },
             vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
             fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform float time, amplitude, frequency, decay; 
                uniform vec2 origin; 
                varying vec2 vUv;
                
                void main() {
                    float dist = distance(vUv, origin);
                    
                    // Gravitational wave strain pattern
                    float strain = sin(dist * frequency - time * 15.0) * amplitude;
                    strain *= exp(-dist * decay) * exp(-time * 2.0);
                    strain *= smoothstep(0.0, 0.1, time) * (1.0 - smoothstep(0.7, 1.0, time));
                    
                    // Plus and cross polarizations
                    vec2 dir = normalize(vUv - origin);
                    vec2 perpDir = vec2(-dir.y, dir.x);
                    
                    vec2 plusPol = dir * strain;
                    vec2 crossPol = perpDir * strain * 0.5;
                    
                    vec2 totalOffset = plusPol + crossPol;
                    
                    vec4 color = texture2D(tDiffuse, vUv + totalOffset);
                    
                    // Wave visualization
                    float waveVis = abs(strain) * 15.0;
                    color.rgb += vec3(0.1, 0.05, 0.2) * waveVis;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(wavePass);

        // God-ray / Radial Blur pass for merger flash
        const godRayPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
                exposure: { value: 1.0 },
                decay: { value: 0.95 },
                density: { value: 0.5 },
                weight: { value: 0.4 },
                samples: { value: 60 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 lightPosition;
                uniform float exposure;
                uniform float decay;
                uniform float density;
                uniform float weight;
                uniform int samples;
                varying vec2 vUv;

                void main() {
                    vec2 delta = vUv - lightPosition;
                    delta *= 1.0 / float(samples) * density;
                    float illuminationDecay = 1.0;
                    vec4 color = texture2D(tDiffuse, vUv);

                    for (int i = 0; i < samples; i++) {
                        vUv -= delta;
                        vec4 sampleColor = texture2D(tDiffuse, vUv);
                        sampleColor *= illuminationDecay * weight;
                        color += sampleColor;
                        illuminationDecay *= decay;
                    }
                    gl_FragColor = color * exposure;
                }`
        });
        godRayPass.enabled = false;
        composer.addPass(godRayPass);
        
        // Enhanced Bloom Pass
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            params.bloomIntensity, 
            0.4, 
            0.1
        );
        bloomPass.threshold = 0.1;
        bloomPass.radius = 1.0;
        composer.addPass(bloomPass);
        
        // SMAA Anti-aliasing Pass (should be one of the last passes before final color correction)
        const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);
        composer.addPass(smaaPass);

        // Color Correction Pass
        const colorCorrectionPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                exposure: { value: 1.0 },
                contrast: { value: 1.1 },
                saturation: { value: 1.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float exposure;
                uniform float contrast;
                uniform float saturation;
                varying vec2 vUv;
                
                vec3 adjustSaturation(vec3 color, float sat) {
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    return mix(vec3(gray), color, sat);
                }
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    
                    // Exposure
                    color.rgb *= exposure;
                    
                    // Contrast
                    color.rgb = (color.rgb - 0.5) * contrast + 0.5;
                    
                    // Saturation
                    color.rgb = adjustSaturation(color.rgb, saturation);
                    
                    // Vignette
                    float vignette = smoothstep(1.0, 0.4, length(vUv - 0.5));
                    color.rgb *= vignette;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(colorCorrectionPass);

        // --- GUI Configuration ---
        const gui = new GUI();
        
        const setupFolder = gui.addFolder('System Setup');
        const mass1Controller = setupFolder.add(params, 'mass1', 10, 150).name('Mass 1 (M)');
        const mass2Controller = setupFolder.add(params, 'mass2', 10, 150).name('Mass 2 (M)');
        const distanceController = setupFolder.add(params, 'distance', 50, 200).name('Initial Distance');
        setupFolder.add(params, 'start').name(' Launch Simulation');
        
        const presetsFolder = gui.addFolder('Presets');
        presetsFolder.add(params, 'preset1').name('Asymmetric Merger');
        presetsFolder.add(params, 'preset2').name('Equal Mass');
        presetsFolder.add(params, 'preset3').name('Extreme Mass Ratio');
        presetsFolder.add(params, 'preset4').name('Massive Merger');
        
        const directorFolder = gui.addFolder('Director Controls');
        const timeScaleController = directorFolder.add(params, 'timeScale', 0.1, 5.0).name('Time Scale');
        const cinematicController = directorFolder.add(params, 'cinematicCamera').name('Cinematic Camera');
        directorFolder.add(params, 'focusBH1').name('Focus on Black Hole 1');
        directorFolder.add(params, 'focusBH2').name('Focus on Black Hole 2');
        directorFolder.add(params, 'focusCenter').name('Focus on Center');
        directorFolder.add(params, 'resetCamera').name('Reset Camera');

        const visualFolder = gui.addFolder('Visual Controls');
        visualFolder.add(params, 'diskEmissivity', 0, 10).name('Disk Brightness').onChange(v => {
            blackHoles.forEach(bh => bh.diskMaterial.uniforms.emissiveIntensity.value = v);
        });
        visualFolder.add(params, 'bloomIntensity', 0, 5).name('Bloom Intensity').onChange(v => bloomPass.strength = v);
        const gridController = visualFolder.add(params, 'showGrid').name('Show Spacetime Grid').onChange(v => {
            spacetimeGrid.group.visible = v;
        });
        const infoController = visualFolder.add(params, 'showInfo').name('Show Info Display').onChange(v => {
            document.getElementById('info-panel').style.opacity = v ? '1' : '0';
        });
        visualFolder.add(params, 'particleDensity', 0, 3).name('Particle Density').onChange(v => {
             particleSystems.forEach(ps => {
                if (ps.userData.type === 'accretion') {
                    ps.material.uniforms.opacity.value = v;
                }
             });
        });
        visualFolder.add(starfieldMaterial.uniforms.nebulaDensity, 'value', 0, 5).name('Nebula Density');
        visualFolder.add(starfieldMaterial.uniforms.starDensity, 'value', 0, 5).name('Star Density');
        
        const advancedFolder = gui.addFolder('Advanced Physics');
        advancedFolder.add(params, 'orbitalDecay', 0, 0.02).name('Orbital Decay Rate');
        advancedFolder.add(params, 'finalSpin', 0, 0.98, 0.01).name('Final BH Spin (a/M)');
        advancedFolder.add(params, 'cameraShake').name('Camera Shake');
        advancedFolder.add(params, 'lensingStrength', 0, 2).name('Lensing Strength').onChange(v => {
            lensingPass.uniforms.strength.value = v;
        });
        advancedFolder.add(params, 'playSound').name('Play Merger Sound');
        
        const postProcessFolder = gui.addFolder('Post Processing');
        postProcessFolder.add(colorCorrectionPass.uniforms.exposure, 'value', 0.5, 2).name('Exposure');
        postProcessFolder.add(colorCorrectionPass.uniforms.contrast, 'value', 0.5, 2).name('Contrast');
        postProcessFolder.add(colorCorrectionPass.uniforms.saturation, 'value', 0, 2).name('Saturation');
        
        const qualityFolder = gui.addFolder('Performance');
        qualityFolder.add(params, 'quality', ['low', 'medium', 'high', 'ultra']).name('Quality').onChange(updateQuality);

        // --- UI & Controls Setup ---
        const controlsContainer = document.getElementById('controls');
        const pauseIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`;
        const playIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
        
        const controlButtons = [
            { id: 'restart-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>`, action: () => initSimulation(), title: 'Restart (R)' },
            { id: 'pause-btn', icon: pauseIcon, action: togglePause, title: 'Pause/Play (Space)' },
            { id: 'cinematic-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg>`, action: toggleCinematic, title: 'Cinematic Camera (C)' },
            { id: 'grid-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`, action: toggleGrid, title: 'Toggle Grid (G)' },
            { id: 'info-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`, action: toggleInfo, title: 'Toggle Info (I)' },
        ];

        controlButtons.forEach(btnInfo => {
            const button = document.createElement('button');
            button.id = btnInfo.id;
            button.innerHTML = btnInfo.icon;
            button.title = btnInfo.title;
            button.className = "p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all";
            button.addEventListener('click', btnInfo.action);
            controlsContainer.appendChild(button);
        });

        function togglePause() {
            params.isPaused = !params.isPaused;
            document.getElementById('pause-btn').innerHTML = params.isPaused ? playIcon : pauseIcon;
        }
        function toggleCinematic() {
            params.cinematicCamera = !params.cinematicCamera;
            cinematicController.updateDisplay();
        }
        function toggleGrid() {
            params.showGrid = !params.showGrid;
            spacetimeGrid.group.visible = params.showGrid;
            gridController.updateDisplay();
        }
        function toggleInfo() {
            params.showInfo = !params.showInfo;
            document.getElementById('info-panel').style.opacity = params.showInfo ? '1' : '0';
            infoController.updateDisplay();
        }

        function initSimulation() {
            // Clear previous simulation objects
            blackHoles.forEach(bh => bh.dispose());
            if (massStream) massStream.dispose();
            particleSystems.forEach(ps => {
                scene.remove(ps);
                ps.geometry.dispose();
                ps.material.dispose();
            });
            particleSystems = [];
            jets = [];
            blackHoles = [];
            
            simulationTime = 0;
            mergerTime = -1;
            simulationActive = true;

            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'INSPIRAL';
            phaseEl.style.color = '#22d3ee'; // cyan-400
            document.getElementById('progressBar').style.width = '0%';
            
            const m1 = params.mass1, m2 = params.mass2, dist = params.distance;
            initialDistance = dist;
            const totalMass = m1 + m2;
            
            // Circular orbit velocities
            const v = Math.sqrt(G * totalMass / dist);
            const v1 = v * m2 / totalMass;
            const v2 = v * m1 / totalMass;
            
            // Initial positions (center of mass at origin)
            const r1 = dist * m2 / totalMass;
            const r2 = dist * m1 / totalMass;
            
            const bh1 = new BlackHole(m1, new THREE.Vector3(-r1, 0, 0), new THREE.Vector3(0, 0, -v1), true);
            const bh2 = new BlackHole(m2, new THREE.Vector3(r2, 0, 0), new THREE.Vector3(0, 0, v2), false);
            
            blackHoles.push(bh1, bh2);
            massStream = new MassStream();
            wavePass.uniforms.time.value = -1.0;
            godRayPass.enabled = false;
            setCameraFocus(-1);
        }
        
        function applyPreset(m1, m2, d) {
            params.mass1 = m1;
            params.mass2 = m2;
            params.distance = d;
            mass1Controller.updateDisplay();
            mass2Controller.updateDisplay();
            distanceController.updateDisplay();
            initSimulation();
        }
        
        function updateQuality(quality) {
            let pixelRatio = 1;
            let samples = 30;
            switch(quality) {
                case 'low':
                    pixelRatio = 1;
                    samples = 30;
                    break;
                case 'medium':
                    pixelRatio = Math.min(window.devicePixelRatio, 1.5);
                    samples = 60;
                    break;
                case 'high':
                case 'ultra':
                    pixelRatio = Math.min(window.devicePixelRatio, 2);
                    samples = 80;
                    break;
            }
            renderer.setPixelRatio(pixelRatio);
            composer.setPixelRatio(pixelRatio);
            godRayPass.uniforms.samples.value = samples;
        }
        
        // --- Camera and Effects Management ---
        let shakeDuration = 0, shakeIntensity = 0;
        function triggerCameraShake(duration = 0.5, intensity = 0.5) { 
            shakeDuration = duration; 
            shakeIntensity = intensity; 
        }
        
        function updateCameraShake(deltaTime) { 
            if (shakeDuration > 0) { 
                shakeDuration -= deltaTime;
                const shake = shakeIntensity * (shakeDuration / 0.5); // Fade out
                camera.position.x += (Math.random() - 0.5) * shake; 
                camera.position.y += (Math.random() - 0.5) * shake;
                camera.position.z += (Math.random() - 0.5) * shake * 0.5;
            } 
        }
        
        function triggerGravitationalWave(origin) { 
            const screenPos = origin.clone().project(camera); 
            wavePass.uniforms.origin.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2); 
            wavePass.uniforms.time.value = 0.0; 
            wavePass.uniforms.amplitude.value = 0.04; 
        }
        
        function triggerBloomFlash(strength) { 
            let flashStrength = strength; 
            const flashInterval = setInterval(() => { 
                bloomPass.strength = flashStrength; 
                flashStrength *= 0.9;
                if (flashStrength <= params.bloomIntensity) { 
                    bloomPass.strength = params.bloomIntensity; 
                    clearInterval(flashInterval); 
                } 
            }, 16); 
        }

        function triggerGodRayFlash(origin) {
            const screenPos = origin.clone().project(camera);
            godRayPass.enabled = true;
            godRayPass.uniforms.lightPosition.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2);
            godRayPass.uniforms.exposure.value = 1.0;
        }
        
        let focusIndex = -1;
        function setCameraFocus(index) {
            focusIndex = index;
            params.cinematicCamera = false;
            cinematicController.updateDisplay();
        }

        function updateCamera(time) {
            if (params.cinematicCamera) {
                const phase = (time * 0.05) % (Math.PI * 2);
                const radius = 120 + Math.sin(phase * 2) * 30;
                const height = 50 + Math.sin(phase * 3) * 20;
                
                camera.position.x = Math.cos(phase) * radius;
                camera.position.z = Math.sin(phase) * radius;
                camera.position.y = height;
                
                const lookAhead = 0.1;
                const lookX = Math.cos(phase + lookAhead) * radius * 0.3;
                const lookZ = Math.sin(phase + lookAhead) * radius * 0.3;
                controls.target.set(lookX, 0, lookZ);
            } else {
                let targetPos = new THREE.Vector3();
                if (focusIndex === -1 && blackHoles.length > 1) {
                    const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                    targetPos.addScaledVector(blackHoles[0].position, blackHoles[0].mass / totalMass);
                    targetPos.addScaledVector(blackHoles[1].position, blackHoles[1].mass / totalMass);
                } else if (focusIndex >= 0 && blackHoles[focusIndex]) {
                    targetPos.copy(blackHoles[focusIndex].position);
                } else if (blackHoles.length === 1) {
                    targetPos.copy(blackHoles[0].position);
                }
                cameraTarget.position.lerp(targetPos, 0.1);
                controls.target.lerp(cameraTarget.position, 0.1);
            }
        }
        
        // --- Centralized Particle System Update ---
        function updateAllParticleSystems(deltaTime) {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const system = particleSystems[i];
                const type = system.userData.type;

                if (type === 'accretion') {
                    const bh = system.userData.parentBH;
                    if (!bh) continue;

                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    const lifetimes = system.geometry.attributes.lifetime.array;
                    const colors = system.geometry.attributes.customColor.array;
                    
                    for (let j = 0; j < lifetimes.length; j++) {
                        lifetimes[j] -= deltaTime * 0.1;
                        
                        if (lifetimes[j] <= 0) {
                            // Respawn
                            const angle = Math.random() * Math.PI * 2;
                            const radius = bh.radius * 1.5 + Math.random() * bh.radius * 2.5;
                            
                            positions[j * 3] = Math.cos(angle) * radius;
                            positions[j * 3 + 1] = (Math.random() - 0.5) * 2;
                            positions[j * 3 + 2] = Math.sin(angle) * radius;
                            
                            lifetimes[j] = 1.0;
                        } else {
                            // Update position with gravity
                            const x = positions[j * 3];
                            const y = positions[j * 3 + 1];
                            const z = positions[j * 3 + 2];
                            const r = Math.sqrt(x * x + z * z);
                            
                            // Gravitational acceleration
                            const accel = -G * bh.mass / (r * r);
                            velocities[j * 3] += (x / r) * accel * deltaTime;
                            velocities[j * 3 + 2] += (z / r) * accel * deltaTime;
                            
                            positions[j * 3] += velocities[j * 3] * deltaTime;
                            positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                            positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        }
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.geometry.attributes.lifetime.needsUpdate = true;
                    system.material.uniforms.opacity.value = params.particleDensity;
                } else if (type === 'jet') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for (let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                } else if (type === 'burst') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for(let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        velocities[j * 3] *= 0.99;
                        velocities[j * 3 + 1] *= 0.99;
                        velocities[j * 3 + 2] *= 0.99;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.material.opacity -= deltaTime * 0.5;
                    if (system.material.opacity <= 0) {
                        scene.remove(system);
                        system.geometry.dispose();
                        system.material.dispose();
                        particleSystems.splice(i, 1);
                    }
                }
                if (system.material.uniforms && system.material.uniforms.time) {
                    system.material.uniforms.time.value += deltaTime;
                }
            }
        }

        // --- Main Animation Loop ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const effectiveDeltaTime = clock.getDelta();
            const timeScale = params.isPaused ? 0 : params.timeScale;
            const deltaTime = effectiveDeltaTime * timeScale;
            const elapsedTime = clock.getElapsedTime();
            
            // Update simulation
            updatePhysics(deltaTime);
            if (!params.cinematicCamera) controls.update();
            updateCamera(elapsedTime);
            updateCameraShake(deltaTime);
            updateAllParticleSystems(deltaTime);
            
            // Update background
            starfieldMaterial.uniforms.time.value = elapsedTime;
            
            // Update post-merger effects
            if (mergerTime > 0 && blackHoles.length === 1) {
                const bh = blackHoles[0];
                const precessionQuaternion = new THREE.Quaternion().setFromAxisAngle(bh.precessionAxis, deltaTime * bh.spinMagnitude * 0.1);
                bh.group.quaternion.premultiply(precessionQuaternion);
                
                jets.forEach(jet => {
                    if (jet.material.uniforms.opacity.value > 0) {
                        jet.material.uniforms.opacity.value *= 0.995;
                    }
                    if (jet.material.uniforms.time) {
                        jet.material.uniforms.time.value = elapsedTime;
                    }
                });

                if (bh.diskMaterial.uniforms.ringdown.value > 0.001) {
                    bh.diskMaterial.uniforms.ringdown.value *= (1.0 - 0.8 * effectiveDeltaTime);
                } else {
                    bh.diskMaterial.uniforms.ringdown.value = 0.0;
                }
                updateInfoDisplay();
            }

            // Update lensing positions
            const screenPositions = blackHoles.map(bh => {
                const pos = bh.group.position.clone();
                pos.project(camera);
                return pos;
            });
            
            for (let i = 0; i < 10; i++) {
                if (i < blackHoles.length) {
                    lensingPass.uniforms.bhPositions.value[i].set(
                        (screenPositions[i].x + 1) / 2, 
                        (screenPositions[i].y + 1) / 2
                    );
                    lensingPass.uniforms.bhMasses.value[i] = blackHoles[i].mass;
                } else {
                    lensingPass.uniforms.bhPositions.value[i].set(-10, -10);
                    lensingPass.uniforms.bhMasses.value[i] = 0;
                }
            }
            lensingPass.uniforms.bhCount.value = blackHoles.length;
            lensingPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspect.value = window.innerWidth / window.innerHeight;
            
            // Update gravitational wave effect
            if (wavePass.uniforms.time.value >= 0) {
                wavePass.uniforms.time.value += deltaTime;
                if (wavePass.uniforms.time.value > 1.0) {
                    wavePass.uniforms.time.value = -1.0;
                }
            }

            // Update God Ray effect
            if (godRayPass.enabled) {
                godRayPass.uniforms.exposure.value *= (1.0 - 1.5 * effectiveDeltaTime);
                if (godRayPass.uniforms.exposure.value < 0.01) {
                    godRayPass.enabled = false;
                }
            }

            // Render
            composer.render();
        }
        
        // Start simulation
        const loader = document.getElementById('loader');
        initSimulation();
        animate();
        loader.style.opacity = '0';
        setTimeout(() => loader.style.display = 'none', 500);


        // --- Window Resize Handler ---
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
            composer.setSize(width, height);
            
            lensingPass.uniforms.resolution.value.set(width, height);
            lensingPass.uniforms.aspect.value = width / height;
            
            smaaPass.setSize(width, height);
            
            updateQuality(params.quality);
        });
        
        // --- Keyboard Controls ---
        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    togglePause();
                    break;
                case 'c': toggleCinematic(); break;
                case 'g': toggleGrid(); break;
                case 'i': toggleInfo(); break;
                case 'r': initSimulation(); break;
            }
        });
    </script>
</body>
</html>
