<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Black Hole Merger - Enhanced Edition v3</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a cleaner look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <style>.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"↕";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"▾";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"▸"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"✓";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}</style><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&amp;family=Roboto+Mono:wght@400;700&amp;display=swap" rel="stylesheet">
    <style>
        /* Basic body styles */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            color: #e5e7eb;
        }
        canvas { display: block; }

        /* Custom styles for lil-gui */
        .lil-gui {
            --font-size: 14px;
            --width: 320px;
            --background-color: rgba(0, 0, 0, 0.6);
            --widget-color: #a78bfa; /* violet-400 */
            --hover-color: #c4b5fd; /* violet-300 */
            --text-color: #e5e7eb; /* gray-200 */
            --font-family: 'Roboto Mono', monospace;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
        }
        .lil-gui.root > .title {
            color: #fff;
            background-color: rgba(255,255,255,0.05);
        }
        .lil-gui .name {
            font-weight: 500;
        }
        .lil-gui .controller.boolean .label {
            border-left-color: rgba(255,255,255,0.2);
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            font-family: 'Roboto Mono', monospace;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }
    </style>
    <!-- Using the latest stable version of Three.js as of July 2025 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/"
        }
    }
    </script>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.16 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.pointer-events-none{pointer-events:none}.pointer-events-auto{pointer-events:auto}.fixed{position:fixed}.absolute{position:absolute}.inset-0{inset:0px}.bottom-4{bottom:1rem}.left-1\/2{left:50%}.left-4{left:1rem}.top-4{top:1rem}.mb-2{margin-bottom:0.5rem}.mb-4{margin-bottom:1rem}.flex{display:flex}.grid{display:grid}.h-2{height:0.5rem}.h-full{height:100%}.w-full{width:100%}.max-w-lg{max-width:32rem}.-translate-x-1\/2{--tw-translate-x:-50%;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.grid-cols-\[auto\2c 1fr\]{grid-template-columns:auto 1fr}.items-center{align-items:center}.justify-center{justify-content:center}.gap-2{gap:0.5rem}.gap-x-4{column-gap:1rem}.gap-y-1{row-gap:0.25rem}.overflow-hidden{overflow:hidden}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:0.5rem}.rounded-md{border-radius:0.375rem}.border{border-width:1px}.border-white\/10{border-color:rgb(255 255 255 / 0.1)}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0 / var(--tw-bg-opacity, 1))}.bg-black\/60{background-color:rgb(0 0 0 / 0.6)}.bg-white\/10{background-color:rgb(255 255 255 / 0.1)}.bg-gradient-to-r{background-image:linear-gradient(to right, var(--tw-gradient-stops))}.from-cyan-400{--tw-gradient-from:#22d3ee var(--tw-gradient-from-position);--tw-gradient-to:rgb(34 211 238 / 0) var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to)}.to-purple-500{--tw-gradient-to:#a855f7 var(--tw-gradient-to-position)}.p-2{padding:0.5rem}.p-3{padding:0.75rem}.p-4{padding:1rem}.px-4{padding-left:1rem;padding-right:1rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}.font-sans{font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-xs{font-size:0.75rem;line-height:1rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.font-bold{font-weight:700}.uppercase{text-transform:uppercase}.tracking-widest{letter-spacing:0.1em}.text-cyan-300{--tw-text-opacity:1;color:rgb(103 232 249 / var(--tw-text-opacity, 1))}.text-gray-200{--tw-text-opacity:1;color:rgb(229 231 235 / var(--tw-text-opacity, 1))}.text-gray-300{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity, 1))}.text-gray-400{--tw-text-opacity:1;color:rgb(156 163 175 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.opacity-100{opacity:1}.shadow-inner{--tw-shadow:inset 0 2px 4px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:inset 0 2px 4px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.backdrop-blur-md{--tw-backdrop-blur:blur(12px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.transition-colors{transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.duration-300{transition-duration:300ms}.duration-500{transition-duration:500ms}.ease-out{transition-timing-function:cubic-bezier(0, 0, 0.2, 1)}.hover\:bg-white\/10:hover{background-color:rgb(255 255 255 / 0.1)}.hover\:text-white:hover{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.focus\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\:ring-2:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.focus\:ring-purple-400:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(192 132 252 / var(--tw-ring-opacity, 1))}@media (min-width: 640px){.sm\:left-6{left:1.5rem}.sm\:top-6{top:1.5rem}.sm\:p-6{padding:1.5rem}}@media (min-width: 1024px){.lg\:left-8{left:2rem}.lg\:top-8{top:2rem}.lg\:p-8{padding:2rem}}</style></head>
<body class="bg-black">
    <!-- Loading overlay -->
    <div id="loader" style="opacity: 0; display: none;">Initializing Simulation...</div>

    <!-- Enhanced UI Container -->
    <div id="ui-container" class="fixed inset-0 p-4 sm:p-6 lg:p-8 pointer-events-none text-gray-200 font-mono text-sm">
        <!-- Top-left Info Panel -->
        <div id="info-panel" class="absolute top-4 left-4 sm:top-6 sm:left-6 lg:top-8 lg:left-8 bg-black/60 backdrop-blur-md p-4 rounded-lg border border-white/10 shadow-lg pointer-events-auto transition-all duration-300 opacity-100">
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">66.5 Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">1335.05 s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">-1 E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">0.001 Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">105.8 s</span>
                    </div></div>

        <!-- Bottom Controls -->
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 w-full max-w-lg px-4">
            <!-- Timeline -->
            <div id="timeline-container" class="bg-black/60 backdrop-blur-md p-3 rounded-lg border border-white/10 shadow-lg mb-4 pointer-events-auto">
                <div id="phase" class="text-center text-xs font-bold tracking-widest uppercase mb-2 text-cyan-300 transition-colors duration-500" style="color: rgb(34, 211, 238);">INSPIRAL</div>
                <div id="progress" class="w-full h-2 bg-white/10 rounded-full overflow-hidden shadow-inner">
                    <div id="progressBar" class="h-full bg-gradient-to-r from-cyan-400 to-purple-500 transition-all duration-500 ease-out" style="width: 5.066561%;"></div>
                </div>
            </div>
            <!-- Control Buttons -->
            <div id="controls" class="flex justify-center items-center gap-2 bg-black/60 backdrop-blur-md p-2 rounded-lg border border-white/10 shadow-lg pointer-events-auto">
                <!-- Buttons will be populated by JS -->
            <button id="restart-btn" title="Restart (R)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg></button><button id="pause-btn" title="Pause/Play (Space)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg></button><button id="cinematic-btn" title="Cinematic Camera (C)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg></button><button id="grid-btn" title="Toggle Grid (G)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg></button><button id="info-btn" title="Toggle Info (I)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></button></div>
        </div>
    </div>

    <!-- Audio for merger sound -->
    <audio id="mergerSound" src="https://gwosc.org/GW150914data/GW150914_H1_shifted.wav" preload="auto"></audio>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- Enhanced Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000011, 0.0003);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, // SMAA pass handles anti-aliasing
            powerPreference: "high-performance",
            alpha: false,
            stencil: false,
            depth: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Camera Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 800;
        controls.maxPolarAngle = Math.PI * 0.85;
        camera.position.set(0, 40, 90);

        // --- Ultra HD Galaxy Background ---
        const starfieldMaterial = new THREE.ShaderMaterial({
            uniforms: { 
                time: { value: 0.0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                nebulaDensity: { value: 2.0 },
                starDensity: { value: 3.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                varying vec3 vPosition;
                void main() { 
                    vUv = uv; 
                    vPosition = position;
                    gl_Position = vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                uniform float nebulaDensity;
                uniform float starDensity;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                // High quality noise functions
                float hash(vec3 p) { 
                    p = fract(p * vec3(443.8975, 397.2973, 491.1871));
                    p += dot(p, p.yxz + 19.19);
                    return fract((p.x + p.y) * p.z);
                }
                
                float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    return mix(mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
                                   mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                               mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                   mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                }
                
                float fbm(vec3 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    float frequency = 1.0;
                    for(int i = 0; i < 6; i++) {
                        value += amplitude * noise(p * frequency);
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }
                    return value;
                }
                
                void main() {
                    vec3 color = vec3(0.0);
                    vec2 uv = vUv;
                    vec3 pos = vPosition;
                    
                    // Ultra HD star field
                    for(int i = 0; i < 5; i++) {
                        float scale = 100.0 + float(i) * 200.0;
                        vec2 starUv = uv * scale;
                        float star = hash(vec3(floor(starUv), float(i)));
                        
                        if(star > 0.98 - float(i) * 0.01) {
                            vec2 starPos = fract(starUv) - 0.5;
                            float dist = length(starPos);
                            float brightness = 1.0 - smoothstep(0.0, 0.02, dist);
                            brightness *= (0.5 + 0.5 * sin(time * (1.0 + star * 5.0)));
                            
                            // Star color variation
                            vec3 starColor = vec3(1.0);
                            float colorType = hash(vec3(floor(starUv), float(i) + 100.0));
                            if(colorType < 0.3) starColor = vec3(1.0, 0.8, 0.6); // Yellow
                            else if(colorType < 0.6) starColor = vec3(0.8, 0.8, 1.0); // Blue-white
                            else if(colorType < 0.8) starColor = vec3(1.0, 0.6, 0.4); // Red
                            
                            color += starColor * brightness * starDensity / float(i + 1);
                        }
                    }
                    
                    // High detail nebula
                    vec3 nebulaPos = pos * 0.001;
                    float nebula1 = fbm(nebulaPos + vec3(time * 0.01, 0.0, 0.0));
                    float nebula2 = fbm(nebulaPos * 2.0 - vec3(0.0, time * 0.02, 0.0));
                    float nebula3 = fbm(nebulaPos * 4.0 + vec3(0.0, 0.0, time * 0.03));
                    
                    float nebulaMask = nebula1 * 0.5 + nebula2 * 0.3 + nebula3 * 0.2;
                    nebulaMask = pow(nebulaMask, 2.0) * nebulaDensity;
                    
                    // Nebula color gradients
                    vec3 nebulaColor1 = vec3(0.1, 0.0, 0.4) * nebula1;
                    vec3 nebulaColor2 = vec3(0.0, 0.1, 0.3) * nebula2;
                    vec3 nebulaColor3 = vec3(0.2, 0.0, 0.2) * nebula3;
                    vec3 nebulaColor = (nebulaColor1 + nebulaColor2 + nebulaColor3) * 0.5;
                    
                    color += nebulaColor * nebulaMask;
                    
                    // Milky way band
                    float band = 1.0 - abs(pos.y * 0.005);
                    band = pow(band, 4.0) * 0.2;
                    vec3 bandColor = mix(vec3(0.05, 0.03, 0.08), vec3(0.1, 0.08, 0.15), noise(pos * 0.01));
                    color += bandColor * band;
                    
                    // Distant galaxies
                    float galaxyNoise = hash(vec3(uv * 50.0, 0.0));
                    if(galaxyNoise > 0.999) {
                        float galaxyBrightness = pow(galaxyNoise, 10.0) * 0.5;
                        color += vec3(0.8, 0.7, 0.9) * galaxyBrightness;
                    }
                    
                    // Final color grading
                    color = pow(color, vec3(0.85));
                    color = mix(color, vec3(dot(color, vec3(0.299, 0.587, 0.114))), -0.2);
                    
                    gl_FragColor = vec4(color, 1.0);
                }`,
            side: THREE.BackSide
        });
        const starfieldSphere = new THREE.Mesh(new THREE.IcosahedronGeometry(2000, 4), starfieldMaterial);
        scene.add(starfieldSphere);

        // --- Advanced Ambient Lighting ---
        const ambientLight = new THREE.AmbientLight(0x0a0a0a, 0.5);
        scene.add(ambientLight);

        // --- High Quality Spacetime Grid ---
        class SpacetimeGrid {
            constructor() {
                this.gridSize = 300;
                this.gridDivisions = 60;
                this.group = new THREE.Group();
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        bhPositions: { value: [new THREE.Vector3(), new THREE.Vector3()] },
                        bhMasses: { value: [0, 0] },
                        time: { value: 0 },
                        opacity: { value: 0.3 },
                        waveAmplitude: { value: 0.0 },
                        waveOrigin: { value: new THREE.Vector3() },
                        waveTime: { value: 0.0 }
                    },
                    vertexShader: `
                        uniform vec3 bhPositions[2];
                        uniform float bhMasses[2];
                        uniform float time;
                        uniform float waveAmplitude;
                        uniform vec3 waveOrigin;
                        uniform float waveTime;
                        
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            vec3 pos = position;
                            float totalDistortion = 0.0;
                            
                            // Black hole warping
                            for(int i = 0; i < 2; i++) {
                                if(bhMasses[i] > 0.0) {
                                    vec3 delta = pos - bhPositions[i];
                                    delta.y = 0.0;
                                    float dist = length(delta);
                                    float warp = bhMasses[i] / (dist + 5.0);
                                    float falloff = exp(-dist * 0.05);
                                    pos.y -= warp * 3.0 * falloff;
                                    totalDistortion += warp;
                                }
                            }
                            
                            // Gravitational wave ripples
                            float waveDist = length(pos.xz - waveOrigin.xz);
                            float wave = sin(waveDist * 0.3 - waveTime * 15.0) * waveAmplitude;
                            wave *= exp(-waveDist * 0.01) * exp(-waveTime * 2.0);
                            pos.y += wave * 5.0;
                            vWave = wave;
                            
                            // Orbital motion distortion
                            float orbitalEffect = sin(time * 2.0 + length(pos.xz) * 0.05) * 0.2;
                            pos.y += orbitalEffect * totalDistortion;
                            
                            vDistortion = totalDistortion;
                            vColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.0, 0.5), totalDistortion * 0.2);
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            float intensity = 0.3 + vDistortion * 0.7 + abs(vWave) * 2.0;
                            vec3 color = vColor;
                            
                            // Pulsing effect
                            float pulse = sin(time * 3.0 + vDistortion * 10.0) * 0.1 + 0.9;
                            intensity *= pulse;
                            
                            // Wave color enhancement
                            if(abs(vWave) > 0.01) {
                                color = mix(color, vec3(0.5, 0.0, 1.0), abs(vWave) * 5.0);
                            }
                            
                            gl_FragColor = vec4(color, opacity * intensity);
                        }`,
                    transparent: true,
                    wireframe: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const geometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize, this.gridDivisions, this.gridDivisions);
                geometry.rotateX(-Math.PI / 2);
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.position.y = -10;
                this.group.add(this.mesh);
                
                scene.add(this.group);
                this.group.visible = false;
            }
            
            update(blackHoles, deltaTime) {
                if (blackHoles.length > 0) {
                    this.material.uniforms.bhPositions.value[0].copy(blackHoles[0].position);
                    this.material.uniforms.bhMasses.value[0] = blackHoles[0].mass;
                }
                if (blackHoles.length > 1) {
                    this.material.uniforms.bhPositions.value[1].copy(blackHoles[1].position);
                    this.material.uniforms.bhMasses.value[1] = blackHoles[1].mass;
                } else {
                    this.material.uniforms.bhMasses.value[1] = 0;
                }
                this.material.uniforms.time.value += deltaTime;
                this.material.uniforms.waveTime.value += deltaTime;
            }
            
            triggerWave(origin, amplitude) {
                this.material.uniforms.waveOrigin.value.copy(origin);
                this.material.uniforms.waveAmplitude.value = amplitude;
                this.material.uniforms.waveTime.value = 0;
            }
        }

        // --- Physics & Simulation State ---
        const G = 0.1;
        let blackHoles = [];
        let massStream = null;
        let jets = [];
        let simulationActive = true;
        let spacetimeGrid = new SpacetimeGrid();
        let particleSystems = [];
        let initialDistance = 70;
        let simulationTime = 0;
        let mergerTime = -1;
        
        const params = {
            mass1: 40, 
            mass2: 25, 
            distance: 70, 
            timeScale: 1.0, 
            isPaused: false,
            orbitalDecay: 0.005,
            diskEmissivity: 3.0, 
            bloomIntensity: 1.5, 
            finalSpin: 0.9, 
            cameraShake: true, 
            cinematicCamera: false,
            showGrid: false, 
            showInfo: true, 
            quality: 'ultra',
            particleDensity: 1.5, 
            lensingStrength: 1.0,
            playSound: true, // New parameter for sound
            focusBH1: () => setCameraFocus(0),
            focusBH2: () => setCameraFocus(1),
            focusCenter: () => setCameraFocus(-1),
            resetCamera: () => {
                setCameraFocus(-1);
                controls.reset();
                camera.position.set(0, 40, 90);
            },
            start: () => initSimulation(),
            preset1: () => applyPreset(40, 25, 70),
            preset2: () => applyPreset(30, 30, 80),
            preset3: () => applyPreset(50, 10, 100),
            preset4: () => applyPreset(140, 100, 120) // New 2025 massive merger preset
        };
        
        let cameraTarget = new THREE.Object3D();
        scene.add(cameraTarget);

        // --- Ultra HD BlackHole Class (with enhanced Doppler shift) ---
        class BlackHole {
            constructor(mass, position, velocity, isPrimary = false) {
                this.mass = mass; 
                this.position = position; 
                this.velocity = velocity;
                this.isPrimary = isPrimary;
                this.isMerged = false; 
                this.radius = Math.pow(mass, 1/3);
                this.spin = new THREE.Vector3(0, 1, 0).multiplyScalar(Math.random() * 0.5 + 0.5);
                this.spinMagnitude = 0;
                this.precessionAxis = new THREE.Vector3(0, 1, 0);
                
                this.group = new THREE.Group();
                
                // Schwarzschild radius event horizon
                const eventHorizonGeometry = new THREE.SphereGeometry(this.radius, 128, 64);
                this.eventHorizon = new THREE.Mesh(eventHorizonGeometry, new THREE.MeshBasicMaterial({ 
                    color: 0x000000
                }));
                this.eventHorizon.castShadow = true;
                this.eventHorizon.receiveShadow = true;
                this.group.add(this.eventHorizon);
                
                // Multi-layer glow effect
                for(let i = 0; i < 3; i++) {
                    const glowScale = 1.1 + i * 0.05;
                    const glowGeometry = new THREE.SphereGeometry(this.radius * glowScale, 64, 32);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: isPrimary ? 0xff6600 : 0x0066ff,
                        transparent: true,
                        opacity: 0.1 / (i + 1),
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.group.add(glow);
                }
                
                // Dynamic light sources
                this.light = new THREE.PointLight(isPrimary ? 0xffaa66 : 0x6699ff, 2, 300, 2);
                this.light.castShadow = true;
                this.light.shadow.mapSize.width = 1024;
                this.light.shadow.mapSize.height = 1024;
                this.group.add(this.light);
                
                // Rim lighting
                const rimLight = new THREE.PointLight(isPrimary ? 0xff6600 : 0x0066ff, 1, 200, 2);
                rimLight.position.set(0, this.radius * 2, 0);
                this.group.add(rimLight);

                // Ultra HD accretion disk with enhanced Doppler
                this.createAccretionDisk();
                
                scene.add(this.group);
                
                // HD Particle systems
                this.createParticleSystem();
                this.createPhotonSphere();
            }
            
            createAccretionDisk() {
                const diskInner = this.radius * 1.5; 
                const diskOuter = this.radius * 4;
                
                this.diskMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        innerRadius: { value: diskInner },
                        outerRadius: { value: diskOuter },
                        emissiveIntensity: { value: params.diskEmissivity },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xff8800) : new THREE.Color(0x0088ff) },
                        rotationSpeed: { value: 1.0 },
                        temperature: { value: 1.0 },
                        ringdown: { value: 0.0 },
                        tidalForce: { value: new THREE.Vector3() },
                        cameraPos: { value: new THREE.Vector3() }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float ringdown;
                        uniform vec3 tidalForce;
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;

                        void main() {
                            vUv = uv;
                            vPos = position;
                            vNormal = normal;
                            vec3 pos = position;
                            
                            // Tidal Disruption Effect
                            float tidalMagnitude = length(tidalForce);
                            if (tidalMagnitude > 0.01) {
                                vec3 dirToForce = normalize(tidalForce);
                                float alignment = dot(normalize(pos.xz), normalize(dirToForce.xz));
                                float stretch = smoothstep(0.5, 1.0, alignment) * tidalMagnitude * 5.0;
                                pos += dirToForce * stretch;
                            }

                            // Ringdown oscillation effect
                            if (ringdown > 0.0) {
                                float r = length(pos.xz);
                                float angle = atan(pos.z, pos.x);
                                float wobble = sin(r * 0.5 - time * 10.0) * sin(angle * 4.0); // Quadrupole oscillation
                                pos.y += wobble * ringdown * r * 0.1; // Amplitude proportional to radius
                            }
                            
                            vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float time;
                        uniform float innerRadius;
                        uniform float outerRadius;
                        uniform float emissiveIntensity;
                        uniform vec3 primaryColor;
                        uniform float rotationSpeed;
                        uniform float temperature;
                        uniform vec3 cameraPos;
                        
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vWorldPosition;
                        
                        // High quality noise
                        float noise(vec2 p) {
                            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                        }
                        
                        float turbulence(vec2 p) {
                            float value = 0.0;
                            float scale = 1.0;
                            for(int i = 0; i < 5; i++) {
                                value += noise(p * scale) / scale;
                                scale *= 2.0;
                            }
                            return value;
                        }
                        
                        vec3 blackbody(float temp) {
                            vec3 color;
                            float t = temp * 4000.0;
                            
                            if(t < 6600.0) {
                                color.r = 1.0;
                                color.g = 0.39 * log(t / 100.0) - 0.63;
                                color.b = 0.54 * log(t / 100.0 - 10.0) - 1.19;
                            } else {
                                color.r = 1.29 * pow(t / 100.0 - 60.0, -0.13);
                                color.g = 1.29 * pow(t / 100.0 - 60.0, -0.07);
                                color.b = 1.0;
                            }
                            
                            return clamp(color, 0.0, 1.0);
                        }
                        
                        void main() {
                            float dist = length(vPos);
                            float angle = atan(vPos.z, vPos.x);
                            
                            // Complex spiral arms
                            float spiral1 = sin(angle * 2.0 - time * rotationSpeed + dist * 0.3);
                            float spiral2 = sin(angle * 3.0 + time * rotationSpeed * 0.7 - dist * 0.2);
                            float spiralPattern = (spiral1 * 0.7 + spiral2 * 0.3) * 0.5 + 0.5;
                            
                            // Turbulence
                            float turb = turbulence(vec2(angle * 5.0, dist * 0.1) + time * 0.1);
                            spiralPattern = mix(spiralPattern, turb, 0.3);
                            
                            // Radial profile
                            float innerEdge = smoothstep(innerRadius - 1.0, innerRadius + 1.0, dist);
                            float outerEdge = 1.0 - smoothstep(outerRadius - 5.0, outerRadius, dist);
                            float radialFade = innerEdge * outerEdge;
                            
                            // Temperature gradient
                            float temp = temperature * (1.0 - (dist - innerRadius) / (outerRadius - innerRadius));
                            temp = pow(temp, 2.0);
                            
                            // Relativistic Doppler Beaming
                            vec3 tangent = normalize(vec3(-vPos.z, 0.0, vPos.x));
                            float speed = 0.3; // Relativistic speed factor
                            vec3 velocity = tangent * speed;
                            vec3 viewDir = normalize(cameraPos - vWorldPosition);
                            float dopplerFactor = dot(velocity, viewDir);
                            float brightnessBoost = pow(1.0 + dopplerFactor, 4.0);
                            temp *= (1.0 + dopplerFactor * 0.5); // Temperature shift
                            
                            // Color from temperature
                            vec3 color = blackbody(temp) * primaryColor;
                            
                            // Hot spots and flares
                            float hotSpot = pow(noise(vec2(angle * 10.0 + time, dist * 0.5)), 3.0);
                            color += color * hotSpot * 2.0;
                            
                            // Rim brightening
                            float innerRim = 1.0 - smoothstep(innerRadius, innerRadius + 2.0, dist);
                            color += primaryColor * pow(innerRim, 2.0) * 5.0;
                            
                            // Final composition
                            float intensity = radialFade * (0.6 + spiralPattern * 0.4) * emissiveIntensity * brightnessBoost;
                            color *= intensity;
                            
                            // Add glow
                            color += primaryColor * 0.1 * intensity;
                            
                            gl_FragColor = vec4(color, radialFade * 0.9);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const diskSegments = params.quality === 'ultra' ? 256 : 128;
                const diskGeometry = new THREE.RingGeometry(diskInner, diskOuter, diskSegments, 16);
                diskGeometry.rotateX(-Math.PI / 2);
                
                this.accretionDisk = new THREE.Mesh(diskGeometry, this.diskMaterial);
                this.group.add(this.accretionDisk);
            }
            
            createParticleSystem() {
                const particleCount = params.quality === 'ultra' ? 2000 : 1000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                const lifetimes = new Float32Array(particleCount);
                const sizes = new Float32Array(particleCount);
                const customColors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = this.radius * 1.5 + Math.random() * this.radius * 2.5;
                    const height = (Math.random() - 0.5) * 4;
                    
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = height * Math.exp(-radius / (this.radius * 3));
                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    const speed = Math.sqrt(G * this.mass / radius) * (0.8 + Math.random() * 0.4);
                    velocities[i * 3] = -Math.sin(angle) * speed;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                    velocities[i * 3 + 2] = Math.cos(angle) * speed;
                    
                    lifetimes[i] = Math.random();
                    sizes[i] = Math.random() * 2 + 0.5;
                    
                    const temp = 1.0 - (radius - this.radius) / (this.radius * 3);
                    customColors[i * 3] = temp;
                    customColors[i * 3 + 1] = temp * 0.5;
                    customColors[i * 3 + 2] = temp * 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xffaa66) : new THREE.Color(0x6699ff) },
                        opacity: { value: 1.0 }
                    },
                    vertexShader: `
                        attribute float lifetime;
                        attribute float size;
                        attribute vec3 customColor;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vLifetime = lifetime;
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z) * vLifetime;
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform vec3 primaryColor;
                        uniform float opacity;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * vLifetime * 0.8 * opacity;
                            vec3 finalColor = mix(primaryColor, vec3(1.0), vColor.r);
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.particles.userData.type = 'accretion';
                this.particles.userData.parentBH = this;
                this.group.add(this.particles);
                particleSystems.push(this.particles);
            }
            
            createPhotonSphere() {
                // Photon sphere at 1.5x Schwarzschild radius
                const photonRadius = this.radius * 1.5;
                const photonGeometry = new THREE.TorusGeometry(photonRadius, 0.1, 8, 64);
                const photonMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                this.photonSphere = new THREE.Mesh(photonGeometry, photonMaterial);
                this.photonSphere.rotation.x = Math.PI / 2;
                this.group.add(this.photonSphere);
            }
            
            update(deltaTime) {
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.group.position.copy(this.position);
                this.light.intensity = this.mass * 0.05 * params.diskEmissivity;
                
                // Update disk
                this.diskMaterial.uniforms.time.value += deltaTime;
                this.diskMaterial.uniforms.cameraPos.value.copy(camera.position);
                this.accretionDisk.rotation.y += deltaTime * 0.3;
                
                // Photon sphere rotation
                if(this.photonSphere) {
                    this.photonSphere.rotation.z += deltaTime * 2;
                }
                
                if (this.isMerged) {
                    this.diskMaterial.uniforms.emissiveIntensity.value = THREE.MathUtils.lerp(
                        this.diskMaterial.uniforms.emissiveIntensity.value, 
                        params.diskEmissivity, 
                        deltaTime * 0.5
                    );
                }
            }
            
            dispose() {
                // Remove associated particle systems from the global array
                particleSystems = particleSystems.filter(p => p.userData.parentBH !== this);

                // Dispose of all geometries and materials to free up GPU memory
                this.group.traverse(child => {
                    if (child.isMesh || child.isPoints) {
                        child.geometry.dispose();
                        // If material is an array, dispose each one
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                scene.remove(this.group);
            }
        }
        
        // --- Ultra HD MassStream Class ---
        class MassStream {
            constructor() {
                this.particleCount = 1000;
                this.geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particleCount * 3);
                const customColors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);
                
                for (let i = 0; i < this.particleCount; i++) {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                    
                    const t = i / this.particleCount;
                    customColors[i * 3] = 1.0;
                    customColors[i * 3 + 1] = 0.5 + t * 0.5;
                    customColors[i * 3 + 2] = t;
                    
                    sizes[i] = Math.random() * 2 + 0.5;
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 0.8 }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 customColor;
                        varying vec3 vColor;
                        
                        void main() {
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (200.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * opacity;
                            vec3 finalColor = vColor * (1.0 + 0.5 * sin(time * 10.0));
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
            }
            
            update(p1, p2, v1, distance, deltaTime) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.customColor.array;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const t = i / this.particleCount;
                    
                    // Bezier curve for stream path
                    const midPoint = new THREE.Vector3().lerpVectors(p1, p2, 0.5);
                    const offset = new THREE.Vector3().crossVectors(
                        new THREE.Vector3().subVectors(p2, p1).normalize(),
                        new THREE.Vector3(0, 1, 0)
                    ).multiplyScalar(distance * 0.1 * Math.sin(t * Math.PI));
                    midPoint.add(offset);
                    
                    // Quadratic bezier interpolation
                    const t2 = 1 - t;
                    const point = new THREE.Vector3()
                        .addScaledVector(p1, t2 * t2)
                        .addScaledVector(midPoint, 2 * t2 * t)
                        .addScaledVector(p2, t * t);
                    
                    // Add turbulence
                    const turbulence = new THREE.Vector3(
                        Math.sin(t * 10 + this.material.uniforms.time.value * 5) * 2,
                        Math.cos(t * 8 + this.material.uniforms.time.value * 3) * 2,
                        Math.sin(t * 12 + this.material.uniforms.time.value * 4) * 2
                    );
                    point.add(turbulence);
                    
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                    
                    // Dynamic coloring based on distance
                    const heat = 1.0 - distance / 100;
                    colors[i * 3] = heat;
                    colors[i * 3 + 1] = heat * 0.5;
                    colors[i * 3 + 2] = (1 - heat) * 0.5;
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.customColor.needsUpdate = true;
                
                const opacity = 1.0 - THREE.MathUtils.smoothstep(distance, 40, 100);
                this.material.uniforms.opacity.value = opacity * 0.8;
                this.material.uniforms.time.value += deltaTime;
            }
            
            hide() { 
                this.material.uniforms.opacity.value = 0; 
            }
            
            dispose() {
                this.geometry.dispose();
                this.material.dispose();
                scene.remove(this.mesh);
            }
        }

        // --- Physics & Merger Logic ---
        function updatePhysics(deltaTime) {
            if (mergerTime < 0 && blackHoles.length > 1) {
                // Pre-merger physics
                simulationTime += deltaTime;
                
                const bh1 = blackHoles[0], bh2 = blackHoles[1];
                const distanceVec = new THREE.Vector3().subVectors(bh2.position, bh1.position);
                const distance = distanceVec.length();
                
                updateInfoDisplay(distance);
                
                const progress = 1.0 - (distance / initialDistance);
                document.getElementById('progressBar').style.width = `${progress * 100}%`;
                
                const phaseEl = document.getElementById('phase');
                if (distance < 30) {
                    phaseEl.textContent = 'MERGER PHASE';
                    phaseEl.style.color = '#f472b6'; // pink-400
                } else if (distance < 50) {
                    phaseEl.textContent = 'FINAL INSPIRAL';
                    phaseEl.style.color = '#f59e0b'; // amber-500
                }
                
                if (distance < bh1.radius + bh2.radius) { 
                    mergeBlackHoles(); 
                    return; 
                }
                
                // Newtonian gravity
                const forceMag = G * (bh1.mass * bh2.mass) / (distance * distance);
                const forceVec = distanceVec.normalize().multiplyScalar(forceMag);
                
                bh1.velocity.add(forceVec.clone().divideScalar(bh1.mass).multiplyScalar(deltaTime));
                bh2.velocity.add(forceVec.clone().multiplyScalar(-1).divideScalar(bh2.mass).multiplyScalar(deltaTime));
                
                // GW energy loss (orbital decay)
                const totalMass = bh1.mass + bh2.mass;
                const v = Math.sqrt(G * totalMass / distance);
                const mu = (bh1.mass * bh2.mass) / totalMass;
                const gwLuminosity = (32/5) * Math.pow(G, 4) * Math.pow(mu, 2) * Math.pow(totalMass, 3) / Math.pow(distance, 5);
                const energyLoss = gwLuminosity * deltaTime * 0.000005;
                const decayRate = energyLoss / (mu * v * v) + params.orbitalDecay * deltaTime;
                
                const decayVec = distanceVec.clone().normalize().multiplyScalar(-decayRate);
                bh1.position.add(decayVec.clone().multiplyScalar(bh2.mass / totalMass));
                bh2.position.add(decayVec.clone().multiplyScalar(-bh1.mass / totalMass));
                
                // Update tidal forces for disk deformation
                const tidalForceOn1 = forceVec.clone().multiplyScalar(1 / (distance * distance * 1000));
                bh1.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1);
                bh2.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1.negate());

                massStream.update(bh1.position, bh2.position, bh1.velocity, distance, deltaTime);
            }
            
            blackHoles.forEach(bh => bh.update(deltaTime));
            spacetimeGrid.update(blackHoles, deltaTime);
        }
        
        function updateInfoDisplay(distance) {
            if (!params.showInfo) return;
            const infoPanel = document.getElementById('info-panel');
            if (!infoPanel) return;

            if (blackHoles.length > 1) {
                const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(distance, 3) / (G * totalMass));
                const kineticEnergy = 0.5 * blackHoles[0].mass * blackHoles[0].velocity.lengthSq() + 
                                      0.5 * blackHoles[1].mass * blackHoles[1].velocity.lengthSq();
                const potentialEnergy = -G * blackHoles[0].mass * blackHoles[1].mass / distance;
                const totalEnergy = kineticEnergy + potentialEnergy;
                const gwFrequency = 2 / orbitalPeriod;
                
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">${distance.toFixed(1)} Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">${orbitalPeriod.toFixed(2)} s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">${totalEnergy.toFixed(0)} E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">${gwFrequency.toFixed(3)} Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">${simulationTime.toFixed(1)} s</span>
                    </div>`;
            } else if (blackHoles.length === 1) {
                const bh = blackHoles[0];
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">Remnant Black Hole</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Status:</span> <span class="text-green-400 font-bold text-right">Ringdown</span>
                        <span class="text-gray-400">Mass:</span> <span class="text-cyan-300 font-bold text-right">${bh.mass.toFixed(1)} M☉</span>
                        <span class="text-gray-400">Spin:</span> <span class="text-cyan-300 font-bold text-right">${bh.spinMagnitude.toFixed(2)} a/M</span>
                        <span class="text-gray-400">Kick Vel:</span> <span class="text-cyan-300 font-bold text-right">${bh.velocity.length().toFixed(1)} km/s</span>
                    </div>`;
            }
        }
        
        function mergeBlackHoles() {
            simulationActive = false; 
            massStream.hide();
            mergerTime = simulationTime;
            
            const bh1 = blackHoles[0], bh2 = blackHoles[1];
            const newMass = (bh1.mass + bh2.mass) * 0.95; // 5% radiated as GWs
            const newPosition = new THREE.Vector3().addVectors(
                bh1.position.clone().multiplyScalar(bh1.mass), 
                bh2.position.clone().multiplyScalar(bh2.mass)
            ).divideScalar(bh1.mass + bh2.mass);
            
            // GW recoil kick
            const kickVelocity = new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5
            );
            
            triggerGravitationalWave(newPosition); 
            triggerBloomFlash(30.0);
            triggerGodRayFlash(newPosition);
            if (params.cameraShake) triggerCameraShake(1.0, newMass / 50);
            
            createMergerFlash(newPosition);
            spacetimeGrid.triggerWave(newPosition, 0.5);
            
            // Play merger sound if enabled
            if (params.playSound) {
                document.getElementById('mergerSound').play();
            }
            
            bh1.dispose();
            bh2.dispose();
            
            const mergedBH = new BlackHole(newMass, newPosition, kickVelocity, true);
            mergedBH.isMerged = true;
            mergedBH.spinMagnitude = params.finalSpin;
            mergedBH.precessionAxis = new THREE.Vector3(Math.random() - 0.5, 1, Math.random() - 0.5).normalize();
            mergedBH.diskMaterial.uniforms.emissiveIntensity.value = 10.0;
            mergedBH.diskMaterial.uniforms.temperature.value = 2.0;
            mergedBH.diskMaterial.uniforms.ringdown.value = 1.0; // Start ringdown effect
            blackHoles = [mergedBH];
            
            createJets(mergedBH);
            
            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'RINGDOWN PHASE';
            phaseEl.style.color = '#4ade80'; // green-400
            document.getElementById('progressBar').style.width = '100%';
        }
        
        function createMergerFlash(position) {
            // Particle burst
            createParticleBurst(position);
        }
        
        function createParticleBurst(position) {
            const burstCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(burstCount * 3);
            const velocities = new Float32Array(burstCount * 3);
            const customColors = new Float32Array(burstCount * 3);
            
            for(let i = 0; i < burstCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const speed = 20 + Math.random() * 30;
                
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                velocities[i * 3] = Math.sin(phi) * Math.cos(theta) * speed;
                velocities[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * speed;
                velocities[i * 3 + 2] = Math.cos(phi) * speed;
                
                const color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.6, 1.0, 0.5);
                customColors[i * 3] = color.r;
                customColors[i * 3 + 1] = color.g;
                customColors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            const burst = new THREE.Points(geometry, material);
            burst.userData.type = 'burst';
            scene.add(burst);
            particleSystems.push(burst);
        }

        // --- Ultra HD Jet Creation ---
        function createJets(parentBH) {
            const jetLength = 800;
            const jetRadius = parentBH.radius * 0.15;
            
            // Jet shader material
            const jetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 1.0 },
                    jetLength: { value: jetLength },
                    primaryColor: { value: new THREE.Color(0x4444ff) },
                    secondaryColor: { value: new THREE.Color(0xff44ff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vY = position.y;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }`,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    uniform float jetLength;
                    uniform vec3 primaryColor;
                    uniform vec3 secondaryColor;
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453);
                    }
                    
                    void main() {
                        float height = abs(vY) / jetLength;
                        
                        // Jet structure
                        float radialFade = 1.0 - smoothstep(0.0, 1.0, vUv.x);
                        float heightFade = 1.0 - smoothstep(0.3, 1.0, height);
                        
                        // Pulsing waves
                        float pulse1 = sin(vY * 0.05 - time * 5.0) * 0.5 + 0.5;
                        float pulse2 = sin(vY * 0.08 + time * 3.0) * 0.5 + 0.5;
                        float combinedPulse = pulse1 * 0.7 + pulse2 * 0.3;
                        
                        // Turbulence
                        float turb = noise(vPosition * 0.1 + time);
                        
                        // Color mixing
                        vec3 color = mix(primaryColor, secondaryColor, combinedPulse + turb * 0.2);
                        color = mix(color, vec3(1.0), heightFade * 0.3);
                        
                        // Shock fronts
                        float shock = step(0.98, sin(vY * 0.02 - time * 2.0));
                        color += vec3(0.5, 0.3, 0.8) * shock;

                        // Brighter Core
                        float coreBrightness = pow(1.0 - vUv.x, 10.0);
                        color += vec3(1.0, 1.0, 1.5) * coreBrightness * 2.0;
                        
                        float alpha = opacity * radialFade * heightFade * (0.5 + combinedPulse * 0.5);
                        
                        gl_FragColor = vec4(color, alpha);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            // Create tapered jet geometry
            const jetGeometry = new THREE.CylinderGeometry(jetRadius, jetRadius * 0.1, jetLength, 32, 32, true);
            
            // Add twist to geometry
            const positions = jetGeometry.attributes.position.array;
            for(let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                const angle = y * 0.01;
                const x = positions[i];
                const z = positions[i + 2];
                positions[i] = x * Math.cos(angle) - z * Math.sin(angle);
                positions[i + 2] = x * Math.sin(angle) + z * Math.cos(angle);
            }
            jetGeometry.attributes.position.needsUpdate = true;
            
            const jetTop = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetTop.position.y = jetLength / 2;
            
            const jetBottom = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetBottom.position.y = -jetLength / 2;
            jetBottom.rotation.x = Math.PI;
            
            parentBH.group.add(jetTop, jetBottom);
            jets = [jetTop, jetBottom];
            
            // Jet particles
            createJetParticles(parentBH, jetLength);
        }
        
        function createJetParticles(parentBH, jetLength) {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const isTop = i < particleCount / 2;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * parentBH.radius * 0.15;
                const height = Math.random() * jetLength;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = isTop ? height : -height;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                const speed = 3 + Math.random() * 2;
                velocities[i * 3] = (Math.random() - 0.5) * 0.2;
                velocities[i * 3 + 1] = isTop ? speed : -speed;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                
                lifetimes[i] = Math.random();
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    jetLength: { value: jetLength }
                },
                vertexShader: `
                    attribute float lifetime;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vLifetime = lifetime;
                        vHeight = abs(position.y) / ${jetLength.toFixed(1)};
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (1.0 + vHeight * 3.0) * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }`,
                fragmentShader: `
                    uniform float time;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        if(dist > 0.5) discard;
                        
                        float opacity = smoothstep(0.5, 0.0, dist) * vLifetime * (1.0 - vHeight * 0.5);
                        vec3 color = mix(vec3(0.4, 0.4, 1.0), vec3(1.0, 0.4, 1.0), vHeight);
                        color += vec3(0.2) * (1.0 + sin(time * 10.0 + vHeight * 20.0));
                        
                        gl_FragColor = vec4(color, opacity);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const jetParticles = new THREE.Points(geometry, material);
            jetParticles.userData.type = 'jet';
            jetParticles.userData.parentBH = parentBH;
            parentBH.group.add(jetParticles);
            particleSystems.push(jetParticles);
        }

        // --- Post-Processing Pipeline ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // Gravitational Lensing Pass
        const lensingPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null }, 
                resolution: { value: new THREE.Vector2() }, 
                aspect: { value: 1.0 },
                bhPositions: { value: Array(10).fill(0).map(() => new THREE.Vector2()) },
                bhMasses: { value: new Float32Array(10) }, 
                bhCount: { value: 0 },
                strength: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform vec2 resolution; 
                uniform float aspect;
                uniform vec2 bhPositions[10]; 
                uniform float bhMasses[10]; 
                uniform int bhCount; 
                uniform float strength;
                varying vec2 vUv;
                
                vec2 computeLensing(vec2 uv) {
                    vec2 totalOffset = vec2(0.0);
                    
                    for (int i = 0; i < 10; i++) {
                        if (i >= bhCount) break;
                        
                        vec2 pos = uv - bhPositions[i]; 
                        pos.x *= aspect;
                        float dist = length(pos);
                        
                        // Einstein ring radius approximation
                        float einsteinRadius = sqrt(bhMasses[i] * 0.0005 * strength);
                        float deflection = einsteinRadius * einsteinRadius / (dist + 0.0001);
                        
                        totalOffset += normalize(pos) * deflection;
                    }
                    
                    totalOffset.x /= aspect;
                    return totalOffset;
                }
                
                void main() {
                    vec2 offset = computeLensing(vUv);
                    
                    // Chromatic aberration for strong lensing
                    float aberration = length(offset) * 3.0;
                    
                    vec3 color;
                    color.r = texture2D(tDiffuse, vUv - offset * (1.0 + aberration * 0.1)).r;
                    color.g = texture2D(tDiffuse, vUv - offset).g;
                    color.b = texture2D(tDiffuse, vUv - offset * (1.0 - aberration * 0.1)).b;
                    
                    // Edge darkening for extreme lensing
                    float edgeDark = 1.0 - smoothstep(0.0, 0.05, length(offset));
                    color *= edgeDark;
                    
                    gl_FragColor = vec4(color, 1.0);
                }`
        });
        lensingPass.uniforms.strength.value = params.lensingStrength;
        composer.addPass(lensingPass);
        
        // Gravitational Wave Pass
        const wavePass = new ShaderPass({
             uniforms: { 
                tDiffuse: { value: null }, 
                time: { value: -1.0 }, 
                origin: { value: new THREE.Vector2() }, 
                amplitude: { value: 0.0 },
                frequency: { value: 50.0 },
                decay: { value: 2.0 }
            },
             vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
             fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform float time, amplitude, frequency, decay; 
                uniform vec2 origin; 
                varying vec2 vUv;
                
                void main() {
                    float dist = distance(vUv, origin);
                    
                    // Gravitational wave strain pattern
                    float strain = sin(dist * frequency - time * 15.0) * amplitude;
                    strain *= exp(-dist * decay) * exp(-time * 2.0);
                    strain *= smoothstep(0.0, 0.1, time) * (1.0 - smoothstep(0.7, 1.0, time));
                    
                    // Plus and cross polarizations
                    vec2 dir = normalize(vUv - origin);
                    vec2 perpDir = vec2(-dir.y, dir.x);
                    
                    vec2 plusPol = dir * strain;
                    vec2 crossPol = perpDir * strain * 0.5;
                    
                    vec2 totalOffset = plusPol + crossPol;
                    
                    vec4 color = texture2D(tDiffuse, vUv + totalOffset);
                    
                    // Wave visualization
                    float waveVis = abs(strain) * 15.0;
                    color.rgb += vec3(0.1, 0.05, 0.2) * waveVis;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(wavePass);

        // God-ray / Radial Blur pass for merger flash
        const godRayPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
                exposure: { value: 1.0 },
                decay: { value: 0.95 },
                density: { value: 0.5 },
                weight: { value: 0.4 },
                samples: { value: 60 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 lightPosition;
                uniform float exposure;
                uniform float decay;
                uniform float density;
                uniform float weight;
                uniform int samples;
                varying vec2 vUv;

                void main() {
                    vec2 delta = vUv - lightPosition;
                    delta *= 1.0 / float(samples) * density;
                    float illuminationDecay = 1.0;
                    vec4 color = texture2D(tDiffuse, vUv);

                    for (int i = 0; i < samples; i++) {
                        vUv -= delta;
                        vec4 sampleColor = texture2D(tDiffuse, vUv);
                        sampleColor *= illuminationDecay * weight;
                        color += sampleColor;
                        illuminationDecay *= decay;
                    }
                    gl_FragColor = color * exposure;
                }`
        });
        godRayPass.enabled = false;
        composer.addPass(godRayPass);
        
        // Enhanced Bloom Pass
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            params.bloomIntensity, 
            0.4, 
            0.1
        );
        bloomPass.threshold = 0.1;
        bloomPass.radius = 1.0;
        composer.addPass(bloomPass);
        
        // SMAA Anti-aliasing Pass (should be one of the last passes before final color correction)
        const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);
        composer.addPass(smaaPass);

        // Color Correction Pass
        const colorCorrectionPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                exposure: { value: 1.0 },
                contrast: { value: 1.1 },
                saturation: { value: 1.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float exposure;
                uniform float contrast;
                uniform float saturation;
                varying vec2 vUv;
                
                vec3 adjustSaturation(vec3 color, float sat) {
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    return mix(vec3(gray), color, sat);
                }
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    
                    // Exposure
                    color.rgb *= exposure;
                    
                    // Contrast
                    color.rgb = (color.rgb - 0.5) * contrast + 0.5;
                    
                    // Saturation
                    color.rgb = adjustSaturation(color.rgb, saturation);
                    
                    // Vignette
                    float vignette = smoothstep(1.0, 0.4, length(vUv - 0.5));
                    color.rgb *= vignette;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(colorCorrectionPass);

        // --- GUI Configuration ---
        const gui = new GUI();
        
        const setupFolder = gui.addFolder('System Setup');
        const mass1Controller = setupFolder.add(params, 'mass1', 10, 150).name('Mass 1 (M☉)');
        const mass2Controller = setupFolder.add(params, 'mass2', 10, 150).name('Mass 2 (M☉)');
        const distanceController = setupFolder.add(params, 'distance', 50, 200).name('Initial Distance');
        setupFolder.add(params, 'start').name('🚀 Launch Simulation');
        
        const presetsFolder = gui.addFolder('Presets');
        presetsFolder.add(params, 'preset1').name('Asymmetric Merger');
        presetsFolder.add(params, 'preset2').name('Equal Mass');
        presetsFolder.add(params, 'preset3').name('Extreme Mass Ratio');
        presetsFolder.add(params, 'preset4').name('Massive Merger');
        
        const directorFolder = gui.addFolder('Director Controls');
        const timeScaleController = directorFolder.add(params, 'timeScale', 0.1, 5.0).name('Time Scale');
        const cinematicController = directorFolder.add(params, 'cinematicCamera').name('Cinematic Camera');
        directorFolder.add(params, 'focusBH1').name('Focus on Black Hole 1');
        directorFolder.add(params, 'focusBH2').name('Focus on Black Hole 2');
        directorFolder.add(params, 'focusCenter').name('Focus on Center');
        directorFolder.add(params, 'resetCamera').name('Reset Camera');

        const visualFolder = gui.addFolder('Visual Controls');
        visualFolder.add(params, 'diskEmissivity', 0, 10).name('Disk Brightness').onChange(v => {
            blackHoles.forEach(bh => bh.diskMaterial.uniforms.emissiveIntensity.value = v);
        });
        visualFolder.add(params, 'bloomIntensity', 0, 5).name('Bloom Intensity').onChange(v => bloomPass.strength = v);
        const gridController = visualFolder.add(params, 'showGrid').name('Show Spacetime Grid').onChange(v => {
            spacetimeGrid.group.visible = v;
        });
        const infoController = visualFolder.add(params, 'showInfo').name('Show Info Display').onChange(v => {
            document.getElementById('info-panel').style.opacity = v ? '1' : '0';
        });
        visualFolder.add(params, 'particleDensity', 0, 3).name('Particle Density').onChange(v => {
             particleSystems.forEach(ps => {
                if (ps.userData.type === 'accretion') {
                    ps.material.uniforms.opacity.value = v;
                }
             });
        });
        visualFolder.add(starfieldMaterial.uniforms.nebulaDensity, 'value', 0, 5).name('Nebula Density');
        visualFolder.add(starfieldMaterial.uniforms.starDensity, 'value', 0, 5).name('Star Density');
        
        const advancedFolder = gui.addFolder('Advanced Physics');
        advancedFolder.add(params, 'orbitalDecay', 0, 0.02).name('Orbital Decay Rate');
        advancedFolder.add(params, 'finalSpin', 0, 0.98, 0.01).name('Final BH Spin (a/M)');
        advancedFolder.add(params, 'cameraShake').name('Camera Shake');
        advancedFolder.add(params, 'lensingStrength', 0, 2).name('Lensing Strength').onChange(v => {
            lensingPass.uniforms.strength.value = v;
        });
        advancedFolder.add(params, 'playSound').name('Play Merger Sound');
        
        const postProcessFolder = gui.addFolder('Post Processing');
        postProcessFolder.add(colorCorrectionPass.uniforms.exposure, 'value', 0.5, 2).name('Exposure');
        postProcessFolder.add(colorCorrectionPass.uniforms.contrast, 'value', 0.5, 2).name('Contrast');
        postProcessFolder.add(colorCorrectionPass.uniforms.saturation, 'value', 0, 2).name('Saturation');
        
        const qualityFolder = gui.addFolder('Performance');
        qualityFolder.add(params, 'quality', ['low', 'medium', 'high', 'ultra']).name('Quality').onChange(updateQuality);

        // --- UI & Controls Setup ---
        const controlsContainer = document.getElementById('controls');
        const pauseIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`;
        const playIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
        
        const controlButtons = [
            { id: 'restart-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>`, action: () => initSimulation(), title: 'Restart (R)' },
            { id: 'pause-btn', icon: pauseIcon, action: togglePause, title: 'Pause/Play (Space)' },
            { id: 'cinematic-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg>`, action: toggleCinematic, title: 'Cinematic Camera (C)' },
            { id: 'grid-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`, action: toggleGrid, title: 'Toggle Grid (G)' },
            { id: 'info-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`, action: toggleInfo, title: 'Toggle Info (I)' },
        ];

        controlButtons.forEach(btnInfo => {
            const button = document.createElement('button');
            button.id = btnInfo.id;
            button.innerHTML = btnInfo.icon;
            button.title = btnInfo.title;
            button.className = "p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all";
            button.addEventListener('click', btnInfo.action);
            controlsContainer.appendChild(button);
        });

        function togglePause() {
            params.isPaused = !params.isPaused;
            document.getElementById('pause-btn').innerHTML = params.isPaused ? playIcon : pauseIcon;
        }
        function toggleCinematic() {
            params.cinematicCamera = !params.cinematicCamera;
            cinematicController.updateDisplay();
        }
        function toggleGrid() {
            params.showGrid = !params.showGrid;
            spacetimeGrid.group.visible = params.showGrid;
            gridController.updateDisplay();
        }
        function toggleInfo() {
            params.showInfo = !params.showInfo;
            document.getElementById('info-panel').style.opacity = params.showInfo ? '1' : '0';
            infoController.updateDisplay();
        }

        function initSimulation() {
            // Clear previous simulation objects
            blackHoles.forEach(bh => bh.dispose());
            if (massStream) massStream.dispose();
            particleSystems.forEach(ps => {
                scene.remove(ps);
                ps.geometry.dispose();
                ps.material.dispose();
            });
            particleSystems = [];
            jets = [];
            blackHoles = [];
            
            simulationTime = 0;
            mergerTime = -1;
            simulationActive = true;

            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'INSPIRAL';
            phaseEl.style.color = '#22d3ee'; // cyan-400
            document.getElementById('progressBar').style.width = '0%';
            
            const m1 = params.mass1, m2 = params.mass2, dist = params.distance;
            initialDistance = dist;
            const totalMass = m1 + m2;
            
            // Circular orbit velocities
            const v = Math.sqrt(G * totalMass / dist);
            const v1 = v * m2 / totalMass;
            const v2 = v * m1 / totalMass;
            
            // Initial positions (center of mass at origin)
            const r1 = dist * m2 / totalMass;
            const r2 = dist * m1 / totalMass;
            
            const bh1 = new BlackHole(m1, new THREE.Vector3(-r1, 0, 0), new THREE.Vector3(0, 0, -v1), true);
            const bh2 = new BlackHole(m2, new THREE.Vector3(r2, 0, 0), new THREE.Vector3(0, 0, v2), false);
            
            blackHoles.push(bh1, bh2);
            massStream = new MassStream();
            wavePass.uniforms.time.value = -1.0;
            godRayPass.enabled = false;
            setCameraFocus(-1);
        }
        
        function applyPreset(m1, m2, d) {
            params.mass1 = m1;
            params.mass2 = m2;
            params.distance = d;
            mass1Controller.updateDisplay();
            mass2Controller.updateDisplay();
            distanceController.updateDisplay();
            initSimulation();
        }
        
        function updateQuality(quality) {
            let pixelRatio = 1;
            let samples = 30;
            switch(quality) {
                case 'low':
                    pixelRatio = 1;
                    samples = 30;
                    break;
                case 'medium':
                    pixelRatio = Math.min(window.devicePixelRatio, 1.5);
                    samples = 60;
                    break;
                case 'high':
                case 'ultra':
                    pixelRatio = Math.min(window.devicePixelRatio, 2);
                    samples = 80;
                    break;
            }
            renderer.setPixelRatio(pixelRatio);
            composer.setPixelRatio(pixelRatio);
            godRayPass.uniforms.samples.value = samples;
        }
        
        // --- Camera and Effects Management ---
        let shakeDuration = 0, shakeIntensity = 0;
        function triggerCameraShake(duration = 0.5, intensity = 0.5) { 
            shakeDuration = duration; 
            shakeIntensity = intensity; 
        }
        
        function updateCameraShake(deltaTime) { 
            if (shakeDuration > 0) { 
                shakeDuration -= deltaTime;
                const shake = shakeIntensity * (shakeDuration / 0.5); // Fade out
                camera.position.x += (Math.random() - 0.5) * shake; 
                camera.position.y += (Math.random() - 0.5) * shake;
                camera.position.z += (Math.random() - 0.5) * shake * 0.5;
            } 
        }
        
        function triggerGravitationalWave(origin) { 
            const screenPos = origin.clone().project(camera); 
            wavePass.uniforms.origin.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2); 
            wavePass.uniforms.time.value = 0.0; 
            wavePass.uniforms.amplitude.value = 0.04; 
        }
        
        function triggerBloomFlash(strength) { 
            let flashStrength = strength; 
            const flashInterval = setInterval(() => { 
                bloomPass.strength = flashStrength; 
                flashStrength *= 0.9;
                if (flashStrength <= params.bloomIntensity) { 
                    bloomPass.strength = params.bloomIntensity; 
                    clearInterval(flashInterval); 
                } 
            }, 16); 
        }

        function triggerGodRayFlash(origin) {
            const screenPos = origin.clone().project(camera);
            godRayPass.enabled = true;
            godRayPass.uniforms.lightPosition.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2);
            godRayPass.uniforms.exposure.value = 1.0;
        }
        
        let focusIndex = -1;
        function setCameraFocus(index) {
            focusIndex = index;
            params.cinematicCamera = false;
            cinematicController.updateDisplay();
        }

        function updateCamera(time) {
            if (params.cinematicCamera) {
                const phase = (time * 0.05) % (Math.PI * 2);
                const radius = 120 + Math.sin(phase * 2) * 30;
                const height = 50 + Math.sin(phase * 3) * 20;
                
                camera.position.x = Math.cos(phase) * radius;
                camera.position.z = Math.sin(phase) * radius;
                camera.position.y = height;
                
                const lookAhead = 0.1;
                const lookX = Math.cos(phase + lookAhead) * radius * 0.3;
                const lookZ = Math.sin(phase + lookAhead) * radius * 0.3;
                controls.target.set(lookX, 0, lookZ);
            } else {
                let targetPos = new THREE.Vector3();
                if (focusIndex === -1 && blackHoles.length > 1) {
                    const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                    targetPos.addScaledVector(blackHoles[0].position, blackHoles[0].mass / totalMass);
                    targetPos.addScaledVector(blackHoles[1].position, blackHoles[1].mass / totalMass);
                } else if (focusIndex >= 0 && blackHoles[focusIndex]) {
                    targetPos.copy(blackHoles[focusIndex].position);
                } else if (blackHoles.length === 1) {
                    targetPos.copy(blackHoles[0].position);
                }
                cameraTarget.position.lerp(targetPos, 0.1);
                controls.target.lerp(cameraTarget.position, 0.1);
            }
        }
        
        // --- Centralized Particle System Update ---
        function updateAllParticleSystems(deltaTime) {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const system = particleSystems[i];
                const type = system.userData.type;

                if (type === 'accretion') {
                    const bh = system.userData.parentBH;
                    if (!bh) continue;

                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    const lifetimes = system.geometry.attributes.lifetime.array;
                    const colors = system.geometry.attributes.customColor.array;
                    
                    for (let j = 0; j < lifetimes.length; j++) {
                        lifetimes[j] -= deltaTime * 0.1;
                        
                        if (lifetimes[j] <= 0) {
                            // Respawn
                            const angle = Math.random() * Math.PI * 2;
                            const radius = bh.radius * 1.5 + Math.random() * bh.radius * 2.5;
                            
                            positions[j * 3] = Math.cos(angle) * radius;
                            positions[j * 3 + 1] = (Math.random() - 0.5) * 2;
                            positions[j * 3 + 2] = Math.sin(angle) * radius;
                            
                            lifetimes[j] = 1.0;
                        } else {
                            // Update position with gravity
                            const x = positions[j * 3];
                            const y = positions[j * 3 + 1];
                            const z = positions[j * 3 + 2];
                            const r = Math.sqrt(x * x + z * z);
                            
                            // Gravitational acceleration
                            const accel = -G * bh.mass / (r * r);
                            velocities[j * 3] += (x / r) * accel * deltaTime;
                            velocities[j * 3 + 2] += (z / r) * accel * deltaTime;
                            
                            positions[j * 3] += velocities[j * 3] * deltaTime;
                            positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                            positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        }
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.geometry.attributes.lifetime.needsUpdate = true;
                    system.material.uniforms.opacity.value = params.particleDensity;
                } else if (type === 'jet') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for (let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                } else if (type === 'burst') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for(let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        velocities[j * 3] *= 0.99;
                        velocities[j * 3 + 1] *= 0.99;
                        velocities[j * 3 + 2] *= 0.99;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.material.opacity -= deltaTime * 0.5;
                    if (system.material.opacity <= 0) {
                        scene.remove(system);
                        system.geometry.dispose();
                        system.material.dispose();
                        particleSystems.splice(i, 1);
                    }
                }
                if (system.material.uniforms && system.material.uniforms.time) {
                    system.material.uniforms.time.value += deltaTime;
                }
            }
        }

        // --- Main Animation Loop ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const effectiveDeltaTime = clock.getDelta();
            const timeScale = params.isPaused ? 0 : params.timeScale;
            const deltaTime = effectiveDeltaTime * timeScale;
            const elapsedTime = clock.getElapsedTime();
            
            // Update simulation
            updatePhysics(deltaTime);
            if (!params.cinematicCamera) controls.update();
            updateCamera(elapsedTime);
            updateCameraShake(deltaTime);
            updateAllParticleSystems(deltaTime);
            
            // Update background
            starfieldMaterial.uniforms.time.value = elapsedTime;
            
            // Update post-merger effects
            if (mergerTime > 0 && blackHoles.length === 1) {
                const bh = blackHoles[0];
                const precessionQuaternion = new THREE.Quaternion().setFromAxisAngle(bh.precessionAxis, deltaTime * bh.spinMagnitude * 0.1);
                bh.group.quaternion.premultiply(precessionQuaternion);
                
                jets.forEach(jet => {
                    if (jet.material.uniforms.opacity.value > 0) {
                        jet.material.uniforms.opacity.value *= 0.995;
                    }
                    if (jet.material.uniforms.time) {
                        jet.material.uniforms.time.value = elapsedTime;
                    }
                });

                if (bh.diskMaterial.uniforms.ringdown.value > 0.001) {
                    bh.diskMaterial.uniforms.ringdown.value *= (1.0 - 0.8 * effectiveDeltaTime);
                } else {
                    bh.diskMaterial.uniforms.ringdown.value = 0.0;
                }
                updateInfoDisplay();
            }

            // Update lensing positions
            const screenPositions = blackHoles.map(bh => {
                const pos = bh.group.position.clone();
                pos.project(camera);
                return pos;
            });
            
            for (let i = 0; i < 10; i++) {
                if (i < blackHoles.length) {
                    lensingPass.uniforms.bhPositions.value[i].set(
                        (screenPositions[i].x + 1) / 2, 
                        (screenPositions[i].y + 1) / 2
                    );
                    lensingPass.uniforms.bhMasses.value[i] = blackHoles[i].mass;
                } else {
                    lensingPass.uniforms.bhPositions.value[i].set(-10, -10);
                    lensingPass.uniforms.bhMasses.value[i] = 0;
                }
            }
            lensingPass.uniforms.bhCount.value = blackHoles.length;
            lensingPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspect.value = window.innerWidth / window.innerHeight;
            
            // Update gravitational wave effect
            if (wavePass.uniforms.time.value >= 0) {
                wavePass.uniforms.time.value += deltaTime;
                if (wavePass.uniforms.time.value > 1.0) {
                    wavePass.uniforms.time.value = -1.0;
                }
            }

            // Update God Ray effect
            if (godRayPass.enabled) {
                godRayPass.uniforms.exposure.value *= (1.0 - 1.5 * effectiveDeltaTime);
                if (godRayPass.uniforms.exposure.value < 0.01) {
                    godRayPass.enabled = false;
                }
            }

            // Render
            composer.render();
        }
        
        // Start simulation
        const loader = document.getElementById('loader');
        initSimulation();
        animate();
        loader.style.opacity = '0';
        setTimeout(() => loader.style.display = 'none', 500);


        // --- Window Resize Handler ---
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
            composer.setSize(width, height);
            
            lensingPass.uniforms.resolution.value.set(width, height);
            lensingPass.uniforms.aspect.value = width / height;
            
            smaaPass.setSize(width, height);
            
            updateQuality(params.quality);
        });
        
        // --- Keyboard Controls ---
        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    togglePause();
                    break;
                case 'c': toggleCinematic(); break;
                case 'g': toggleGrid(); break;
                case 'i': toggleInfo(); break;
                case 'r': initSimulation(); break;
            }
        });
    </script>

<canvas data-engine="three.js r178" width="2704" height="410" style="display: block; width: 1352px; height: 205px; touch-action: none;"></canvas><div class="lil-gui allow-touch-styles root autoPlace"><div class="title" role="button" aria-expanded="true" tabindex="0">Controls</div><div class="children"><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Presets</div><div class="children"><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-5">Asymmetric Merger</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-6">Equal Mass</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-7">Extreme Mass Ratio</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-8">Massive Merger</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Director Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-9">Time Scale</div><div class="widget"><div class="slider"><div class="fill" style="width: 18.367347%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-9"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-10">Cinematic Camera</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-10"></label></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-11">Focus on Black Hole 1</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-12">Focus on Black Hole 2</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-13">Focus on Center</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-14">Reset Camera</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Visual Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-15">Disk Brightness</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-15"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-16">Bloom Intensity</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-16"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-17">Show Spacetime Grid</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-17"></label></div><div class="controller boolean"><div class="name" id="lil-gui-name-18">Show Info Display</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-18"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-19">Particle Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-19"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-20">Nebula Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-20"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-21">Star Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-21"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Advanced Physics</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-22">Orbital Decay Rate</div><div class="widget"><div class="slider"><div class="fill" style="width: 25%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-22"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-23">Final BH Spin (a/M)</div><div class="widget"><div class="slider"><div class="fill" style="width: 91.836735%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-23"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-24">Camera Shake</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-24"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-25">Lensing Strength</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-25"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-26">Play Merger Sound</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-26"></label></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Post Processing</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-27">Exposure</div><div class="widget"><div class="slider"><div class="fill" style="width: 33.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-27"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-28">Contrast</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-28"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-29">Saturation</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-29"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Performance</div><div class="children"><div class="controller option"><div class="name" id="lil-gui-name-30">Quality</div><div class="widget"><select aria-labelledby="lil-gui-name-30"><option>low</option><option>medium</option><option>high</option><option>ultra</option></select><div class="display">ultra</div></div></div></div></div></div></div></body></html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Black Hole Merger - Enhanced Edition v3</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a cleaner look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <style>.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"↕";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"▾";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"▸"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"✓";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}</style><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&amp;family=Roboto+Mono:wght@400;700&amp;display=swap" rel="stylesheet">
    <style>
        /* Basic body styles */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            color: #e5e7eb;
        }
        canvas { display: block; }

        /* Custom styles for lil-gui */
        .lil-gui {
            --font-size: 14px;
            --width: 320px;
            --background-color: rgba(0, 0, 0, 0.6);
            --widget-color: #a78bfa; /* violet-400 */
            --hover-color: #c4b5fd; /* violet-300 */
            --text-color: #e5e7eb; /* gray-200 */
            --font-family: 'Roboto Mono', monospace;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
        }
        .lil-gui.root > .title {
            color: #fff;
            background-color: rgba(255,255,255,0.05);
        }
        .lil-gui .name {
            font-weight: 500;
        }
        .lil-gui .controller.boolean .label {
            border-left-color: rgba(255,255,255,0.2);
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            font-family: 'Roboto Mono', monospace;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }
    </style>
    <!-- Using the latest stable version of Three.js as of July 2025 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/"
        }
    }
    </script>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.16 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.pointer-events-none{pointer-events:none}.pointer-events-auto{pointer-events:auto}.fixed{position:fixed}.absolute{position:absolute}.inset-0{inset:0px}.bottom-4{bottom:1rem}.left-1\/2{left:50%}.left-4{left:1rem}.top-4{top:1rem}.mb-2{margin-bottom:0.5rem}.mb-4{margin-bottom:1rem}.flex{display:flex}.grid{display:grid}.h-2{height:0.5rem}.h-full{height:100%}.w-full{width:100%}.max-w-lg{max-width:32rem}.-translate-x-1\/2{--tw-translate-x:-50%;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.grid-cols-\[auto\2c 1fr\]{grid-template-columns:auto 1fr}.items-center{align-items:center}.justify-center{justify-content:center}.gap-2{gap:0.5rem}.gap-x-4{column-gap:1rem}.gap-y-1{row-gap:0.25rem}.overflow-hidden{overflow:hidden}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:0.5rem}.rounded-md{border-radius:0.375rem}.border{border-width:1px}.border-white\/10{border-color:rgb(255 255 255 / 0.1)}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0 / var(--tw-bg-opacity, 1))}.bg-black\/60{background-color:rgb(0 0 0 / 0.6)}.bg-white\/10{background-color:rgb(255 255 255 / 0.1)}.bg-gradient-to-r{background-image:linear-gradient(to right, var(--tw-gradient-stops))}.from-cyan-400{--tw-gradient-from:#22d3ee var(--tw-gradient-from-position);--tw-gradient-to:rgb(34 211 238 / 0) var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to)}.to-purple-500{--tw-gradient-to:#a855f7 var(--tw-gradient-to-position)}.p-2{padding:0.5rem}.p-3{padding:0.75rem}.p-4{padding:1rem}.px-4{padding-left:1rem;padding-right:1rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}.font-sans{font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-xs{font-size:0.75rem;line-height:1rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.font-bold{font-weight:700}.uppercase{text-transform:uppercase}.tracking-widest{letter-spacing:0.1em}.text-cyan-300{--tw-text-opacity:1;color:rgb(103 232 249 / var(--tw-text-opacity, 1))}.text-gray-200{--tw-text-opacity:1;color:rgb(229 231 235 / var(--tw-text-opacity, 1))}.text-gray-300{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity, 1))}.text-gray-400{--tw-text-opacity:1;color:rgb(156 163 175 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.opacity-100{opacity:1}.shadow-inner{--tw-shadow:inset 0 2px 4px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:inset 0 2px 4px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.backdrop-blur-md{--tw-backdrop-blur:blur(12px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.transition-colors{transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.duration-300{transition-duration:300ms}.duration-500{transition-duration:500ms}.ease-out{transition-timing-function:cubic-bezier(0, 0, 0.2, 1)}.hover\:bg-white\/10:hover{background-color:rgb(255 255 255 / 0.1)}.hover\:text-white:hover{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.focus\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\:ring-2:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.focus\:ring-purple-400:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(192 132 252 / var(--tw-ring-opacity, 1))}@media (min-width: 640px){.sm\:left-6{left:1.5rem}.sm\:top-6{top:1.5rem}.sm\:p-6{padding:1.5rem}}@media (min-width: 1024px){.lg\:left-8{left:2rem}.lg\:top-8{top:2rem}.lg\:p-8{padding:2rem}}</style></head>
<body class="bg-black">
    <!-- Loading overlay -->
    <div id="loader" style="opacity: 0; display: none;">Initializing Simulation...</div>

    <!-- Enhanced UI Container -->
    <div id="ui-container" class="fixed inset-0 p-4 sm:p-6 lg:p-8 pointer-events-none text-gray-200 font-mono text-sm">
        <!-- Top-left Info Panel -->
        <div id="info-panel" class="absolute top-4 left-4 sm:top-6 sm:left-6 lg:top-8 lg:left-8 bg-black/60 backdrop-blur-md p-4 rounded-lg border border-white/10 shadow-lg pointer-events-auto transition-all duration-300 opacity-100">
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">66.5 Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">1335.05 s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">-1 E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">0.001 Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">105.8 s</span>
                    </div></div>

        <!-- Bottom Controls -->
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 w-full max-w-lg px-4">
            <!-- Timeline -->
            <div id="timeline-container" class="bg-black/60 backdrop-blur-md p-3 rounded-lg border border-white/10 shadow-lg mb-4 pointer-events-auto">
                <div id="phase" class="text-center text-xs font-bold tracking-widest uppercase mb-2 text-cyan-300 transition-colors duration-500" style="color: rgb(34, 211, 238);">INSPIRAL</div>
                <div id="progress" class="w-full h-2 bg-white/10 rounded-full overflow-hidden shadow-inner">
                    <div id="progressBar" class="h-full bg-gradient-to-r from-cyan-400 to-purple-500 transition-all duration-500 ease-out" style="width: 5.066561%;"></div>
                </div>
            </div>
            <!-- Control Buttons -->
            <div id="controls" class="flex justify-center items-center gap-2 bg-black/60 backdrop-blur-md p-2 rounded-lg border border-white/10 shadow-lg pointer-events-auto">
                <!-- Buttons will be populated by JS -->
            <button id="restart-btn" title="Restart (R)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg></button><button id="pause-btn" title="Pause/Play (Space)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg></button><button id="cinematic-btn" title="Cinematic Camera (C)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg></button><button id="grid-btn" title="Toggle Grid (G)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg></button><button id="info-btn" title="Toggle Info (I)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></button></div>
        </div>
    </div>

    <!-- Audio for merger sound -->
    <audio id="mergerSound" src="https://gwosc.org/GW150914data/GW150914_H1_shifted.wav" preload="auto"></audio>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- Enhanced Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000011, 0.0003);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, // SMAA pass handles anti-aliasing
            powerPreference: "high-performance",
            alpha: false,
            stencil: false,
            depth: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Camera Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 800;
        controls.maxPolarAngle = Math.PI * 0.85;
        camera.position.set(0, 40, 90);

        // --- Ultra HD Galaxy Background ---
        const starfieldMaterial = new THREE.ShaderMaterial({
            uniforms: { 
                time: { value: 0.0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                nebulaDensity: { value: 2.0 },
                starDensity: { value: 3.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                varying vec3 vPosition;
                void main() { 
                    vUv = uv; 
                    vPosition = position;
                    gl_Position = vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                uniform float nebulaDensity;
                uniform float starDensity;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                // High quality noise functions
                float hash(vec3 p) { 
                    p = fract(p * vec3(443.8975, 397.2973, 491.1871));
                    p += dot(p, p.yxz + 19.19);
                    return fract((p.x + p.y) * p.z);
                }
                
                float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    return mix(mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
                                   mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                               mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                   mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                }
                
                float fbm(vec3 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    float frequency = 1.0;
                    for(int i = 0; i < 6; i++) {
                        value += amplitude * noise(p * frequency);
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }
                    return value;
                }
                
                void main() {
                    vec3 color = vec3(0.0);
                    vec2 uv = vUv;
                    vec3 pos = vPosition;
                    
                    // Ultra HD star field
                    for(int i = 0; i < 5; i++) {
                        float scale = 100.0 + float(i) * 200.0;
                        vec2 starUv = uv * scale;
                        float star = hash(vec3(floor(starUv), float(i)));
                        
                        if(star > 0.98 - float(i) * 0.01) {
                            vec2 starPos = fract(starUv) - 0.5;
                            float dist = length(starPos);
                            float brightness = 1.0 - smoothstep(0.0, 0.02, dist);
                            brightness *= (0.5 + 0.5 * sin(time * (1.0 + star * 5.0)));
                            
                            // Star color variation
                            vec3 starColor = vec3(1.0);
                            float colorType = hash(vec3(floor(starUv), float(i) + 100.0));
                            if(colorType < 0.3) starColor = vec3(1.0, 0.8, 0.6); // Yellow
                            else if(colorType < 0.6) starColor = vec3(0.8, 0.8, 1.0); // Blue-white
                            else if(colorType < 0.8) starColor = vec3(1.0, 0.6, 0.4); // Red
                            
                            color += starColor * brightness * starDensity / float(i + 1);
                        }
                    }
                    
                    // High detail nebula
                    vec3 nebulaPos = pos * 0.001;
                    float nebula1 = fbm(nebulaPos + vec3(time * 0.01, 0.0, 0.0));
                    float nebula2 = fbm(nebulaPos * 2.0 - vec3(0.0, time * 0.02, 0.0));
                    float nebula3 = fbm(nebulaPos * 4.0 + vec3(0.0, 0.0, time * 0.03));
                    
                    float nebulaMask = nebula1 * 0.5 + nebula2 * 0.3 + nebula3 * 0.2;
                    nebulaMask = pow(nebulaMask, 2.0) * nebulaDensity;
                    
                    // Nebula color gradients
                    vec3 nebulaColor1 = vec3(0.1, 0.0, 0.4) * nebula1;
                    vec3 nebulaColor2 = vec3(0.0, 0.1, 0.3) * nebula2;
                    vec3 nebulaColor3 = vec3(0.2, 0.0, 0.2) * nebula3;
                    vec3 nebulaColor = (nebulaColor1 + nebulaColor2 + nebulaColor3) * 0.5;
                    
                    color += nebulaColor * nebulaMask;
                    
                    // Milky way band
                    float band = 1.0 - abs(pos.y * 0.005);
                    band = pow(band, 4.0) * 0.2;
                    vec3 bandColor = mix(vec3(0.05, 0.03, 0.08), vec3(0.1, 0.08, 0.15), noise(pos * 0.01));
                    color += bandColor * band;
                    
                    // Distant galaxies
                    float galaxyNoise = hash(vec3(uv * 50.0, 0.0));
                    if(galaxyNoise > 0.999) {
                        float galaxyBrightness = pow(galaxyNoise, 10.0) * 0.5;
                        color += vec3(0.8, 0.7, 0.9) * galaxyBrightness;
                    }
                    
                    // Final color grading
                    color = pow(color, vec3(0.85));
                    color = mix(color, vec3(dot(color, vec3(0.299, 0.587, 0.114))), -0.2);
                    
                    gl_FragColor = vec4(color, 1.0);
                }`,
            side: THREE.BackSide
        });
        const starfieldSphere = new THREE.Mesh(new THREE.IcosahedronGeometry(2000, 4), starfieldMaterial);
        scene.add(starfieldSphere);

        // --- Advanced Ambient Lighting ---
        const ambientLight = new THREE.AmbientLight(0x0a0a0a, 0.5);
        scene.add(ambientLight);

        // --- High Quality Spacetime Grid ---
        class SpacetimeGrid {
            constructor() {
                this.gridSize = 300;
                this.gridDivisions = 60;
                this.group = new THREE.Group();
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        bhPositions: { value: [new THREE.Vector3(), new THREE.Vector3()] },
                        bhMasses: { value: [0, 0] },
                        time: { value: 0 },
                        opacity: { value: 0.3 },
                        waveAmplitude: { value: 0.0 },
                        waveOrigin: { value: new THREE.Vector3() },
                        waveTime: { value: 0.0 }
                    },
                    vertexShader: `
                        uniform vec3 bhPositions[2];
                        uniform float bhMasses[2];
                        uniform float time;
                        uniform float waveAmplitude;
                        uniform vec3 waveOrigin;
                        uniform float waveTime;
                        
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            vec3 pos = position;
                            float totalDistortion = 0.0;
                            
                            // Black hole warping
                            for(int i = 0; i < 2; i++) {
                                if(bhMasses[i] > 0.0) {
                                    vec3 delta = pos - bhPositions[i];
                                    delta.y = 0.0;
                                    float dist = length(delta);
                                    float warp = bhMasses[i] / (dist + 5.0);
                                    float falloff = exp(-dist * 0.05);
                                    pos.y -= warp * 3.0 * falloff;
                                    totalDistortion += warp;
                                }
                            }
                            
                            // Gravitational wave ripples
                            float waveDist = length(pos.xz - waveOrigin.xz);
                            float wave = sin(waveDist * 0.3 - waveTime * 15.0) * waveAmplitude;
                            wave *= exp(-waveDist * 0.01) * exp(-waveTime * 2.0);
                            pos.y += wave * 5.0;
                            vWave = wave;
                            
                            // Orbital motion distortion
                            float orbitalEffect = sin(time * 2.0 + length(pos.xz) * 0.05) * 0.2;
                            pos.y += orbitalEffect * totalDistortion;
                            
                            vDistortion = totalDistortion;
                            vColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.0, 0.5), totalDistortion * 0.2);
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            float intensity = 0.3 + vDistortion * 0.7 + abs(vWave) * 2.0;
                            vec3 color = vColor;
                            
                            // Pulsing effect
                            float pulse = sin(time * 3.0 + vDistortion * 10.0) * 0.1 + 0.9;
                            intensity *= pulse;
                            
                            // Wave color enhancement
                            if(abs(vWave) > 0.01) {
                                color = mix(color, vec3(0.5, 0.0, 1.0), abs(vWave) * 5.0);
                            }
                            
                            gl_FragColor = vec4(color, opacity * intensity);
                        }`,
                    transparent: true,
                    wireframe: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const geometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize, this.gridDivisions, this.gridDivisions);
                geometry.rotateX(-Math.PI / 2);
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.position.y = -10;
                this.group.add(this.mesh);
                
                scene.add(this.group);
                this.group.visible = false;
            }
            
            update(blackHoles, deltaTime) {
                if (blackHoles.length > 0) {
                    this.material.uniforms.bhPositions.value[0].copy(blackHoles[0].position);
                    this.material.uniforms.bhMasses.value[0] = blackHoles[0].mass;
                }
                if (blackHoles.length > 1) {
                    this.material.uniforms.bhPositions.value[1].copy(blackHoles[1].position);
                    this.material.uniforms.bhMasses.value[1] = blackHoles[1].mass;
                } else {
                    this.material.uniforms.bhMasses.value[1] = 0;
                }
                this.material.uniforms.time.value += deltaTime;
                this.material.uniforms.waveTime.value += deltaTime;
            }
            
            triggerWave(origin, amplitude) {
                this.material.uniforms.waveOrigin.value.copy(origin);
                this.material.uniforms.waveAmplitude.value = amplitude;
                this.material.uniforms.waveTime.value = 0;
            }
        }

        // --- Physics & Simulation State ---
        const G = 0.1;
        let blackHoles = [];
        let massStream = null;
        let jets = [];
        let simulationActive = true;
        let spacetimeGrid = new SpacetimeGrid();
        let particleSystems = [];
        let initialDistance = 70;
        let simulationTime = 0;
        let mergerTime = -1;
        
        const params = {
            mass1: 40, 
            mass2: 25, 
            distance: 70, 
            timeScale: 1.0, 
            isPaused: false,
            orbitalDecay: 0.005,
            diskEmissivity: 3.0, 
            bloomIntensity: 1.5, 
            finalSpin: 0.9, 
            cameraShake: true, 
            cinematicCamera: false,
            showGrid: false, 
            showInfo: true, 
            quality: 'ultra',
            particleDensity: 1.5, 
            lensingStrength: 1.0,
            playSound: true, // New parameter for sound
            focusBH1: () => setCameraFocus(0),
            focusBH2: () => setCameraFocus(1),
            focusCenter: () => setCameraFocus(-1),
            resetCamera: () => {
                setCameraFocus(-1);
                controls.reset();
                camera.position.set(0, 40, 90);
            },
            start: () => initSimulation(),
            preset1: () => applyPreset(40, 25, 70),
            preset2: () => applyPreset(30, 30, 80),
            preset3: () => applyPreset(50, 10, 100),
            preset4: () => applyPreset(140, 100, 120) // New 2025 massive merger preset
        };
        
        let cameraTarget = new THREE.Object3D();
        scene.add(cameraTarget);

        // --- Ultra HD BlackHole Class (with enhanced Doppler shift) ---
        class BlackHole {
            constructor(mass, position, velocity, isPrimary = false) {
                this.mass = mass; 
                this.position = position; 
                this.velocity = velocity;
                this.isPrimary = isPrimary;
                this.isMerged = false; 
                this.radius = Math.pow(mass, 1/3);
                this.spin = new THREE.Vector3(0, 1, 0).multiplyScalar(Math.random() * 0.5 + 0.5);
                this.spinMagnitude = 0;
                this.precessionAxis = new THREE.Vector3(0, 1, 0);
                
                this.group = new THREE.Group();
                
                // Schwarzschild radius event horizon
                const eventHorizonGeometry = new THREE.SphereGeometry(this.radius, 128, 64);
                this.eventHorizon = new THREE.Mesh(eventHorizonGeometry, new THREE.MeshBasicMaterial({ 
                    color: 0x000000
                }));
                this.eventHorizon.castShadow = true;
                this.eventHorizon.receiveShadow = true;
                this.group.add(this.eventHorizon);
                
                // Multi-layer glow effect
                for(let i = 0; i < 3; i++) {
                    const glowScale = 1.1 + i * 0.05;
                    const glowGeometry = new THREE.SphereGeometry(this.radius * glowScale, 64, 32);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: isPrimary ? 0xff6600 : 0x0066ff,
                        transparent: true,
                        opacity: 0.1 / (i + 1),
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.group.add(glow);
                }
                
                // Dynamic light sources
                this.light = new THREE.PointLight(isPrimary ? 0xffaa66 : 0x6699ff, 2, 300, 2);
                this.light.castShadow = true;
                this.light.shadow.mapSize.width = 1024;
                this.light.shadow.mapSize.height = 1024;
                this.group.add(this.light);
                
                // Rim lighting
                const rimLight = new THREE.PointLight(isPrimary ? 0xff6600 : 0x0066ff, 1, 200, 2);
                rimLight.position.set(0, this.radius * 2, 0);
                this.group.add(rimLight);

                // Ultra HD accretion disk with enhanced Doppler
                this.createAccretionDisk();
                
                scene.add(this.group);
                
                // HD Particle systems
                this.createParticleSystem();
                this.createPhotonSphere();
            }
            
            createAccretionDisk() {
                const diskInner = this.radius * 1.5; 
                const diskOuter = this.radius * 4;
                
                this.diskMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        innerRadius: { value: diskInner },
                        outerRadius: { value: diskOuter },
                        emissiveIntensity: { value: params.diskEmissivity },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xff8800) : new THREE.Color(0x0088ff) },
                        rotationSpeed: { value: 1.0 },
                        temperature: { value: 1.0 },
                        ringdown: { value: 0.0 },
                        tidalForce: { value: new THREE.Vector3() },
                        cameraPos: { value: new THREE.Vector3() }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float ringdown;
                        uniform vec3 tidalForce;
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;

                        void main() {
                            vUv = uv;
                            vPos = position;
                            vNormal = normal;
                            vec3 pos = position;
                            
                            // Tidal Disruption Effect
                            float tidalMagnitude = length(tidalForce);
                            if (tidalMagnitude > 0.01) {
                                vec3 dirToForce = normalize(tidalForce);
                                float alignment = dot(normalize(pos.xz), normalize(dirToForce.xz));
                                float stretch = smoothstep(0.5, 1.0, alignment) * tidalMagnitude * 5.0;
                                pos += dirToForce * stretch;
                            }

                            // Ringdown oscillation effect
                            if (ringdown > 0.0) {
                                float r = length(pos.xz);
                                float angle = atan(pos.z, pos.x);
                                float wobble = sin(r * 0.5 - time * 10.0) * sin(angle * 4.0); // Quadrupole oscillation
                                pos.y += wobble * ringdown * r * 0.1; // Amplitude proportional to radius
                            }
                            
                            vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float time;
                        uniform float innerRadius;
                        uniform float outerRadius;
                        uniform float emissiveIntensity;
                        uniform vec3 primaryColor;
                        uniform float rotationSpeed;
                        uniform float temperature;
                        uniform vec3 cameraPos;
                        
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vWorldPosition;
                        
                        // High quality noise
                        float noise(vec2 p) {
                            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                        }
                        
                        float turbulence(vec2 p) {
                            float value = 0.0;
                            float scale = 1.0;
                            for(int i = 0; i < 5; i++) {
                                value += noise(p * scale) / scale;
                                scale *= 2.0;
                            }
                            return value;
                        }
                        
                        vec3 blackbody(float temp) {
                            vec3 color;
                            float t = temp * 4000.0;
                            
                            if(t < 6600.0) {
                                color.r = 1.0;
                                color.g = 0.39 * log(t / 100.0) - 0.63;
                                color.b = 0.54 * log(t / 100.0 - 10.0) - 1.19;
                            } else {
                                color.r = 1.29 * pow(t / 100.0 - 60.0, -0.13);
                                color.g = 1.29 * pow(t / 100.0 - 60.0, -0.07);
                                color.b = 1.0;
                            }
                            
                            return clamp(color, 0.0, 1.0);
                        }
                        
                        void main() {
                            float dist = length(vPos);
                            float angle = atan(vPos.z, vPos.x);
                            
                            // Complex spiral arms
                            float spiral1 = sin(angle * 2.0 - time * rotationSpeed + dist * 0.3);
                            float spiral2 = sin(angle * 3.0 + time * rotationSpeed * 0.7 - dist * 0.2);
                            float spiralPattern = (spiral1 * 0.7 + spiral2 * 0.3) * 0.5 + 0.5;
                            
                            // Turbulence
                            float turb = turbulence(vec2(angle * 5.0, dist * 0.1) + time * 0.1);
                            spiralPattern = mix(spiralPattern, turb, 0.3);
                            
                            // Radial profile
                            float innerEdge = smoothstep(innerRadius - 1.0, innerRadius + 1.0, dist);
                            float outerEdge = 1.0 - smoothstep(outerRadius - 5.0, outerRadius, dist);
                            float radialFade = innerEdge * outerEdge;
                            
                            // Temperature gradient
                            float temp = temperature * (1.0 - (dist - innerRadius) / (outerRadius - innerRadius));
                            temp = pow(temp, 2.0);
                            
                            // Relativistic Doppler Beaming
                            vec3 tangent = normalize(vec3(-vPos.z, 0.0, vPos.x));
                            float speed = 0.3; // Relativistic speed factor
                            vec3 velocity = tangent * speed;
                            vec3 viewDir = normalize(cameraPos - vWorldPosition);
                            float dopplerFactor = dot(velocity, viewDir);
                            float brightnessBoost = pow(1.0 + dopplerFactor, 4.0);
                            temp *= (1.0 + dopplerFactor * 0.5); // Temperature shift
                            
                            // Color from temperature
                            vec3 color = blackbody(temp) * primaryColor;
                            
                            // Hot spots and flares
                            float hotSpot = pow(noise(vec2(angle * 10.0 + time, dist * 0.5)), 3.0);
                            color += color * hotSpot * 2.0;
                            
                            // Rim brightening
                            float innerRim = 1.0 - smoothstep(innerRadius, innerRadius + 2.0, dist);
                            color += primaryColor * pow(innerRim, 2.0) * 5.0;
                            
                            // Final composition
                            float intensity = radialFade * (0.6 + spiralPattern * 0.4) * emissiveIntensity * brightnessBoost;
                            color *= intensity;
                            
                            // Add glow
                            color += primaryColor * 0.1 * intensity;
                            
                            gl_FragColor = vec4(color, radialFade * 0.9);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const diskSegments = params.quality === 'ultra' ? 256 : 128;
                const diskGeometry = new THREE.RingGeometry(diskInner, diskOuter, diskSegments, 16);
                diskGeometry.rotateX(-Math.PI / 2);
                
                this.accretionDisk = new THREE.Mesh(diskGeometry, this.diskMaterial);
                this.group.add(this.accretionDisk);
            }
            
            createParticleSystem() {
                const particleCount = params.quality === 'ultra' ? 2000 : 1000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                const lifetimes = new Float32Array(particleCount);
                const sizes = new Float32Array(particleCount);
                const customColors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = this.radius * 1.5 + Math.random() * this.radius * 2.5;
                    const height = (Math.random() - 0.5) * 4;
                    
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = height * Math.exp(-radius / (this.radius * 3));
                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    const speed = Math.sqrt(G * this.mass / radius) * (0.8 + Math.random() * 0.4);
                    velocities[i * 3] = -Math.sin(angle) * speed;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                    velocities[i * 3 + 2] = Math.cos(angle) * speed;
                    
                    lifetimes[i] = Math.random();
                    sizes[i] = Math.random() * 2 + 0.5;
                    
                    const temp = 1.0 - (radius - this.radius) / (this.radius * 3);
                    customColors[i * 3] = temp;
                    customColors[i * 3 + 1] = temp * 0.5;
                    customColors[i * 3 + 2] = temp * 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xffaa66) : new THREE.Color(0x6699ff) },
                        opacity: { value: 1.0 }
                    },
                    vertexShader: `
                        attribute float lifetime;
                        attribute float size;
                        attribute vec3 customColor;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vLifetime = lifetime;
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z) * vLifetime;
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform vec3 primaryColor;
                        uniform float opacity;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * vLifetime * 0.8 * opacity;
                            vec3 finalColor = mix(primaryColor, vec3(1.0), vColor.r);
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.particles.userData.type = 'accretion';
                this.particles.userData.parentBH = this;
                this.group.add(this.particles);
                particleSystems.push(this.particles);
            }
            
            createPhotonSphere() {
                // Photon sphere at 1.5x Schwarzschild radius
                const photonRadius = this.radius * 1.5;
                const photonGeometry = new THREE.TorusGeometry(photonRadius, 0.1, 8, 64);
                const photonMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                this.photonSphere = new THREE.Mesh(photonGeometry, photonMaterial);
                this.photonSphere.rotation.x = Math.PI / 2;
                this.group.add(this.photonSphere);
            }
            
            update(deltaTime) {
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.group.position.copy(this.position);
                this.light.intensity = this.mass * 0.05 * params.diskEmissivity;
                
                // Update disk
                this.diskMaterial.uniforms.time.value += deltaTime;
                this.diskMaterial.uniforms.cameraPos.value.copy(camera.position);
                this.accretionDisk.rotation.y += deltaTime * 0.3;
                
                // Photon sphere rotation
                if(this.photonSphere) {
                    this.photonSphere.rotation.z += deltaTime * 2;
                }
                
                if (this.isMerged) {
                    this.diskMaterial.uniforms.emissiveIntensity.value = THREE.MathUtils.lerp(
                        this.diskMaterial.uniforms.emissiveIntensity.value, 
                        params.diskEmissivity, 
                        deltaTime * 0.5
                    );
                }
            }
            
            dispose() {
                // Remove associated particle systems from the global array
                particleSystems = particleSystems.filter(p => p.userData.parentBH !== this);

                // Dispose of all geometries and materials to free up GPU memory
                this.group.traverse(child => {
                    if (child.isMesh || child.isPoints) {
                        child.geometry.dispose();
                        // If material is an array, dispose each one
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                scene.remove(this.group);
            }
        }
        
        // --- Ultra HD MassStream Class ---
        class MassStream {
            constructor() {
                this.particleCount = 1000;
                this.geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particleCount * 3);
                const customColors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);
                
                for (let i = 0; i < this.particleCount; i++) {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                    
                    const t = i / this.particleCount;
                    customColors[i * 3] = 1.0;
                    customColors[i * 3 + 1] = 0.5 + t * 0.5;
                    customColors[i * 3 + 2] = t;
                    
                    sizes[i] = Math.random() * 2 + 0.5;
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 0.8 }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 customColor;
                        varying vec3 vColor;
                        
                        void main() {
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (200.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * opacity;
                            vec3 finalColor = vColor * (1.0 + 0.5 * sin(time * 10.0));
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
            }
            
            update(p1, p2, v1, distance, deltaTime) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.customColor.array;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const t = i / this.particleCount;
                    
                    // Bezier curve for stream path
                    const midPoint = new THREE.Vector3().lerpVectors(p1, p2, 0.5);
                    const offset = new THREE.Vector3().crossVectors(
                        new THREE.Vector3().subVectors(p2, p1).normalize(),
                        new THREE.Vector3(0, 1, 0)
                    ).multiplyScalar(distance * 0.1 * Math.sin(t * Math.PI));
                    midPoint.add(offset);
                    
                    // Quadratic bezier interpolation
                    const t2 = 1 - t;
                    const point = new THREE.Vector3()
                        .addScaledVector(p1, t2 * t2)
                        .addScaledVector(midPoint, 2 * t2 * t)
                        .addScaledVector(p2, t * t);
                    
                    // Add turbulence
                    const turbulence = new THREE.Vector3(
                        Math.sin(t * 10 + this.material.uniforms.time.value * 5) * 2,
                        Math.cos(t * 8 + this.material.uniforms.time.value * 3) * 2,
                        Math.sin(t * 12 + this.material.uniforms.time.value * 4) * 2
                    );
                    point.add(turbulence);
                    
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                    
                    // Dynamic coloring based on distance
                    const heat = 1.0 - distance / 100;
                    colors[i * 3] = heat;
                    colors[i * 3 + 1] = heat * 0.5;
                    colors[i * 3 + 2] = (1 - heat) * 0.5;
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.customColor.needsUpdate = true;
                
                const opacity = 1.0 - THREE.MathUtils.smoothstep(distance, 40, 100);
                this.material.uniforms.opacity.value = opacity * 0.8;
                this.material.uniforms.time.value += deltaTime;
            }
            
            hide() { 
                this.material.uniforms.opacity.value = 0; 
            }
            
            dispose() {
                this.geometry.dispose();
                this.material.dispose();
                scene.remove(this.mesh);
            }
        }

        // --- Physics & Merger Logic ---
        function updatePhysics(deltaTime) {
            if (mergerTime < 0 && blackHoles.length > 1) {
                // Pre-merger physics
                simulationTime += deltaTime;
                
                const bh1 = blackHoles[0], bh2 = blackHoles[1];
                const distanceVec = new THREE.Vector3().subVectors(bh2.position, bh1.position);
                const distance = distanceVec.length();
                
                updateInfoDisplay(distance);
                
                const progress = 1.0 - (distance / initialDistance);
                document.getElementById('progressBar').style.width = `${progress * 100}%`;
                
                const phaseEl = document.getElementById('phase');
                if (distance < 30) {
                    phaseEl.textContent = 'MERGER PHASE';
                    phaseEl.style.color = '#f472b6'; // pink-400
                } else if (distance < 50) {
                    phaseEl.textContent = 'FINAL INSPIRAL';
                    phaseEl.style.color = '#f59e0b'; // amber-500
                }
                
                if (distance < bh1.radius + bh2.radius) { 
                    mergeBlackHoles(); 
                    return; 
                }
                
                // Newtonian gravity
                const forceMag = G * (bh1.mass * bh2.mass) / (distance * distance);
                const forceVec = distanceVec.normalize().multiplyScalar(forceMag);
                
                bh1.velocity.add(forceVec.clone().divideScalar(bh1.mass).multiplyScalar(deltaTime));
                bh2.velocity.add(forceVec.clone().multiplyScalar(-1).divideScalar(bh2.mass).multiplyScalar(deltaTime));
                
                // GW energy loss (orbital decay)
                const totalMass = bh1.mass + bh2.mass;
                const v = Math.sqrt(G * totalMass / distance);
                const mu = (bh1.mass * bh2.mass) / totalMass;
                const gwLuminosity = (32/5) * Math.pow(G, 4) * Math.pow(mu, 2) * Math.pow(totalMass, 3) / Math.pow(distance, 5);
                const energyLoss = gwLuminosity * deltaTime * 0.000005;
                const decayRate = energyLoss / (mu * v * v) + params.orbitalDecay * deltaTime;
                
                const decayVec = distanceVec.clone().normalize().multiplyScalar(-decayRate);
                bh1.position.add(decayVec.clone().multiplyScalar(bh2.mass / totalMass));
                bh2.position.add(decayVec.clone().multiplyScalar(-bh1.mass / totalMass));
                
                // Update tidal forces for disk deformation
                const tidalForceOn1 = forceVec.clone().multiplyScalar(1 / (distance * distance * 1000));
                bh1.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1);
                bh2.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1.negate());

                massStream.update(bh1.position, bh2.position, bh1.velocity, distance, deltaTime);
            }
            
            blackHoles.forEach(bh => bh.update(deltaTime));
            spacetimeGrid.update(blackHoles, deltaTime);
        }
        
        function updateInfoDisplay(distance) {
            if (!params.showInfo) return;
            const infoPanel = document.getElementById('info-panel');
            if (!infoPanel) return;

            if (blackHoles.length > 1) {
                const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(distance, 3) / (G * totalMass));
                const kineticEnergy = 0.5 * blackHoles[0].mass * blackHoles[0].velocity.lengthSq() + 
                                      0.5 * blackHoles[1].mass * blackHoles[1].velocity.lengthSq();
                const potentialEnergy = -G * blackHoles[0].mass * blackHoles[1].mass / distance;
                const totalEnergy = kineticEnergy + potentialEnergy;
                const gwFrequency = 2 / orbitalPeriod;
                
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">${distance.toFixed(1)} Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">${orbitalPeriod.toFixed(2)} s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">${totalEnergy.toFixed(0)} E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">${gwFrequency.toFixed(3)} Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">${simulationTime.toFixed(1)} s</span>
                    </div>`;
            } else if (blackHoles.length === 1) {
                const bh = blackHoles[0];
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">Remnant Black Hole</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Status:</span> <span class="text-green-400 font-bold text-right">Ringdown</span>
                        <span class="text-gray-400">Mass:</span> <span class="text-cyan-300 font-bold text-right">${bh.mass.toFixed(1)} M☉</span>
                        <span class="text-gray-400">Spin:</span> <span class="text-cyan-300 font-bold text-right">${bh.spinMagnitude.toFixed(2)} a/M</span>
                        <span class="text-gray-400">Kick Vel:</span> <span class="text-cyan-300 font-bold text-right">${bh.velocity.length().toFixed(1)} km/s</span>
                    </div>`;
            }
        }
        
        function mergeBlackHoles() {
            simulationActive = false; 
            massStream.hide();
            mergerTime = simulationTime;
            
            const bh1 = blackHoles[0], bh2 = blackHoles[1];
            const newMass = (bh1.mass + bh2.mass) * 0.95; // 5% radiated as GWs
            const newPosition = new THREE.Vector3().addVectors(
                bh1.position.clone().multiplyScalar(bh1.mass), 
                bh2.position.clone().multiplyScalar(bh2.mass)
            ).divideScalar(bh1.mass + bh2.mass);
            
            // GW recoil kick
            const kickVelocity = new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5
            );
            
            triggerGravitationalWave(newPosition); 
            triggerBloomFlash(30.0);
            triggerGodRayFlash(newPosition);
            if (params.cameraShake) triggerCameraShake(1.0, newMass / 50);
            
            createMergerFlash(newPosition);
            spacetimeGrid.triggerWave(newPosition, 0.5);
            
            // Play merger sound if enabled
            if (params.playSound) {
                document.getElementById('mergerSound').play();
            }
            
            bh1.dispose();
            bh2.dispose();
            
            const mergedBH = new BlackHole(newMass, newPosition, kickVelocity, true);
            mergedBH.isMerged = true;
            mergedBH.spinMagnitude = params.finalSpin;
            mergedBH.precessionAxis = new THREE.Vector3(Math.random() - 0.5, 1, Math.random() - 0.5).normalize();
            mergedBH.diskMaterial.uniforms.emissiveIntensity.value = 10.0;
            mergedBH.diskMaterial.uniforms.temperature.value = 2.0;
            mergedBH.diskMaterial.uniforms.ringdown.value = 1.0; // Start ringdown effect
            blackHoles = [mergedBH];
            
            createJets(mergedBH);
            
            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'RINGDOWN PHASE';
            phaseEl.style.color = '#4ade80'; // green-400
            document.getElementById('progressBar').style.width = '100%';
        }
        
        function createMergerFlash(position) {
            // Particle burst
            createParticleBurst(position);
        }
        
        function createParticleBurst(position) {
            const burstCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(burstCount * 3);
            const velocities = new Float32Array(burstCount * 3);
            const customColors = new Float32Array(burstCount * 3);
            
            for(let i = 0; i < burstCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const speed = 20 + Math.random() * 30;
                
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                velocities[i * 3] = Math.sin(phi) * Math.cos(theta) * speed;
                velocities[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * speed;
                velocities[i * 3 + 2] = Math.cos(phi) * speed;
                
                const color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.6, 1.0, 0.5);
                customColors[i * 3] = color.r;
                customColors[i * 3 + 1] = color.g;
                customColors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            const burst = new THREE.Points(geometry, material);
            burst.userData.type = 'burst';
            scene.add(burst);
            particleSystems.push(burst);
        }

        // --- Ultra HD Jet Creation ---
        function createJets(parentBH) {
            const jetLength = 800;
            const jetRadius = parentBH.radius * 0.15;
            
            // Jet shader material
            const jetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 1.0 },
                    jetLength: { value: jetLength },
                    primaryColor: { value: new THREE.Color(0x4444ff) },
                    secondaryColor: { value: new THREE.Color(0xff44ff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vY = position.y;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }`,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    uniform float jetLength;
                    uniform vec3 primaryColor;
                    uniform vec3 secondaryColor;
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453);
                    }
                    
                    void main() {
                        float height = abs(vY) / jetLength;
                        
                        // Jet structure
                        float radialFade = 1.0 - smoothstep(0.0, 1.0, vUv.x);
                        float heightFade = 1.0 - smoothstep(0.3, 1.0, height);
                        
                        // Pulsing waves
                        float pulse1 = sin(vY * 0.05 - time * 5.0) * 0.5 + 0.5;
                        float pulse2 = sin(vY * 0.08 + time * 3.0) * 0.5 + 0.5;
                        float combinedPulse = pulse1 * 0.7 + pulse2 * 0.3;
                        
                        // Turbulence
                        float turb = noise(vPosition * 0.1 + time);
                        
                        // Color mixing
                        vec3 color = mix(primaryColor, secondaryColor, combinedPulse + turb * 0.2);
                        color = mix(color, vec3(1.0), heightFade * 0.3);
                        
                        // Shock fronts
                        float shock = step(0.98, sin(vY * 0.02 - time * 2.0));
                        color += vec3(0.5, 0.3, 0.8) * shock;

                        // Brighter Core
                        float coreBrightness = pow(1.0 - vUv.x, 10.0);
                        color += vec3(1.0, 1.0, 1.5) * coreBrightness * 2.0;
                        
                        float alpha = opacity * radialFade * heightFade * (0.5 + combinedPulse * 0.5);
                        
                        gl_FragColor = vec4(color, alpha);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            // Create tapered jet geometry
            const jetGeometry = new THREE.CylinderGeometry(jetRadius, jetRadius * 0.1, jetLength, 32, 32, true);
            
            // Add twist to geometry
            const positions = jetGeometry.attributes.position.array;
            for(let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                const angle = y * 0.01;
                const x = positions[i];
                const z = positions[i + 2];
                positions[i] = x * Math.cos(angle) - z * Math.sin(angle);
                positions[i + 2] = x * Math.sin(angle) + z * Math.cos(angle);
            }
            jetGeometry.attributes.position.needsUpdate = true;
            
            const jetTop = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetTop.position.y = jetLength / 2;
            
            const jetBottom = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetBottom.position.y = -jetLength / 2;
            jetBottom.rotation.x = Math.PI;
            
            parentBH.group.add(jetTop, jetBottom);
            jets = [jetTop, jetBottom];
            
            // Jet particles
            createJetParticles(parentBH, jetLength);
        }
        
        function createJetParticles(parentBH, jetLength) {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const isTop = i < particleCount / 2;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * parentBH.radius * 0.15;
                const height = Math.random() * jetLength;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = isTop ? height : -height;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                const speed = 3 + Math.random() * 2;
                velocities[i * 3] = (Math.random() - 0.5) * 0.2;
                velocities[i * 3 + 1] = isTop ? speed : -speed;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                
                lifetimes[i] = Math.random();
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    jetLength: { value: jetLength }
                },
                vertexShader: `
                    attribute float lifetime;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vLifetime = lifetime;
                        vHeight = abs(position.y) / ${jetLength.toFixed(1)};
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (1.0 + vHeight * 3.0) * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }`,
                fragmentShader: `
                    uniform float time;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        if(dist > 0.5) discard;
                        
                        float opacity = smoothstep(0.5, 0.0, dist) * vLifetime * (1.0 - vHeight * 0.5);
                        vec3 color = mix(vec3(0.4, 0.4, 1.0), vec3(1.0, 0.4, 1.0), vHeight);
                        color += vec3(0.2) * (1.0 + sin(time * 10.0 + vHeight * 20.0));
                        
                        gl_FragColor = vec4(color, opacity);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const jetParticles = new THREE.Points(geometry, material);
            jetParticles.userData.type = 'jet';
            jetParticles.userData.parentBH = parentBH;
            parentBH.group.add(jetParticles);
            particleSystems.push(jetParticles);
        }

        // --- Post-Processing Pipeline ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // Gravitational Lensing Pass
        const lensingPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null }, 
                resolution: { value: new THREE.Vector2() }, 
                aspect: { value: 1.0 },
                bhPositions: { value: Array(10).fill(0).map(() => new THREE.Vector2()) },
                bhMasses: { value: new Float32Array(10) }, 
                bhCount: { value: 0 },
                strength: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform vec2 resolution; 
                uniform float aspect;
                uniform vec2 bhPositions[10]; 
                uniform float bhMasses[10]; 
                uniform int bhCount; 
                uniform float strength;
                varying vec2 vUv;
                
                vec2 computeLensing(vec2 uv) {
                    vec2 totalOffset = vec2(0.0);
                    
                    for (int i = 0; i < 10; i++) {
                        if (i >= bhCount) break;
                        
                        vec2 pos = uv - bhPositions[i]; 
                        pos.x *= aspect;
                        float dist = length(pos);
                        
                        // Einstein ring radius approximation
                        float einsteinRadius = sqrt(bhMasses[i] * 0.0005 * strength);
                        float deflection = einsteinRadius * einsteinRadius / (dist + 0.0001);
                        
                        totalOffset += normalize(pos) * deflection;
                    }
                    
                    totalOffset.x /= aspect;
                    return totalOffset;
                }
                
                void main() {
                    vec2 offset = computeLensing(vUv);
                    
                    // Chromatic aberration for strong lensing
                    float aberration = length(offset) * 3.0;
                    
                    vec3 color;
                    color.r = texture2D(tDiffuse, vUv - offset * (1.0 + aberration * 0.1)).r;
                    color.g = texture2D(tDiffuse, vUv - offset).g;
                    color.b = texture2D(tDiffuse, vUv - offset * (1.0 - aberration * 0.1)).b;
                    
                    // Edge darkening for extreme lensing
                    float edgeDark = 1.0 - smoothstep(0.0, 0.05, length(offset));
                    color *= edgeDark;
                    
                    gl_FragColor = vec4(color, 1.0);
                }`
        });
        lensingPass.uniforms.strength.value = params.lensingStrength;
        composer.addPass(lensingPass);
        
        // Gravitational Wave Pass
        const wavePass = new ShaderPass({
             uniforms: { 
                tDiffuse: { value: null }, 
                time: { value: -1.0 }, 
                origin: { value: new THREE.Vector2() }, 
                amplitude: { value: 0.0 },
                frequency: { value: 50.0 },
                decay: { value: 2.0 }
            },
             vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
             fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform float time, amplitude, frequency, decay; 
                uniform vec2 origin; 
                varying vec2 vUv;
                
                void main() {
                    float dist = distance(vUv, origin);
                    
                    // Gravitational wave strain pattern
                    float strain = sin(dist * frequency - time * 15.0) * amplitude;
                    strain *= exp(-dist * decay) * exp(-time * 2.0);
                    strain *= smoothstep(0.0, 0.1, time) * (1.0 - smoothstep(0.7, 1.0, time));
                    
                    // Plus and cross polarizations
                    vec2 dir = normalize(vUv - origin);
                    vec2 perpDir = vec2(-dir.y, dir.x);
                    
                    vec2 plusPol = dir * strain;
                    vec2 crossPol = perpDir * strain * 0.5;
                    
                    vec2 totalOffset = plusPol + crossPol;
                    
                    vec4 color = texture2D(tDiffuse, vUv + totalOffset);
                    
                    // Wave visualization
                    float waveVis = abs(strain) * 15.0;
                    color.rgb += vec3(0.1, 0.05, 0.2) * waveVis;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(wavePass);

        // God-ray / Radial Blur pass for merger flash
        const godRayPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
                exposure: { value: 1.0 },
                decay: { value: 0.95 },
                density: { value: 0.5 },
                weight: { value: 0.4 },
                samples: { value: 60 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 lightPosition;
                uniform float exposure;
                uniform float decay;
                uniform float density;
                uniform float weight;
                uniform int samples;
                varying vec2 vUv;

                void main() {
                    vec2 delta = vUv - lightPosition;
                    delta *= 1.0 / float(samples) * density;
                    float illuminationDecay = 1.0;
                    vec4 color = texture2D(tDiffuse, vUv);

                    for (int i = 0; i < samples; i++) {
                        vUv -= delta;
                        vec4 sampleColor = texture2D(tDiffuse, vUv);
                        sampleColor *= illuminationDecay * weight;
                        color += sampleColor;
                        illuminationDecay *= decay;
                    }
                    gl_FragColor = color * exposure;
                }`
        });
        godRayPass.enabled = false;
        composer.addPass(godRayPass);
        
        // Enhanced Bloom Pass
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            params.bloomIntensity, 
            0.4, 
            0.1
        );
        bloomPass.threshold = 0.1;
        bloomPass.radius = 1.0;
        composer.addPass(bloomPass);
        
        // SMAA Anti-aliasing Pass (should be one of the last passes before final color correction)
        const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);
        composer.addPass(smaaPass);

        // Color Correction Pass
        const colorCorrectionPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                exposure: { value: 1.0 },
                contrast: { value: 1.1 },
                saturation: { value: 1.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float exposure;
                uniform float contrast;
                uniform float saturation;
                varying vec2 vUv;
                
                vec3 adjustSaturation(vec3 color, float sat) {
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    return mix(vec3(gray), color, sat);
                }
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    
                    // Exposure
                    color.rgb *= exposure;
                    
                    // Contrast
                    color.rgb = (color.rgb - 0.5) * contrast + 0.5;
                    
                    // Saturation
                    color.rgb = adjustSaturation(color.rgb, saturation);
                    
                    // Vignette
                    float vignette = smoothstep(1.0, 0.4, length(vUv - 0.5));
                    color.rgb *= vignette;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(colorCorrectionPass);

        // --- GUI Configuration ---
        const gui = new GUI();
        
        const setupFolder = gui.addFolder('System Setup');
        const mass1Controller = setupFolder.add(params, 'mass1', 10, 150).name('Mass 1 (M☉)');
        const mass2Controller = setupFolder.add(params, 'mass2', 10, 150).name('Mass 2 (M☉)');
        const distanceController = setupFolder.add(params, 'distance', 50, 200).name('Initial Distance');
        setupFolder.add(params, 'start').name('🚀 Launch Simulation');
        
        const presetsFolder = gui.addFolder('Presets');
        presetsFolder.add(params, 'preset1').name('Asymmetric Merger');
        presetsFolder.add(params, 'preset2').name('Equal Mass');
        presetsFolder.add(params, 'preset3').name('Extreme Mass Ratio');
        presetsFolder.add(params, 'preset4').name('Massive Merger');
        
        const directorFolder = gui.addFolder('Director Controls');
        const timeScaleController = directorFolder.add(params, 'timeScale', 0.1, 5.0).name('Time Scale');
        const cinematicController = directorFolder.add(params, 'cinematicCamera').name('Cinematic Camera');
        directorFolder.add(params, 'focusBH1').name('Focus on Black Hole 1');
        directorFolder.add(params, 'focusBH2').name('Focus on Black Hole 2');
        directorFolder.add(params, 'focusCenter').name('Focus on Center');
        directorFolder.add(params, 'resetCamera').name('Reset Camera');

        const visualFolder = gui.addFolder('Visual Controls');
        visualFolder.add(params, 'diskEmissivity', 0, 10).name('Disk Brightness').onChange(v => {
            blackHoles.forEach(bh => bh.diskMaterial.uniforms.emissiveIntensity.value = v);
        });
        visualFolder.add(params, 'bloomIntensity', 0, 5).name('Bloom Intensity').onChange(v => bloomPass.strength = v);
        const gridController = visualFolder.add(params, 'showGrid').name('Show Spacetime Grid').onChange(v => {
            spacetimeGrid.group.visible = v;
        });
        const infoController = visualFolder.add(params, 'showInfo').name('Show Info Display').onChange(v => {
            document.getElementById('info-panel').style.opacity = v ? '1' : '0';
        });
        visualFolder.add(params, 'particleDensity', 0, 3).name('Particle Density').onChange(v => {
             particleSystems.forEach(ps => {
                if (ps.userData.type === 'accretion') {
                    ps.material.uniforms.opacity.value = v;
                }
             });
        });
        visualFolder.add(starfieldMaterial.uniforms.nebulaDensity, 'value', 0, 5).name('Nebula Density');
        visualFolder.add(starfieldMaterial.uniforms.starDensity, 'value', 0, 5).name('Star Density');
        
        const advancedFolder = gui.addFolder('Advanced Physics');
        advancedFolder.add(params, 'orbitalDecay', 0, 0.02).name('Orbital Decay Rate');
        advancedFolder.add(params, 'finalSpin', 0, 0.98, 0.01).name('Final BH Spin (a/M)');
        advancedFolder.add(params, 'cameraShake').name('Camera Shake');
        advancedFolder.add(params, 'lensingStrength', 0, 2).name('Lensing Strength').onChange(v => {
            lensingPass.uniforms.strength.value = v;
        });
        advancedFolder.add(params, 'playSound').name('Play Merger Sound');
        
        const postProcessFolder = gui.addFolder('Post Processing');
        postProcessFolder.add(colorCorrectionPass.uniforms.exposure, 'value', 0.5, 2).name('Exposure');
        postProcessFolder.add(colorCorrectionPass.uniforms.contrast, 'value', 0.5, 2).name('Contrast');
        postProcessFolder.add(colorCorrectionPass.uniforms.saturation, 'value', 0, 2).name('Saturation');
        
        const qualityFolder = gui.addFolder('Performance');
        qualityFolder.add(params, 'quality', ['low', 'medium', 'high', 'ultra']).name('Quality').onChange(updateQuality);

        // --- UI & Controls Setup ---
        const controlsContainer = document.getElementById('controls');
        const pauseIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`;
        const playIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
        
        const controlButtons = [
            { id: 'restart-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>`, action: () => initSimulation(), title: 'Restart (R)' },
            { id: 'pause-btn', icon: pauseIcon, action: togglePause, title: 'Pause/Play (Space)' },
            { id: 'cinematic-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg>`, action: toggleCinematic, title: 'Cinematic Camera (C)' },
            { id: 'grid-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`, action: toggleGrid, title: 'Toggle Grid (G)' },
            { id: 'info-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`, action: toggleInfo, title: 'Toggle Info (I)' },
        ];

        controlButtons.forEach(btnInfo => {
            const button = document.createElement('button');
            button.id = btnInfo.id;
            button.innerHTML = btnInfo.icon;
            button.title = btnInfo.title;
            button.className = "p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all";
            button.addEventListener('click', btnInfo.action);
            controlsContainer.appendChild(button);
        });

        function togglePause() {
            params.isPaused = !params.isPaused;
            document.getElementById('pause-btn').innerHTML = params.isPaused ? playIcon : pauseIcon;
        }
        function toggleCinematic() {
            params.cinematicCamera = !params.cinematicCamera;
            cinematicController.updateDisplay();
        }
        function toggleGrid() {
            params.showGrid = !params.showGrid;
            spacetimeGrid.group.visible = params.showGrid;
            gridController.updateDisplay();
        }
        function toggleInfo() {
            params.showInfo = !params.showInfo;
            document.getElementById('info-panel').style.opacity = params.showInfo ? '1' : '0';
            infoController.updateDisplay();
        }

        function initSimulation() {
            // Clear previous simulation objects
            blackHoles.forEach(bh => bh.dispose());
            if (massStream) massStream.dispose();
            particleSystems.forEach(ps => {
                scene.remove(ps);
                ps.geometry.dispose();
                ps.material.dispose();
            });
            particleSystems = [];
            jets = [];
            blackHoles = [];
            
            simulationTime = 0;
            mergerTime = -1;
            simulationActive = true;

            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'INSPIRAL';
            phaseEl.style.color = '#22d3ee'; // cyan-400
            document.getElementById('progressBar').style.width = '0%';
            
            const m1 = params.mass1, m2 = params.mass2, dist = params.distance;
            initialDistance = dist;
            const totalMass = m1 + m2;
            
            // Circular orbit velocities
            const v = Math.sqrt(G * totalMass / dist);
            const v1 = v * m2 / totalMass;
            const v2 = v * m1 / totalMass;
            
            // Initial positions (center of mass at origin)
            const r1 = dist * m2 / totalMass;
            const r2 = dist * m1 / totalMass;
            
            const bh1 = new BlackHole(m1, new THREE.Vector3(-r1, 0, 0), new THREE.Vector3(0, 0, -v1), true);
            const bh2 = new BlackHole(m2, new THREE.Vector3(r2, 0, 0), new THREE.Vector3(0, 0, v2), false);
            
            blackHoles.push(bh1, bh2);
            massStream = new MassStream();
            wavePass.uniforms.time.value = -1.0;
            godRayPass.enabled = false;
            setCameraFocus(-1);
        }
        
        function applyPreset(m1, m2, d) {
            params.mass1 = m1;
            params.mass2 = m2;
            params.distance = d;
            mass1Controller.updateDisplay();
            mass2Controller.updateDisplay();
            distanceController.updateDisplay();
            initSimulation();
        }
        
        function updateQuality(quality) {
            let pixelRatio = 1;
            let samples = 30;
            switch(quality) {
                case 'low':
                    pixelRatio = 1;
                    samples = 30;
                    break;
                case 'medium':
                    pixelRatio = Math.min(window.devicePixelRatio, 1.5);
                    samples = 60;
                    break;
                case 'high':
                case 'ultra':
                    pixelRatio = Math.min(window.devicePixelRatio, 2);
                    samples = 80;
                    break;
            }
            renderer.setPixelRatio(pixelRatio);
            composer.setPixelRatio(pixelRatio);
            godRayPass.uniforms.samples.value = samples;
        }
        
        // --- Camera and Effects Management ---
        let shakeDuration = 0, shakeIntensity = 0;
        function triggerCameraShake(duration = 0.5, intensity = 0.5) { 
            shakeDuration = duration; 
            shakeIntensity = intensity; 
        }
        
        function updateCameraShake(deltaTime) { 
            if (shakeDuration > 0) { 
                shakeDuration -= deltaTime;
                const shake = shakeIntensity * (shakeDuration / 0.5); // Fade out
                camera.position.x += (Math.random() - 0.5) * shake; 
                camera.position.y += (Math.random() - 0.5) * shake;
                camera.position.z += (Math.random() - 0.5) * shake * 0.5;
            } 
        }
        
        function triggerGravitationalWave(origin) { 
            const screenPos = origin.clone().project(camera); 
            wavePass.uniforms.origin.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2); 
            wavePass.uniforms.time.value = 0.0; 
            wavePass.uniforms.amplitude.value = 0.04; 
        }
        
        function triggerBloomFlash(strength) { 
            let flashStrength = strength; 
            const flashInterval = setInterval(() => { 
                bloomPass.strength = flashStrength; 
                flashStrength *= 0.9;
                if (flashStrength <= params.bloomIntensity) { 
                    bloomPass.strength = params.bloomIntensity; 
                    clearInterval(flashInterval); 
                } 
            }, 16); 
        }

        function triggerGodRayFlash(origin) {
            const screenPos = origin.clone().project(camera);
            godRayPass.enabled = true;
            godRayPass.uniforms.lightPosition.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2);
            godRayPass.uniforms.exposure.value = 1.0;
        }
        
        let focusIndex = -1;
        function setCameraFocus(index) {
            focusIndex = index;
            params.cinematicCamera = false;
            cinematicController.updateDisplay();
        }

        function updateCamera(time) {
            if (params.cinematicCamera) {
                const phase = (time * 0.05) % (Math.PI * 2);
                const radius = 120 + Math.sin(phase * 2) * 30;
                const height = 50 + Math.sin(phase * 3) * 20;
                
                camera.position.x = Math.cos(phase) * radius;
                camera.position.z = Math.sin(phase) * radius;
                camera.position.y = height;
                
                const lookAhead = 0.1;
                const lookX = Math.cos(phase + lookAhead) * radius * 0.3;
                const lookZ = Math.sin(phase + lookAhead) * radius * 0.3;
                controls.target.set(lookX, 0, lookZ);
            } else {
                let targetPos = new THREE.Vector3();
                if (focusIndex === -1 && blackHoles.length > 1) {
                    const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                    targetPos.addScaledVector(blackHoles[0].position, blackHoles[0].mass / totalMass);
                    targetPos.addScaledVector(blackHoles[1].position, blackHoles[1].mass / totalMass);
                } else if (focusIndex >= 0 && blackHoles[focusIndex]) {
                    targetPos.copy(blackHoles[focusIndex].position);
                } else if (blackHoles.length === 1) {
                    targetPos.copy(blackHoles[0].position);
                }
                cameraTarget.position.lerp(targetPos, 0.1);
                controls.target.lerp(cameraTarget.position, 0.1);
            }
        }
        
        // --- Centralized Particle System Update ---
        function updateAllParticleSystems(deltaTime) {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const system = particleSystems[i];
                const type = system.userData.type;

                if (type === 'accretion') {
                    const bh = system.userData.parentBH;
                    if (!bh) continue;

                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    const lifetimes = system.geometry.attributes.lifetime.array;
                    const colors = system.geometry.attributes.customColor.array;
                    
                    for (let j = 0; j < lifetimes.length; j++) {
                        lifetimes[j] -= deltaTime * 0.1;
                        
                        if (lifetimes[j] <= 0) {
                            // Respawn
                            const angle = Math.random() * Math.PI * 2;
                            const radius = bh.radius * 1.5 + Math.random() * bh.radius * 2.5;
                            
                            positions[j * 3] = Math.cos(angle) * radius;
                            positions[j * 3 + 1] = (Math.random() - 0.5) * 2;
                            positions[j * 3 + 2] = Math.sin(angle) * radius;
                            
                            lifetimes[j] = 1.0;
                        } else {
                            // Update position with gravity
                            const x = positions[j * 3];
                            const y = positions[j * 3 + 1];
                            const z = positions[j * 3 + 2];
                            const r = Math.sqrt(x * x + z * z);
                            
                            // Gravitational acceleration
                            const accel = -G * bh.mass / (r * r);
                            velocities[j * 3] += (x / r) * accel * deltaTime;
                            velocities[j * 3 + 2] += (z / r) * accel * deltaTime;
                            
                            positions[j * 3] += velocities[j * 3] * deltaTime;
                            positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                            positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        }
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.geometry.attributes.lifetime.needsUpdate = true;
                    system.material.uniforms.opacity.value = params.particleDensity;
                } else if (type === 'jet') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for (let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                } else if (type === 'burst') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for(let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        velocities[j * 3] *= 0.99;
                        velocities[j * 3 + 1] *= 0.99;
                        velocities[j * 3 + 2] *= 0.99;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.material.opacity -= deltaTime * 0.5;
                    if (system.material.opacity <= 0) {
                        scene.remove(system);
                        system.geometry.dispose();
                        system.material.dispose();
                        particleSystems.splice(i, 1);
                    }
                }
                if (system.material.uniforms && system.material.uniforms.time) {
                    system.material.uniforms.time.value += deltaTime;
                }
            }
        }

        // --- Main Animation Loop ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const effectiveDeltaTime = clock.getDelta();
            const timeScale = params.isPaused ? 0 : params.timeScale;
            const deltaTime = effectiveDeltaTime * timeScale;
            const elapsedTime = clock.getElapsedTime();
            
            // Update simulation
            updatePhysics(deltaTime);
            if (!params.cinematicCamera) controls.update();
            updateCamera(elapsedTime);
            updateCameraShake(deltaTime);
            updateAllParticleSystems(deltaTime);
            
            // Update background
            starfieldMaterial.uniforms.time.value = elapsedTime;
            
            // Update post-merger effects
            if (mergerTime > 0 && blackHoles.length === 1) {
                const bh = blackHoles[0];
                const precessionQuaternion = new THREE.Quaternion().setFromAxisAngle(bh.precessionAxis, deltaTime * bh.spinMagnitude * 0.1);
                bh.group.quaternion.premultiply(precessionQuaternion);
                
                jets.forEach(jet => {
                    if (jet.material.uniforms.opacity.value > 0) {
                        jet.material.uniforms.opacity.value *= 0.995;
                    }
                    if (jet.material.uniforms.time) {
                        jet.material.uniforms.time.value = elapsedTime;
                    }
                });

                if (bh.diskMaterial.uniforms.ringdown.value > 0.001) {
                    bh.diskMaterial.uniforms.ringdown.value *= (1.0 - 0.8 * effectiveDeltaTime);
                } else {
                    bh.diskMaterial.uniforms.ringdown.value = 0.0;
                }
                updateInfoDisplay();
            }

            // Update lensing positions
            const screenPositions = blackHoles.map(bh => {
                const pos = bh.group.position.clone();
                pos.project(camera);
                return pos;
            });
            
            for (let i = 0; i < 10; i++) {
                if (i < blackHoles.length) {
                    lensingPass.uniforms.bhPositions.value[i].set(
                        (screenPositions[i].x + 1) / 2, 
                        (screenPositions[i].y + 1) / 2
                    );
                    lensingPass.uniforms.bhMasses.value[i] = blackHoles[i].mass;
                } else {
                    lensingPass.uniforms.bhPositions.value[i].set(-10, -10);
                    lensingPass.uniforms.bhMasses.value[i] = 0;
                }
            }
            lensingPass.uniforms.bhCount.value = blackHoles.length;
            lensingPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspect.value = window.innerWidth / window.innerHeight;
            
            // Update gravitational wave effect
            if (wavePass.uniforms.time.value >= 0) {
                wavePass.uniforms.time.value += deltaTime;
                if (wavePass.uniforms.time.value > 1.0) {
                    wavePass.uniforms.time.value = -1.0;
                }
            }

            // Update God Ray effect
            if (godRayPass.enabled) {
                godRayPass.uniforms.exposure.value *= (1.0 - 1.5 * effectiveDeltaTime);
                if (godRayPass.uniforms.exposure.value < 0.01) {
                    godRayPass.enabled = false;
                }
            }

            // Render
            composer.render();
        }
        
        // Start simulation
        const loader = document.getElementById('loader');
        initSimulation();
        animate();
        loader.style.opacity = '0';
        setTimeout(() => loader.style.display = 'none', 500);


        // --- Window Resize Handler ---
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
            composer.setSize(width, height);
            
            lensingPass.uniforms.resolution.value.set(width, height);
            lensingPass.uniforms.aspect.value = width / height;
            
            smaaPass.setSize(width, height);
            
            updateQuality(params.quality);
        });
        
        // --- Keyboard Controls ---
        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    togglePause();
                    break;
                case 'c': toggleCinematic(); break;
                case 'g': toggleGrid(); break;
                case 'i': toggleInfo(); break;
                case 'r': initSimulation(); break;
            }
        });
    </script>

<canvas data-engine="three.js r178" width="2704" height="410" style="display: block; width: 1352px; height: 205px; touch-action: none;"></canvas><div class="lil-gui allow-touch-styles root autoPlace"><div class="title" role="button" aria-expanded="true" tabindex="0">Controls</div><div class="children"><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Presets</div><div class="children"><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-5">Asymmetric Merger</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-6">Equal Mass</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-7">Extreme Mass Ratio</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-8">Massive Merger</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Director Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-9">Time Scale</div><div class="widget"><div class="slider"><div class="fill" style="width: 18.367347%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-9"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-10">Cinematic Camera</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-10"></label></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-11">Focus on Black Hole 1</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-12">Focus on Black Hole 2</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-13">Focus on Center</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-14">Reset Camera</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Visual Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-15">Disk Brightness</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-15"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-16">Bloom Intensity</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-16"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-17">Show Spacetime Grid</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-17"></label></div><div class="controller boolean"><div class="name" id="lil-gui-name-18">Show Info Display</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-18"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-19">Particle Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-19"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-20">Nebula Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-20"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-21">Star Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-21"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Advanced Physics</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-22">Orbital Decay Rate</div><div class="widget"><div class="slider"><div class="fill" style="width: 25%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-22"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-23">Final BH Spin (a/M)</div><div class="widget"><div class="slider"><div class="fill" style="width: 91.836735%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-23"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-24">Camera Shake</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-24"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-25">Lensing Strength</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-25"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-26">Play Merger Sound</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-26"></label></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Post Processing</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-27">Exposure</div><div class="widget"><div class="slider"><div class="fill" style="width: 33.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-27"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-28">Contrast</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-28"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-29">Saturation</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-29"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Performance</div><div class="children"><div class="controller option"><div class="name" id="lil-gui-name-30">Quality</div><div class="widget"><select aria-labelledby="lil-gui-name-30"><option>low</option><option>medium</option><option>high</option><option>ultra</option></select><div class="display">ultra</div></div></div></div></div></div></div></body>
<!-- Loading overlay -->
<div id="loader" style="opacity: 0; display: none;">Initializing Simulation...</div>
<!-- Enhanced UI Container -->
<div id="ui-container" class="fixed inset-0 p-4 sm:p-6 lg:p-8 pointer-events-none text-gray-200 font-mono text-sm">
        <!-- Top-left Info Panel -->
        <div id="info-panel" class="absolute top-4 left-4 sm:top-6 sm:left-6 lg:top-8 lg:left-8 bg-black/60 backdrop-blur-md p-4 rounded-lg border border-white/10 shadow-lg pointer-events-auto transition-all duration-300 opacity-100">
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">66.5 Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">1335.05 s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">-1 E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">0.001 Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">105.8 s</span>
                    </div></div>

        <!-- Bottom Controls -->
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 w-full max-w-lg px-4">
            <!-- Timeline -->
            <div id="timeline-container" class="bg-black/60 backdrop-blur-md p-3 rounded-lg border border-white/10 shadow-lg mb-4 pointer-events-auto">
                <div id="phase" class="text-center text-xs font-bold tracking-widest uppercase mb-2 text-cyan-300 transition-colors duration-500" style="color: rgb(34, 211, 238);">INSPIRAL</div>
                <div id="progress" class="w-full h-2 bg-white/10 rounded-full overflow-hidden shadow-inner">
                    <div id="progressBar" class="h-full bg-gradient-to-r from-cyan-400 to-purple-500 transition-all duration-500 ease-out" style="width: 5.066561%;"></div>
                </div>
            </div>
            <!-- Control Buttons -->
            <div id="controls" class="flex justify-center items-center gap-2 bg-black/60 backdrop-blur-md p-2 rounded-lg border border-white/10 shadow-lg pointer-events-auto">
                <!-- Buttons will be populated by JS -->
            <button id="restart-btn" title="Restart (R)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg></button><button id="pause-btn" title="Pause/Play (Space)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg></button><button id="cinematic-btn" title="Cinematic Camera (C)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg></button><button id="grid-btn" title="Toggle Grid (G)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg></button><button id="info-btn" title="Toggle Info (I)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></button></div>
        </div>
    </div>
<!-- Audio for merger sound -->
<audio id="mergerSound" src="https://gwosc.org/GW150914data/GW150914_H1_shifted.wav" preload="auto"></audio>
<script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- Enhanced Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000011, 0.0003);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, // SMAA pass handles anti-aliasing
            powerPreference: "high-performance",
            alpha: false,
            stencil: false,
            depth: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Camera Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 800;
        controls.maxPolarAngle = Math.PI * 0.85;
        camera.position.set(0, 40, 90);

        // --- Ultra HD Galaxy Background ---
        const starfieldMaterial = new THREE.ShaderMaterial({
            uniforms: { 
                time: { value: 0.0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                nebulaDensity: { value: 2.0 },
                starDensity: { value: 3.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                varying vec3 vPosition;
                void main() { 
                    vUv = uv; 
                    vPosition = position;
                    gl_Position = vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                uniform float nebulaDensity;
                uniform float starDensity;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                // High quality noise functions
                float hash(vec3 p) { 
                    p = fract(p * vec3(443.8975, 397.2973, 491.1871));
                    p += dot(p, p.yxz + 19.19);
                    return fract((p.x + p.y) * p.z);
                }
                
                float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    return mix(mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
                                   mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                               mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                   mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                }
                
                float fbm(vec3 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    float frequency = 1.0;
                    for(int i = 0; i < 6; i++) {
                        value += amplitude * noise(p * frequency);
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }
                    return value;
                }
                
                void main() {
                    vec3 color = vec3(0.0);
                    vec2 uv = vUv;
                    vec3 pos = vPosition;
                    
                    // Ultra HD star field
                    for(int i = 0; i < 5; i++) {
                        float scale = 100.0 + float(i) * 200.0;
                        vec2 starUv = uv * scale;
                        float star = hash(vec3(floor(starUv), float(i)));
                        
                        if(star > 0.98 - float(i) * 0.01) {
                            vec2 starPos = fract(starUv) - 0.5;
                            float dist = length(starPos);
                            float brightness = 1.0 - smoothstep(0.0, 0.02, dist);
                            brightness *= (0.5 + 0.5 * sin(time * (1.0 + star * 5.0)));
                            
                            // Star color variation
                            vec3 starColor = vec3(1.0);
                            float colorType = hash(vec3(floor(starUv), float(i) + 100.0));
                            if(colorType < 0.3) starColor = vec3(1.0, 0.8, 0.6); // Yellow
                            else if(colorType < 0.6) starColor = vec3(0.8, 0.8, 1.0); // Blue-white
                            else if(colorType < 0.8) starColor = vec3(1.0, 0.6, 0.4); // Red
                            
                            color += starColor * brightness * starDensity / float(i + 1);
                        }
                    }
                    
                    // High detail nebula
                    vec3 nebulaPos = pos * 0.001;
                    float nebula1 = fbm(nebulaPos + vec3(time * 0.01, 0.0, 0.0));
                    float nebula2 = fbm(nebulaPos * 2.0 - vec3(0.0, time * 0.02, 0.0));
                    float nebula3 = fbm(nebulaPos * 4.0 + vec3(0.0, 0.0, time * 0.03));
                    
                    float nebulaMask = nebula1 * 0.5 + nebula2 * 0.3 + nebula3 * 0.2;
                    nebulaMask = pow(nebulaMask, 2.0) * nebulaDensity;
                    
                    // Nebula color gradients
                    vec3 nebulaColor1 = vec3(0.1, 0.0, 0.4) * nebula1;
                    vec3 nebulaColor2 = vec3(0.0, 0.1, 0.3) * nebula2;
                    vec3 nebulaColor3 = vec3(0.2, 0.0, 0.2) * nebula3;
                    vec3 nebulaColor = (nebulaColor1 + nebulaColor2 + nebulaColor3) * 0.5;
                    
                    color += nebulaColor * nebulaMask;
                    
                    // Milky way band
                    float band = 1.0 - abs(pos.y * 0.005);
                    band = pow(band, 4.0) * 0.2;
                    vec3 bandColor = mix(vec3(0.05, 0.03, 0.08), vec3(0.1, 0.08, 0.15), noise(pos * 0.01));
                    color += bandColor * band;
                    
                    // Distant galaxies
                    float galaxyNoise = hash(vec3(uv * 50.0, 0.0));
                    if(galaxyNoise > 0.999) {
                        float galaxyBrightness = pow(galaxyNoise, 10.0) * 0.5;
                        color += vec3(0.8, 0.7, 0.9) * galaxyBrightness;
                    }
                    
                    // Final color grading
                    color = pow(color, vec3(0.85));
                    color = mix(color, vec3(dot(color, vec3(0.299, 0.587, 0.114))), -0.2);
                    
                    gl_FragColor = vec4(color, 1.0);
                }`,
            side: THREE.BackSide
        });
        const starfieldSphere = new THREE.Mesh(new THREE.IcosahedronGeometry(2000, 4), starfieldMaterial);
        scene.add(starfieldSphere);

        // --- Advanced Ambient Lighting ---
        const ambientLight = new THREE.AmbientLight(0x0a0a0a, 0.5);
        scene.add(ambientLight);

        // --- High Quality Spacetime Grid ---
        class SpacetimeGrid {
            constructor() {
                this.gridSize = 300;
                this.gridDivisions = 60;
                this.group = new THREE.Group();
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        bhPositions: { value: [new THREE.Vector3(), new THREE.Vector3()] },
                        bhMasses: { value: [0, 0] },
                        time: { value: 0 },
                        opacity: { value: 0.3 },
                        waveAmplitude: { value: 0.0 },
                        waveOrigin: { value: new THREE.Vector3() },
                        waveTime: { value: 0.0 }
                    },
                    vertexShader: `
                        uniform vec3 bhPositions[2];
                        uniform float bhMasses[2];
                        uniform float time;
                        uniform float waveAmplitude;
                        uniform vec3 waveOrigin;
                        uniform float waveTime;
                        
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            vec3 pos = position;
                            float totalDistortion = 0.0;
                            
                            // Black hole warping
                            for(int i = 0; i < 2; i++) {
                                if(bhMasses[i] > 0.0) {
                                    vec3 delta = pos - bhPositions[i];
                                    delta.y = 0.0;
                                    float dist = length(delta);
                                    float warp = bhMasses[i] / (dist + 5.0);
                                    float falloff = exp(-dist * 0.05);
                                    pos.y -= warp * 3.0 * falloff;
                                    totalDistortion += warp;
                                }
                            }
                            
                            // Gravitational wave ripples
                            float waveDist = length(pos.xz - waveOrigin.xz);
                            float wave = sin(waveDist * 0.3 - waveTime * 15.0) * waveAmplitude;
                            wave *= exp(-waveDist * 0.01) * exp(-waveTime * 2.0);
                            pos.y += wave * 5.0;
                            vWave = wave;
                            
                            // Orbital motion distortion
                            float orbitalEffect = sin(time * 2.0 + length(pos.xz) * 0.05) * 0.2;
                            pos.y += orbitalEffect * totalDistortion;
                            
                            vDistortion = totalDistortion;
                            vColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.0, 0.5), totalDistortion * 0.2);
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            float intensity = 0.3 + vDistortion * 0.7 + abs(vWave) * 2.0;
                            vec3 color = vColor;
                            
                            // Pulsing effect
                            float pulse = sin(time * 3.0 + vDistortion * 10.0) * 0.1 + 0.9;
                            intensity *= pulse;
                            
                            // Wave color enhancement
                            if(abs(vWave) > 0.01) {
                                color = mix(color, vec3(0.5, 0.0, 1.0), abs(vWave) * 5.0);
                            }
                            
                            gl_FragColor = vec4(color, opacity * intensity);
                        }`,
                    transparent: true,
                    wireframe: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const geometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize, this.gridDivisions, this.gridDivisions);
                geometry.rotateX(-Math.PI / 2);
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.position.y = -10;
                this.group.add(this.mesh);
                
                scene.add(this.group);
                this.group.visible = false;
            }
            
            update(blackHoles, deltaTime) {
                if (blackHoles.length > 0) {
                    this.material.uniforms.bhPositions.value[0].copy(blackHoles[0].position);
                    this.material.uniforms.bhMasses.value[0] = blackHoles[0].mass;
                }
                if (blackHoles.length > 1) {
                    this.material.uniforms.bhPositions.value[1].copy(blackHoles[1].position);
                    this.material.uniforms.bhMasses.value[1] = blackHoles[1].mass;
                } else {
                    this.material.uniforms.bhMasses.value[1] = 0;
                }
                this.material.uniforms.time.value += deltaTime;
                this.material.uniforms.waveTime.value += deltaTime;
            }
            
            triggerWave(origin, amplitude) {
                this.material.uniforms.waveOrigin.value.copy(origin);
                this.material.uniforms.waveAmplitude.value = amplitude;
                this.material.uniforms.waveTime.value = 0;
            }
        }

        // --- Physics & Simulation State ---
        const G = 0.1;
        let blackHoles = [];
        let massStream = null;
        let jets = [];
        let simulationActive = true;
        let spacetimeGrid = new SpacetimeGrid();
        let particleSystems = [];
        let initialDistance = 70;
        let simulationTime = 0;
        let mergerTime = -1;
        
        const params = {
            mass1: 40, 
            mass2: 25, 
            distance: 70, 
            timeScale: 1.0, 
            isPaused: false,
            orbitalDecay: 0.005,
            diskEmissivity: 3.0, 
            bloomIntensity: 1.5, 
            finalSpin: 0.9, 
            cameraShake: true, 
            cinematicCamera: false,
            showGrid: false, 
            showInfo: true, 
            quality: 'ultra',
            particleDensity: 1.5, 
            lensingStrength: 1.0,
            playSound: true, // New parameter for sound
            focusBH1: () => setCameraFocus(0),
            focusBH2: () => setCameraFocus(1),
            focusCenter: () => setCameraFocus(-1),
            resetCamera: () => {
                setCameraFocus(-1);
                controls.reset();
                camera.position.set(0, 40, 90);
            },
            start: () => initSimulation(),
            preset1: () => applyPreset(40, 25, 70),
            preset2: () => applyPreset(30, 30, 80),
            preset3: () => applyPreset(50, 10, 100),
            preset4: () => applyPreset(140, 100, 120) // New 2025 massive merger preset
        };
        
        let cameraTarget = new THREE.Object3D();
        scene.add(cameraTarget);

        // --- Ultra HD BlackHole Class (with enhanced Doppler shift) ---
        class BlackHole {
            constructor(mass, position, velocity, isPrimary = false) {
                this.mass = mass; 
                this.position = position; 
                this.velocity = velocity;
                this.isPrimary = isPrimary;
                this.isMerged = false; 
                this.radius = Math.pow(mass, 1/3);
                this.spin = new THREE.Vector3(0, 1, 0).multiplyScalar(Math.random() * 0.5 + 0.5);
                this.spinMagnitude = 0;
                this.precessionAxis = new THREE.Vector3(0, 1, 0);
                
                this.group = new THREE.Group();
                
                // Schwarzschild radius event horizon
                const eventHorizonGeometry = new THREE.SphereGeometry(this.radius, 128, 64);
                this.eventHorizon = new THREE.Mesh(eventHorizonGeometry, new THREE.MeshBasicMaterial({ 
                    color: 0x000000
                }));
                this.eventHorizon.castShadow = true;
                this.eventHorizon.receiveShadow = true;
                this.group.add(this.eventHorizon);
                
                // Multi-layer glow effect
                for(let i = 0; i < 3; i++) {
                    const glowScale = 1.1 + i * 0.05;
                    const glowGeometry = new THREE.SphereGeometry(this.radius * glowScale, 64, 32);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: isPrimary ? 0xff6600 : 0x0066ff,
                        transparent: true,
                        opacity: 0.1 / (i + 1),
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.group.add(glow);
                }
                
                // Dynamic light sources
                this.light = new THREE.PointLight(isPrimary ? 0xffaa66 : 0x6699ff, 2, 300, 2);
                this.light.castShadow = true;
                this.light.shadow.mapSize.width = 1024;
                this.light.shadow.mapSize.height = 1024;
                this.group.add(this.light);
                
                // Rim lighting
                const rimLight = new THREE.PointLight(isPrimary ? 0xff6600 : 0x0066ff, 1, 200, 2);
                rimLight.position.set(0, this.radius * 2, 0);
                this.group.add(rimLight);

                // Ultra HD accretion disk with enhanced Doppler
                this.createAccretionDisk();
                
                scene.add(this.group);
                
                // HD Particle systems
                this.createParticleSystem();
                this.createPhotonSphere();
            }
            
            createAccretionDisk() {
                const diskInner = this.radius * 1.5; 
                const diskOuter = this.radius * 4;
                
                this.diskMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        innerRadius: { value: diskInner },
                        outerRadius: { value: diskOuter },
                        emissiveIntensity: { value: params.diskEmissivity },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xff8800) : new THREE.Color(0x0088ff) },
                        rotationSpeed: { value: 1.0 },
                        temperature: { value: 1.0 },
                        ringdown: { value: 0.0 },
                        tidalForce: { value: new THREE.Vector3() },
                        cameraPos: { value: new THREE.Vector3() }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float ringdown;
                        uniform vec3 tidalForce;
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;

                        void main() {
                            vUv = uv;
                            vPos = position;
                            vNormal = normal;
                            vec3 pos = position;
                            
                            // Tidal Disruption Effect
                            float tidalMagnitude = length(tidalForce);
                            if (tidalMagnitude > 0.01) {
                                vec3 dirToForce = normalize(tidalForce);
                                float alignment = dot(normalize(pos.xz), normalize(dirToForce.xz));
                                float stretch = smoothstep(0.5, 1.0, alignment) * tidalMagnitude * 5.0;
                                pos += dirToForce * stretch;
                            }

                            // Ringdown oscillation effect
                            if (ringdown > 0.0) {
                                float r = length(pos.xz);
                                float angle = atan(pos.z, pos.x);
                                float wobble = sin(r * 0.5 - time * 10.0) * sin(angle * 4.0); // Quadrupole oscillation
                                pos.y += wobble * ringdown * r * 0.1; // Amplitude proportional to radius
                            }
                            
                            vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float time;
                        uniform float innerRadius;
                        uniform float outerRadius;
                        uniform float emissiveIntensity;
                        uniform vec3 primaryColor;
                        uniform float rotationSpeed;
                        uniform float temperature;
                        uniform vec3 cameraPos;
                        
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vWorldPosition;
                        
                        // High quality noise
                        float noise(vec2 p) {
                            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                        }
                        
                        float turbulence(vec2 p) {
                            float value = 0.0;
                            float scale = 1.0;
                            for(int i = 0; i < 5; i++) {
                                value += noise(p * scale) / scale;
                                scale *= 2.0;
                            }
                            return value;
                        }
                        
                        vec3 blackbody(float temp) {
                            vec3 color;
                            float t = temp * 4000.0;
                            
                            if(t < 6600.0) {
                                color.r = 1.0;
                                color.g = 0.39 * log(t / 100.0) - 0.63;
                                color.b = 0.54 * log(t / 100.0 - 10.0) - 1.19;
                            } else {
                                color.r = 1.29 * pow(t / 100.0 - 60.0, -0.13);
                                color.g = 1.29 * pow(t / 100.0 - 60.0, -0.07);
                                color.b = 1.0;
                            }
                            
                            return clamp(color, 0.0, 1.0);
                        }
                        
                        void main() {
                            float dist = length(vPos);
                            float angle = atan(vPos.z, vPos.x);
                            
                            // Complex spiral arms
                            float spiral1 = sin(angle * 2.0 - time * rotationSpeed + dist * 0.3);
                            float spiral2 = sin(angle * 3.0 + time * rotationSpeed * 0.7 - dist * 0.2);
                            float spiralPattern = (spiral1 * 0.7 + spiral2 * 0.3) * 0.5 + 0.5;
                            
                            // Turbulence
                            float turb = turbulence(vec2(angle * 5.0, dist * 0.1) + time * 0.1);
                            spiralPattern = mix(spiralPattern, turb, 0.3);
                            
                            // Radial profile
                            float innerEdge = smoothstep(innerRadius - 1.0, innerRadius + 1.0, dist);
                            float outerEdge = 1.0 - smoothstep(outerRadius - 5.0, outerRadius, dist);
                            float radialFade = innerEdge * outerEdge;
                            
                            // Temperature gradient
                            float temp = temperature * (1.0 - (dist - innerRadius) / (outerRadius - innerRadius));
                            temp = pow(temp, 2.0);
                            
                            // Relativistic Doppler Beaming
                            vec3 tangent = normalize(vec3(-vPos.z, 0.0, vPos.x));
                            float speed = 0.3; // Relativistic speed factor
                            vec3 velocity = tangent * speed;
                            vec3 viewDir = normalize(cameraPos - vWorldPosition);
                            float dopplerFactor = dot(velocity, viewDir);
                            float brightnessBoost = pow(1.0 + dopplerFactor, 4.0);
                            temp *= (1.0 + dopplerFactor * 0.5); // Temperature shift
                            
                            // Color from temperature
                            vec3 color = blackbody(temp) * primaryColor;
                            
                            // Hot spots and flares
                            float hotSpot = pow(noise(vec2(angle * 10.0 + time, dist * 0.5)), 3.0);
                            color += color * hotSpot * 2.0;
                            
                            // Rim brightening
                            float innerRim = 1.0 - smoothstep(innerRadius, innerRadius + 2.0, dist);
                            color += primaryColor * pow(innerRim, 2.0) * 5.0;
                            
                            // Final composition
                            float intensity = radialFade * (0.6 + spiralPattern * 0.4) * emissiveIntensity * brightnessBoost;
                            color *= intensity;
                            
                            // Add glow
                            color += primaryColor * 0.1 * intensity;
                            
                            gl_FragColor = vec4(color, radialFade * 0.9);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const diskSegments = params.quality === 'ultra' ? 256 : 128;
                const diskGeometry = new THREE.RingGeometry(diskInner, diskOuter, diskSegments, 16);
                diskGeometry.rotateX(-Math.PI / 2);
                
                this.accretionDisk = new THREE.Mesh(diskGeometry, this.diskMaterial);
                this.group.add(this.accretionDisk);
            }
            
            createParticleSystem() {
                const particleCount = params.quality === 'ultra' ? 2000 : 1000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                const lifetimes = new Float32Array(particleCount);
                const sizes = new Float32Array(particleCount);
                const customColors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = this.radius * 1.5 + Math.random() * this.radius * 2.5;
                    const height = (Math.random() - 0.5) * 4;
                    
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = height * Math.exp(-radius / (this.radius * 3));
                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    const speed = Math.sqrt(G * this.mass / radius) * (0.8 + Math.random() * 0.4);
                    velocities[i * 3] = -Math.sin(angle) * speed;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                    velocities[i * 3 + 2] = Math.cos(angle) * speed;
                    
                    lifetimes[i] = Math.random();
                    sizes[i] = Math.random() * 2 + 0.5;
                    
                    const temp = 1.0 - (radius - this.radius) / (this.radius * 3);
                    customColors[i * 3] = temp;
                    customColors[i * 3 + 1] = temp * 0.5;
                    customColors[i * 3 + 2] = temp * 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xffaa66) : new THREE.Color(0x6699ff) },
                        opacity: { value: 1.0 }
                    },
                    vertexShader: `
                        attribute float lifetime;
                        attribute float size;
                        attribute vec3 customColor;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vLifetime = lifetime;
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z) * vLifetime;
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform vec3 primaryColor;
                        uniform float opacity;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * vLifetime * 0.8 * opacity;
                            vec3 finalColor = mix(primaryColor, vec3(1.0), vColor.r);
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.particles.userData.type = 'accretion';
                this.particles.userData.parentBH = this;
                this.group.add(this.particles);
                particleSystems.push(this.particles);
            }
            
            createPhotonSphere() {
                // Photon sphere at 1.5x Schwarzschild radius
                const photonRadius = this.radius * 1.5;
                const photonGeometry = new THREE.TorusGeometry(photonRadius, 0.1, 8, 64);
                const photonMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                this.photonSphere = new THREE.Mesh(photonGeometry, photonMaterial);
                this.photonSphere.rotation.x = Math.PI / 2;
                this.group.add(this.photonSphere);
            }
            
            update(deltaTime) {
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.group.position.copy(this.position);
                this.light.intensity = this.mass * 0.05 * params.diskEmissivity;
                
                // Update disk
                this.diskMaterial.uniforms.time.value += deltaTime;
                this.diskMaterial.uniforms.cameraPos.value.copy(camera.position);
                this.accretionDisk.rotation.y += deltaTime * 0.3;
                
                // Photon sphere rotation
                if(this.photonSphere) {
                    this.photonSphere.rotation.z += deltaTime * 2;
                }
                
                if (this.isMerged) {
                    this.diskMaterial.uniforms.emissiveIntensity.value = THREE.MathUtils.lerp(
                        this.diskMaterial.uniforms.emissiveIntensity.value, 
                        params.diskEmissivity, 
                        deltaTime * 0.5
                    );
                }
            }
            
            dispose() {
                // Remove associated particle systems from the global array
                particleSystems = particleSystems.filter(p => p.userData.parentBH !== this);

                // Dispose of all geometries and materials to free up GPU memory
                this.group.traverse(child => {
                    if (child.isMesh || child.isPoints) {
                        child.geometry.dispose();
                        // If material is an array, dispose each one
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                scene.remove(this.group);
            }
        }
        
        // --- Ultra HD MassStream Class ---
        class MassStream {
            constructor() {
                this.particleCount = 1000;
                this.geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particleCount * 3);
                const customColors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);
                
                for (let i = 0; i < this.particleCount; i++) {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                    
                    const t = i / this.particleCount;
                    customColors[i * 3] = 1.0;
                    customColors[i * 3 + 1] = 0.5 + t * 0.5;
                    customColors[i * 3 + 2] = t;
                    
                    sizes[i] = Math.random() * 2 + 0.5;
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 0.8 }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 customColor;
                        varying vec3 vColor;
                        
                        void main() {
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (200.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * opacity;
                            vec3 finalColor = vColor * (1.0 + 0.5 * sin(time * 10.0));
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
            }
            
            update(p1, p2, v1, distance, deltaTime) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.customColor.array;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const t = i / this.particleCount;
                    
                    // Bezier curve for stream path
                    const midPoint = new THREE.Vector3().lerpVectors(p1, p2, 0.5);
                    const offset = new THREE.Vector3().crossVectors(
                        new THREE.Vector3().subVectors(p2, p1).normalize(),
                        new THREE.Vector3(0, 1, 0)
                    ).multiplyScalar(distance * 0.1 * Math.sin(t * Math.PI));
                    midPoint.add(offset);
                    
                    // Quadratic bezier interpolation
                    const t2 = 1 - t;
                    const point = new THREE.Vector3()
                        .addScaledVector(p1, t2 * t2)
                        .addScaledVector(midPoint, 2 * t2 * t)
                        .addScaledVector(p2, t * t);
                    
                    // Add turbulence
                    const turbulence = new THREE.Vector3(
                        Math.sin(t * 10 + this.material.uniforms.time.value * 5) * 2,
                        Math.cos(t * 8 + this.material.uniforms.time.value * 3) * 2,
                        Math.sin(t * 12 + this.material.uniforms.time.value * 4) * 2
                    );
                    point.add(turbulence);
                    
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                    
                    // Dynamic coloring based on distance
                    const heat = 1.0 - distance / 100;
                    colors[i * 3] = heat;
                    colors[i * 3 + 1] = heat * 0.5;
                    colors[i * 3 + 2] = (1 - heat) * 0.5;
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.customColor.needsUpdate = true;
                
                const opacity = 1.0 - THREE.MathUtils.smoothstep(distance, 40, 100);
                this.material.uniforms.opacity.value = opacity * 0.8;
                this.material.uniforms.time.value += deltaTime;
            }
            
            hide() { 
                this.material.uniforms.opacity.value = 0; 
            }
            
            dispose() {
                this.geometry.dispose();
                this.material.dispose();
                scene.remove(this.mesh);
            }
        }

        // --- Physics & Merger Logic ---
        function updatePhysics(deltaTime) {
            if (mergerTime < 0 && blackHoles.length > 1) {
                // Pre-merger physics
                simulationTime += deltaTime;
                
                const bh1 = blackHoles[0], bh2 = blackHoles[1];
                const distanceVec = new THREE.Vector3().subVectors(bh2.position, bh1.position);
                const distance = distanceVec.length();
                
                updateInfoDisplay(distance);
                
                const progress = 1.0 - (distance / initialDistance);
                document.getElementById('progressBar').style.width = `${progress * 100}%`;
                
                const phaseEl = document.getElementById('phase');
                if (distance < 30) {
                    phaseEl.textContent = 'MERGER PHASE';
                    phaseEl.style.color = '#f472b6'; // pink-400
                } else if (distance < 50) {
                    phaseEl.textContent = 'FINAL INSPIRAL';
                    phaseEl.style.color = '#f59e0b'; // amber-500
                }
                
                if (distance < bh1.radius + bh2.radius) { 
                    mergeBlackHoles(); 
                    return; 
                }
                
                // Newtonian gravity
                const forceMag = G * (bh1.mass * bh2.mass) / (distance * distance);
                const forceVec = distanceVec.normalize().multiplyScalar(forceMag);
                
                bh1.velocity.add(forceVec.clone().divideScalar(bh1.mass).multiplyScalar(deltaTime));
                bh2.velocity.add(forceVec.clone().multiplyScalar(-1).divideScalar(bh2.mass).multiplyScalar(deltaTime));
                
                // GW energy loss (orbital decay)
                const totalMass = bh1.mass + bh2.mass;
                const v = Math.sqrt(G * totalMass / distance);
                const mu = (bh1.mass * bh2.mass) / totalMass;
                const gwLuminosity = (32/5) * Math.pow(G, 4) * Math.pow(mu, 2) * Math.pow(totalMass, 3) / Math.pow(distance, 5);
                const energyLoss = gwLuminosity * deltaTime * 0.000005;
                const decayRate = energyLoss / (mu * v * v) + params.orbitalDecay * deltaTime;
                
                const decayVec = distanceVec.clone().normalize().multiplyScalar(-decayRate);
                bh1.position.add(decayVec.clone().multiplyScalar(bh2.mass / totalMass));
                bh2.position.add(decayVec.clone().multiplyScalar(-bh1.mass / totalMass));
                
                // Update tidal forces for disk deformation
                const tidalForceOn1 = forceVec.clone().multiplyScalar(1 / (distance * distance * 1000));
                bh1.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1);
                bh2.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1.negate());

                massStream.update(bh1.position, bh2.position, bh1.velocity, distance, deltaTime);
            }
            
            blackHoles.forEach(bh => bh.update(deltaTime));
            spacetimeGrid.update(blackHoles, deltaTime);
        }
        
        function updateInfoDisplay(distance) {
            if (!params.showInfo) return;
            const infoPanel = document.getElementById('info-panel');
            if (!infoPanel) return;

            if (blackHoles.length > 1) {
                const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(distance, 3) / (G * totalMass));
                const kineticEnergy = 0.5 * blackHoles[0].mass * blackHoles[0].velocity.lengthSq() + 
                                      0.5 * blackHoles[1].mass * blackHoles[1].velocity.lengthSq();
                const potentialEnergy = -G * blackHoles[0].mass * blackHoles[1].mass / distance;
                const totalEnergy = kineticEnergy + potentialEnergy;
                const gwFrequency = 2 / orbitalPeriod;
                
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">${distance.toFixed(1)} Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">${orbitalPeriod.toFixed(2)} s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">${totalEnergy.toFixed(0)} E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">${gwFrequency.toFixed(3)} Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">${simulationTime.toFixed(1)} s</span>
                    </div>`;
            } else if (blackHoles.length === 1) {
                const bh = blackHoles[0];
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">Remnant Black Hole</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Status:</span> <span class="text-green-400 font-bold text-right">Ringdown</span>
                        <span class="text-gray-400">Mass:</span> <span class="text-cyan-300 font-bold text-right">${bh.mass.toFixed(1)} M☉</span>
                        <span class="text-gray-400">Spin:</span> <span class="text-cyan-300 font-bold text-right">${bh.spinMagnitude.toFixed(2)} a/M</span>
                        <span class="text-gray-400">Kick Vel:</span> <span class="text-cyan-300 font-bold text-right">${bh.velocity.length().toFixed(1)} km/s</span>
                    </div>`;
            }
        }
        
        function mergeBlackHoles() {
            simulationActive = false; 
            massStream.hide();
            mergerTime = simulationTime;
            
            const bh1 = blackHoles[0], bh2 = blackHoles[1];
            const newMass = (bh1.mass + bh2.mass) * 0.95; // 5% radiated as GWs
            const newPosition = new THREE.Vector3().addVectors(
                bh1.position.clone().multiplyScalar(bh1.mass), 
                bh2.position.clone().multiplyScalar(bh2.mass)
            ).divideScalar(bh1.mass + bh2.mass);
            
            // GW recoil kick
            const kickVelocity = new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5
            );
            
            triggerGravitationalWave(newPosition); 
            triggerBloomFlash(30.0);
            triggerGodRayFlash(newPosition);
            if (params.cameraShake) triggerCameraShake(1.0, newMass / 50);
            
            createMergerFlash(newPosition);
            spacetimeGrid.triggerWave(newPosition, 0.5);
            
            // Play merger sound if enabled
            if (params.playSound) {
                document.getElementById('mergerSound').play();
            }
            
            bh1.dispose();
            bh2.dispose();
            
            const mergedBH = new BlackHole(newMass, newPosition, kickVelocity, true);
            mergedBH.isMerged = true;
            mergedBH.spinMagnitude = params.finalSpin;
            mergedBH.precessionAxis = new THREE.Vector3(Math.random() - 0.5, 1, Math.random() - 0.5).normalize();
            mergedBH.diskMaterial.uniforms.emissiveIntensity.value = 10.0;
            mergedBH.diskMaterial.uniforms.temperature.value = 2.0;
            mergedBH.diskMaterial.uniforms.ringdown.value = 1.0; // Start ringdown effect
            blackHoles = [mergedBH];
            
            createJets(mergedBH);
            
            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'RINGDOWN PHASE';
            phaseEl.style.color = '#4ade80'; // green-400
            document.getElementById('progressBar').style.width = '100%';
        }
        
        function createMergerFlash(position) {
            // Particle burst
            createParticleBurst(position);
        }
        
        function createParticleBurst(position) {
            const burstCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(burstCount * 3);
            const velocities = new Float32Array(burstCount * 3);
            const customColors = new Float32Array(burstCount * 3);
            
            for(let i = 0; i < burstCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const speed = 20 + Math.random() * 30;
                
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                velocities[i * 3] = Math.sin(phi) * Math.cos(theta) * speed;
                velocities[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * speed;
                velocities[i * 3 + 2] = Math.cos(phi) * speed;
                
                const color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.6, 1.0, 0.5);
                customColors[i * 3] = color.r;
                customColors[i * 3 + 1] = color.g;
                customColors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            const burst = new THREE.Points(geometry, material);
            burst.userData.type = 'burst';
            scene.add(burst);
            particleSystems.push(burst);
        }

        // --- Ultra HD Jet Creation ---
        function createJets(parentBH) {
            const jetLength = 800;
            const jetRadius = parentBH.radius * 0.15;
            
            // Jet shader material
            const jetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 1.0 },
                    jetLength: { value: jetLength },
                    primaryColor: { value: new THREE.Color(0x4444ff) },
                    secondaryColor: { value: new THREE.Color(0xff44ff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vY = position.y;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }`,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    uniform float jetLength;
                    uniform vec3 primaryColor;
                    uniform vec3 secondaryColor;
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453);
                    }
                    
                    void main() {
                        float height = abs(vY) / jetLength;
                        
                        // Jet structure
                        float radialFade = 1.0 - smoothstep(0.0, 1.0, vUv.x);
                        float heightFade = 1.0 - smoothstep(0.3, 1.0, height);
                        
                        // Pulsing waves
                        float pulse1 = sin(vY * 0.05 - time * 5.0) * 0.5 + 0.5;
                        float pulse2 = sin(vY * 0.08 + time * 3.0) * 0.5 + 0.5;
                        float combinedPulse = pulse1 * 0.7 + pulse2 * 0.3;
                        
                        // Turbulence
                        float turb = noise(vPosition * 0.1 + time);
                        
                        // Color mixing
                        vec3 color = mix(primaryColor, secondaryColor, combinedPulse + turb * 0.2);
                        color = mix(color, vec3(1.0), heightFade * 0.3);
                        
                        // Shock fronts
                        float shock = step(0.98, sin(vY * 0.02 - time * 2.0));
                        color += vec3(0.5, 0.3, 0.8) * shock;

                        // Brighter Core
                        float coreBrightness = pow(1.0 - vUv.x, 10.0);
                        color += vec3(1.0, 1.0, 1.5) * coreBrightness * 2.0;
                        
                        float alpha = opacity * radialFade * heightFade * (0.5 + combinedPulse * 0.5);
                        
                        gl_FragColor = vec4(color, alpha);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            // Create tapered jet geometry
            const jetGeometry = new THREE.CylinderGeometry(jetRadius, jetRadius * 0.1, jetLength, 32, 32, true);
            
            // Add twist to geometry
            const positions = jetGeometry.attributes.position.array;
            for(let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                const angle = y * 0.01;
                const x = positions[i];
                const z = positions[i + 2];
                positions[i] = x * Math.cos(angle) - z * Math.sin(angle);
                positions[i + 2] = x * Math.sin(angle) + z * Math.cos(angle);
            }
            jetGeometry.attributes.position.needsUpdate = true;
            
            const jetTop = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetTop.position.y = jetLength / 2;
            
            const jetBottom = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetBottom.position.y = -jetLength / 2;
            jetBottom.rotation.x = Math.PI;
            
            parentBH.group.add(jetTop, jetBottom);
            jets = [jetTop, jetBottom];
            
            // Jet particles
            createJetParticles(parentBH, jetLength);
        }
        
        function createJetParticles(parentBH, jetLength) {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const isTop = i < particleCount / 2;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * parentBH.radius * 0.15;
                const height = Math.random() * jetLength;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = isTop ? height : -height;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                const speed = 3 + Math.random() * 2;
                velocities[i * 3] = (Math.random() - 0.5) * 0.2;
                velocities[i * 3 + 1] = isTop ? speed : -speed;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                
                lifetimes[i] = Math.random();
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    jetLength: { value: jetLength }
                },
                vertexShader: `
                    attribute float lifetime;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vLifetime = lifetime;
                        vHeight = abs(position.y) / ${jetLength.toFixed(1)};
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (1.0 + vHeight * 3.0) * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }`,
                fragmentShader: `
                    uniform float time;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        if(dist > 0.5) discard;
                        
                        float opacity = smoothstep(0.5, 0.0, dist) * vLifetime * (1.0 - vHeight * 0.5);
                        vec3 color = mix(vec3(0.4, 0.4, 1.0), vec3(1.0, 0.4, 1.0), vHeight);
                        color += vec3(0.2) * (1.0 + sin(time * 10.0 + vHeight * 20.0));
                        
                        gl_FragColor = vec4(color, opacity);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const jetParticles = new THREE.Points(geometry, material);
            jetParticles.userData.type = 'jet';
            jetParticles.userData.parentBH = parentBH;
            parentBH.group.add(jetParticles);
            particleSystems.push(jetParticles);
        }

        // --- Post-Processing Pipeline ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // Gravitational Lensing Pass
        const lensingPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null }, 
                resolution: { value: new THREE.Vector2() }, 
                aspect: { value: 1.0 },
                bhPositions: { value: Array(10).fill(0).map(() => new THREE.Vector2()) },
                bhMasses: { value: new Float32Array(10) }, 
                bhCount: { value: 0 },
                strength: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform vec2 resolution; 
                uniform float aspect;
                uniform vec2 bhPositions[10]; 
                uniform float bhMasses[10]; 
                uniform int bhCount; 
                uniform float strength;
                varying vec2 vUv;
                
                vec2 computeLensing(vec2 uv) {
                    vec2 totalOffset = vec2(0.0);
                    
                    for (int i = 0; i < 10; i++) {
                        if (i >= bhCount) break;
                        
                        vec2 pos = uv - bhPositions[i]; 
                        pos.x *= aspect;
                        float dist = length(pos);
                        
                        // Einstein ring radius approximation
                        float einsteinRadius = sqrt(bhMasses[i] * 0.0005 * strength);
                        float deflection = einsteinRadius * einsteinRadius / (dist + 0.0001);
                        
                        totalOffset += normalize(pos) * deflection;
                    }
                    
                    totalOffset.x /= aspect;
                    return totalOffset;
                }
                
                void main() {
                    vec2 offset = computeLensing(vUv);
                    
                    // Chromatic aberration for strong lensing
                    float aberration = length(offset) * 3.0;
                    
                    vec3 color;
                    color.r = texture2D(tDiffuse, vUv - offset * (1.0 + aberration * 0.1)).r;
                    color.g = texture2D(tDiffuse, vUv - offset).g;
                    color.b = texture2D(tDiffuse, vUv - offset * (1.0 - aberration * 0.1)).b;
                    
                    // Edge darkening for extreme lensing
                    float edgeDark = 1.0 - smoothstep(0.0, 0.05, length(offset));
                    color *= edgeDark;
                    
                    gl_FragColor = vec4(color, 1.0);
                }`
        });
        lensingPass.uniforms.strength.value = params.lensingStrength;
        composer.addPass(lensingPass);
        
        // Gravitational Wave Pass
        const wavePass = new ShaderPass({
             uniforms: { 
                tDiffuse: { value: null }, 
                time: { value: -1.0 }, 
                origin: { value: new THREE.Vector2() }, 
                amplitude: { value: 0.0 },
                frequency: { value: 50.0 },
                decay: { value: 2.0 }
            },
             vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
             fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform float time, amplitude, frequency, decay; 
                uniform vec2 origin; 
                varying vec2 vUv;
                
                void main() {
                    float dist = distance(vUv, origin);
                    
                    // Gravitational wave strain pattern
                    float strain = sin(dist * frequency - time * 15.0) * amplitude;
                    strain *= exp(-dist * decay) * exp(-time * 2.0);
                    strain *= smoothstep(0.0, 0.1, time) * (1.0 - smoothstep(0.7, 1.0, time));
                    
                    // Plus and cross polarizations
                    vec2 dir = normalize(vUv - origin);
                    vec2 perpDir = vec2(-dir.y, dir.x);
                    
                    vec2 plusPol = dir * strain;
                    vec2 crossPol = perpDir * strain * 0.5;
                    
                    vec2 totalOffset = plusPol + crossPol;
                    
                    vec4 color = texture2D(tDiffuse, vUv + totalOffset);
                    
                    // Wave visualization
                    float waveVis = abs(strain) * 15.0;
                    color.rgb += vec3(0.1, 0.05, 0.2) * waveVis;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(wavePass);

        // God-ray / Radial Blur pass for merger flash
        const godRayPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
                exposure: { value: 1.0 },
                decay: { value: 0.95 },
                density: { value: 0.5 },
                weight: { value: 0.4 },
                samples: { value: 60 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 lightPosition;
                uniform float exposure;
                uniform float decay;
                uniform float density;
                uniform float weight;
                uniform int samples;
                varying vec2 vUv;

                void main() {
                    vec2 delta = vUv - lightPosition;
                    delta *= 1.0 / float(samples) * density;
                    float illuminationDecay = 1.0;
                    vec4 color = texture2D(tDiffuse, vUv);

                    for (int i = 0; i < samples; i++) {
                        vUv -= delta;
                        vec4 sampleColor = texture2D(tDiffuse, vUv);
                        sampleColor *= illuminationDecay * weight;
                        color += sampleColor;
                        illuminationDecay *= decay;
                    }
                    gl_FragColor = color * exposure;
                }`
        });
        godRayPass.enabled = false;
        composer.addPass(godRayPass);
        
        // Enhanced Bloom Pass
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            params.bloomIntensity, 
            0.4, 
            0.1
        );
        bloomPass.threshold = 0.1;
        bloomPass.radius = 1.0;
        composer.addPass(bloomPass);
        
        // SMAA Anti-aliasing Pass (should be one of the last passes before final color correction)
        const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);
        composer.addPass(smaaPass);

        // Color Correction Pass
        const colorCorrectionPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                exposure: { value: 1.0 },
                contrast: { value: 1.1 },
                saturation: { value: 1.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float exposure;
                uniform float contrast;
                uniform float saturation;
                varying vec2 vUv;
                
                vec3 adjustSaturation(vec3 color, float sat) {
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    return mix(vec3(gray), color, sat);
                }
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    
                    // Exposure
                    color.rgb *= exposure;
                    
                    // Contrast
                    color.rgb = (color.rgb - 0.5) * contrast + 0.5;
                    
                    // Saturation
                    color.rgb = adjustSaturation(color.rgb, saturation);
                    
                    // Vignette
                    float vignette = smoothstep(1.0, 0.4, length(vUv - 0.5));
                    color.rgb *= vignette;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(colorCorrectionPass);

        // --- GUI Configuration ---
        const gui = new GUI();
        
        const setupFolder = gui.addFolder('System Setup');
        const mass1Controller = setupFolder.add(params, 'mass1', 10, 150).name('Mass 1 (M☉)');
        const mass2Controller = setupFolder.add(params, 'mass2', 10, 150).name('Mass 2 (M☉)');
        const distanceController = setupFolder.add(params, 'distance', 50, 200).name('Initial Distance');
        setupFolder.add(params, 'start').name('🚀 Launch Simulation');
        
        const presetsFolder = gui.addFolder('Presets');
        presetsFolder.add(params, 'preset1').name('Asymmetric Merger');
        presetsFolder.add(params, 'preset2').name('Equal Mass');
        presetsFolder.add(params, 'preset3').name('Extreme Mass Ratio');
        presetsFolder.add(params, 'preset4').name('Massive Merger');
        
        const directorFolder = gui.addFolder('Director Controls');
        const timeScaleController = directorFolder.add(params, 'timeScale', 0.1, 5.0).name('Time Scale');
        const cinematicController = directorFolder.add(params, 'cinematicCamera').name('Cinematic Camera');
        directorFolder.add(params, 'focusBH1').name('Focus on Black Hole 1');
        directorFolder.add(params, 'focusBH2').name('Focus on Black Hole 2');
        directorFolder.add(params, 'focusCenter').name('Focus on Center');
        directorFolder.add(params, 'resetCamera').name('Reset Camera');

        const visualFolder = gui.addFolder('Visual Controls');
        visualFolder.add(params, 'diskEmissivity', 0, 10).name('Disk Brightness').onChange(v => {
            blackHoles.forEach(bh => bh.diskMaterial.uniforms.emissiveIntensity.value = v);
        });
        visualFolder.add(params, 'bloomIntensity', 0, 5).name('Bloom Intensity').onChange(v => bloomPass.strength = v);
        const gridController = visualFolder.add(params, 'showGrid').name('Show Spacetime Grid').onChange(v => {
            spacetimeGrid.group.visible = v;
        });
        const infoController = visualFolder.add(params, 'showInfo').name('Show Info Display').onChange(v => {
            document.getElementById('info-panel').style.opacity = v ? '1' : '0';
        });
        visualFolder.add(params, 'particleDensity', 0, 3).name('Particle Density').onChange(v => {
             particleSystems.forEach(ps => {
                if (ps.userData.type === 'accretion') {
                    ps.material.uniforms.opacity.value = v;
                }
             });
        });
        visualFolder.add(starfieldMaterial.uniforms.nebulaDensity, 'value', 0, 5).name('Nebula Density');
        visualFolder.add(starfieldMaterial.uniforms.starDensity, 'value', 0, 5).name('Star Density');
        
        const advancedFolder = gui.addFolder('Advanced Physics');
        advancedFolder.add(params, 'orbitalDecay', 0, 0.02).name('Orbital Decay Rate');
        advancedFolder.add(params, 'finalSpin', 0, 0.98, 0.01).name('Final BH Spin (a/M)');
        advancedFolder.add(params, 'cameraShake').name('Camera Shake');
        advancedFolder.add(params, 'lensingStrength', 0, 2).name('Lensing Strength').onChange(v => {
            lensingPass.uniforms.strength.value = v;
        });
        advancedFolder.add(params, 'playSound').name('Play Merger Sound');
        
        const postProcessFolder = gui.addFolder('Post Processing');
        postProcessFolder.add(colorCorrectionPass.uniforms.exposure, 'value', 0.5, 2).name('Exposure');
        postProcessFolder.add(colorCorrectionPass.uniforms.contrast, 'value', 0.5, 2).name('Contrast');
        postProcessFolder.add(colorCorrectionPass.uniforms.saturation, 'value', 0, 2).name('Saturation');
        
        const qualityFolder = gui.addFolder('Performance');
        qualityFolder.add(params, 'quality', ['low', 'medium', 'high', 'ultra']).name('Quality').onChange(updateQuality);

        // --- UI & Controls Setup ---
        const controlsContainer = document.getElementById('controls');
        const pauseIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`;
        const playIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
        
        const controlButtons = [
            { id: 'restart-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>`, action: () => initSimulation(), title: 'Restart (R)' },
            { id: 'pause-btn', icon: pauseIcon, action: togglePause, title: 'Pause/Play (Space)' },
            { id: 'cinematic-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg>`, action: toggleCinematic, title: 'Cinematic Camera (C)' },
            { id: 'grid-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`, action: toggleGrid, title: 'Toggle Grid (G)' },
            { id: 'info-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`, action: toggleInfo, title: 'Toggle Info (I)' },
        ];

        controlButtons.forEach(btnInfo => {
            const button = document.createElement('button');
            button.id = btnInfo.id;
            button.innerHTML = btnInfo.icon;
            button.title = btnInfo.title;
            button.className = "p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all";
            button.addEventListener('click', btnInfo.action);
            controlsContainer.appendChild(button);
        });

        function togglePause() {
            params.isPaused = !params.isPaused;
            document.getElementById('pause-btn').innerHTML = params.isPaused ? playIcon : pauseIcon;
        }
        function toggleCinematic() {
            params.cinematicCamera = !params.cinematicCamera;
            cinematicController.updateDisplay();
        }
        function toggleGrid() {
            params.showGrid = !params.showGrid;
            spacetimeGrid.group.visible = params.showGrid;
            gridController.updateDisplay();
        }
        function toggleInfo() {
            params.showInfo = !params.showInfo;
            document.getElementById('info-panel').style.opacity = params.showInfo ? '1' : '0';
            infoController.updateDisplay();
        }

        function initSimulation() {
            // Clear previous simulation objects
            blackHoles.forEach(bh => bh.dispose());
            if (massStream) massStream.dispose();
            particleSystems.forEach(ps => {
                scene.remove(ps);
                ps.geometry.dispose();
                ps.material.dispose();
            });
            particleSystems = [];
            jets = [];
            blackHoles = [];
            
            simulationTime = 0;
            mergerTime = -1;
            simulationActive = true;

            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'INSPIRAL';
            phaseEl.style.color = '#22d3ee'; // cyan-400
            document.getElementById('progressBar').style.width = '0%';
            
            const m1 = params.mass1, m2 = params.mass2, dist = params.distance;
            initialDistance = dist;
            const totalMass = m1 + m2;
            
            // Circular orbit velocities
            const v = Math.sqrt(G * totalMass / dist);
            const v1 = v * m2 / totalMass;
            const v2 = v * m1 / totalMass;
            
            // Initial positions (center of mass at origin)
            const r1 = dist * m2 / totalMass;
            const r2 = dist * m1 / totalMass;
            
            const bh1 = new BlackHole(m1, new THREE.Vector3(-r1, 0, 0), new THREE.Vector3(0, 0, -v1), true);
            const bh2 = new BlackHole(m2, new THREE.Vector3(r2, 0, 0), new THREE.Vector3(0, 0, v2), false);
            
            blackHoles.push(bh1, bh2);
            massStream = new MassStream();
            wavePass.uniforms.time.value = -1.0;
            godRayPass.enabled = false;
            setCameraFocus(-1);
        }
        
        function applyPreset(m1, m2, d) {
            params.mass1 = m1;
            params.mass2 = m2;
            params.distance = d;
            mass1Controller.updateDisplay();
            mass2Controller.updateDisplay();
            distanceController.updateDisplay();
            initSimulation();
        }
        
        function updateQuality(quality) {
            let pixelRatio = 1;
            let samples = 30;
            switch(quality) {
                case 'low':
                    pixelRatio = 1;
                    samples = 30;
                    break;
                case 'medium':
                    pixelRatio = Math.min(window.devicePixelRatio, 1.5);
                    samples = 60;
                    break;
                case 'high':
                case 'ultra':
                    pixelRatio = Math.min(window.devicePixelRatio, 2);
                    samples = 80;
                    break;
            }
            renderer.setPixelRatio(pixelRatio);
            composer.setPixelRatio(pixelRatio);
            godRayPass.uniforms.samples.value = samples;
        }
        
        // --- Camera and Effects Management ---
        let shakeDuration = 0, shakeIntensity = 0;
        function triggerCameraShake(duration = 0.5, intensity = 0.5) { 
            shakeDuration = duration; 
            shakeIntensity = intensity; 
        }
        
        function updateCameraShake(deltaTime) { 
            if (shakeDuration > 0) { 
                shakeDuration -= deltaTime;
                const shake = shakeIntensity * (shakeDuration / 0.5); // Fade out
                camera.position.x += (Math.random() - 0.5) * shake; 
                camera.position.y += (Math.random() - 0.5) * shake;
                camera.position.z += (Math.random() - 0.5) * shake * 0.5;
            } 
        }
        
        function triggerGravitationalWave(origin) { 
            const screenPos = origin.clone().project(camera); 
            wavePass.uniforms.origin.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2); 
            wavePass.uniforms.time.value = 0.0; 
            wavePass.uniforms.amplitude.value = 0.04; 
        }
        
        function triggerBloomFlash(strength) { 
            let flashStrength = strength; 
            const flashInterval = setInterval(() => { 
                bloomPass.strength = flashStrength; 
                flashStrength *= 0.9;
                if (flashStrength <= params.bloomIntensity) { 
                    bloomPass.strength = params.bloomIntensity; 
                    clearInterval(flashInterval); 
                } 
            }, 16); 
        }

        function triggerGodRayFlash(origin) {
            const screenPos = origin.clone().project(camera);
            godRayPass.enabled = true;
            godRayPass.uniforms.lightPosition.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2);
            godRayPass.uniforms.exposure.value = 1.0;
        }
        
        let focusIndex = -1;
        function setCameraFocus(index) {
            focusIndex = index;
            params.cinematicCamera = false;
            cinematicController.updateDisplay();
        }

        function updateCamera(time) {
            if (params.cinematicCamera) {
                const phase = (time * 0.05) % (Math.PI * 2);
                const radius = 120 + Math.sin(phase * 2) * 30;
                const height = 50 + Math.sin(phase * 3) * 20;
                
                camera.position.x = Math.cos(phase) * radius;
                camera.position.z = Math.sin(phase) * radius;
                camera.position.y = height;
                
                const lookAhead = 0.1;
                const lookX = Math.cos(phase + lookAhead) * radius * 0.3;
                const lookZ = Math.sin(phase + lookAhead) * radius * 0.3;
                controls.target.set(lookX, 0, lookZ);
            } else {
                let targetPos = new THREE.Vector3();
                if (focusIndex === -1 && blackHoles.length > 1) {
                    const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                    targetPos.addScaledVector(blackHoles[0].position, blackHoles[0].mass / totalMass);
                    targetPos.addScaledVector(blackHoles[1].position, blackHoles[1].mass / totalMass);
                } else if (focusIndex >= 0 && blackHoles[focusIndex]) {
                    targetPos.copy(blackHoles[focusIndex].position);
                } else if (blackHoles.length === 1) {
                    targetPos.copy(blackHoles[0].position);
                }
                cameraTarget.position.lerp(targetPos, 0.1);
                controls.target.lerp(cameraTarget.position, 0.1);
            }
        }
        
        // --- Centralized Particle System Update ---
        function updateAllParticleSystems(deltaTime) {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const system = particleSystems[i];
                const type = system.userData.type;

                if (type === 'accretion') {
                    const bh = system.userData.parentBH;
                    if (!bh) continue;

                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    const lifetimes = system.geometry.attributes.lifetime.array;
                    const colors = system.geometry.attributes.customColor.array;
                    
                    for (let j = 0; j < lifetimes.length; j++) {
                        lifetimes[j] -= deltaTime * 0.1;
                        
                        if (lifetimes[j] <= 0) {
                            // Respawn
                            const angle = Math.random() * Math.PI * 2;
                            const radius = bh.radius * 1.5 + Math.random() * bh.radius * 2.5;
                            
                            positions[j * 3] = Math.cos(angle) * radius;
                            positions[j * 3 + 1] = (Math.random() - 0.5) * 2;
                            positions[j * 3 + 2] = Math.sin(angle) * radius;
                            
                            lifetimes[j] = 1.0;
                        } else {
                            // Update position with gravity
                            const x = positions[j * 3];
                            const y = positions[j * 3 + 1];
                            const z = positions[j * 3 + 2];
                            const r = Math.sqrt(x * x + z * z);
                            
                            // Gravitational acceleration
                            const accel = -G * bh.mass / (r * r);
                            velocities[j * 3] += (x / r) * accel * deltaTime;
                            velocities[j * 3 + 2] += (z / r) * accel * deltaTime;
                            
                            positions[j * 3] += velocities[j * 3] * deltaTime;
                            positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                            positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        }
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.geometry.attributes.lifetime.needsUpdate = true;
                    system.material.uniforms.opacity.value = params.particleDensity;
                } else if (type === 'jet') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for (let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                } else if (type === 'burst') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for(let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        velocities[j * 3] *= 0.99;
                        velocities[j * 3 + 1] *= 0.99;
                        velocities[j * 3 + 2] *= 0.99;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.material.opacity -= deltaTime * 0.5;
                    if (system.material.opacity <= 0) {
                        scene.remove(system);
                        system.geometry.dispose();
                        system.material.dispose();
                        particleSystems.splice(i, 1);
                    }
                }
                if (system.material.uniforms && system.material.uniforms.time) {
                    system.material.uniforms.time.value += deltaTime;
                }
            }
        }

        // --- Main Animation Loop ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const effectiveDeltaTime = clock.getDelta();
            const timeScale = params.isPaused ? 0 : params.timeScale;
            const deltaTime = effectiveDeltaTime * timeScale;
            const elapsedTime = clock.getElapsedTime();
            
            // Update simulation
            updatePhysics(deltaTime);
            if (!params.cinematicCamera) controls.update();
            updateCamera(elapsedTime);
            updateCameraShake(deltaTime);
            updateAllParticleSystems(deltaTime);
            
            // Update background
            starfieldMaterial.uniforms.time.value = elapsedTime;
            
            // Update post-merger effects
            if (mergerTime > 0 && blackHoles.length === 1) {
                const bh = blackHoles[0];
                const precessionQuaternion = new THREE.Quaternion().setFromAxisAngle(bh.precessionAxis, deltaTime * bh.spinMagnitude * 0.1);
                bh.group.quaternion.premultiply(precessionQuaternion);
                
                jets.forEach(jet => {
                    if (jet.material.uniforms.opacity.value > 0) {
                        jet.material.uniforms.opacity.value *= 0.995;
                    }
                    if (jet.material.uniforms.time) {
                        jet.material.uniforms.time.value = elapsedTime;
                    }
                });

                if (bh.diskMaterial.uniforms.ringdown.value > 0.001) {
                    bh.diskMaterial.uniforms.ringdown.value *= (1.0 - 0.8 * effectiveDeltaTime);
                } else {
                    bh.diskMaterial.uniforms.ringdown.value = 0.0;
                }
                updateInfoDisplay();
            }

            // Update lensing positions
            const screenPositions = blackHoles.map(bh => {
                const pos = bh.group.position.clone();
                pos.project(camera);
                return pos;
            });
            
            for (let i = 0; i < 10; i++) {
                if (i < blackHoles.length) {
                    lensingPass.uniforms.bhPositions.value[i].set(
                        (screenPositions[i].x + 1) / 2, 
                        (screenPositions[i].y + 1) / 2
                    );
                    lensingPass.uniforms.bhMasses.value[i] = blackHoles[i].mass;
                } else {
                    lensingPass.uniforms.bhPositions.value[i].set(-10, -10);
                    lensingPass.uniforms.bhMasses.value[i] = 0;
                }
            }
            lensingPass.uniforms.bhCount.value = blackHoles.length;
            lensingPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspect.value = window.innerWidth / window.innerHeight;
            
            // Update gravitational wave effect
            if (wavePass.uniforms.time.value >= 0) {
                wavePass.uniforms.time.value += deltaTime;
                if (wavePass.uniforms.time.value > 1.0) {
                    wavePass.uniforms.time.value = -1.0;
                }
            }

            // Update God Ray effect
            if (godRayPass.enabled) {
                godRayPass.uniforms.exposure.value *= (1.0 - 1.5 * effectiveDeltaTime);
                if (godRayPass.uniforms.exposure.value < 0.01) {
                    godRayPass.enabled = false;
                }
            }

            // Render
            composer.render();
        }
        
        // Start simulation
        const loader = document.getElementById('loader');
        initSimulation();
        animate();
        loader.style.opacity = '0';
        setTimeout(() => loader.style.display = 'none', 500);


        // --- Window Resize Handler ---
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
            composer.setSize(width, height);
            
            lensingPass.uniforms.resolution.value.set(width, height);
            lensingPass.uniforms.aspect.value = width / height;
            
            smaaPass.setSize(width, height);
            
            updateQuality(params.quality);
        });
        
        // --- Keyboard Controls ---
        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    togglePause();
                    break;
                case 'c': toggleCinematic(); break;
                case 'g': toggleGrid(); break;
                case 'i': toggleInfo(); break;
                case 'r': initSimulation(); break;
            }
        });
    </script>
<canvas data-engine="three.js r178" width="2704" height="410" style="display: block; width: 1352px; height: 205px; touch-action: none;"></canvas>
<div class="lil-gui allow-touch-styles root autoPlace"><div class="title" role="button" aria-expanded="true" tabindex="0">Controls</div><div class="children"><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Presets</div><div class="children"><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-5">Asymmetric Merger</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-6">Equal Mass</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-7">Extreme Mass Ratio</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-8">Massive Merger</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Director Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-9">Time Scale</div><div class="widget"><div class="slider"><div class="fill" style="width: 18.367347%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-9"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-10">Cinematic Camera</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-10"></label></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-11">Focus on Black Hole 1</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-12">Focus on Black Hole 2</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-13">Focus on Center</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-14">Reset Camera</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Visual Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-15">Disk Brightness</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-15"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-16">Bloom Intensity</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-16"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-17">Show Spacetime Grid</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-17"></label></div><div class="controller boolean"><div class="name" id="lil-gui-name-18">Show Info Display</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-18"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-19">Particle Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-19"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-20">Nebula Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-20"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-21">Star Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-21"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Advanced Physics</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-22">Orbital Decay Rate</div><div class="widget"><div class="slider"><div class="fill" style="width: 25%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-22"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-23">Final BH Spin (a/M)</div><div class="widget"><div class="slider"><div class="fill" style="width: 91.836735%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-23"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-24">Camera Shake</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-24"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-25">Lensing Strength</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-25"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-26">Play Merger Sound</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-26"></label></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Post Processing</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-27">Exposure</div><div class="widget"><div class="slider"><div class="fill" style="width: 33.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-27"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-28">Contrast</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-28"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-29">Saturation</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-29"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Performance</div><div class="children"><div class="controller option"><div class="name" id="lil-gui-name-30">Quality</div><div class="widget"><select aria-labelledby="lil-gui-name-30"><option>low</option><option>medium</option><option>high</option><option>ultra</option></select><div class="display">ultra</div></div></div></div></div></div></div>
<div class="title" role="button" aria-expanded="true" tabindex="0">Controls</div>
<div class="children"><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Presets</div><div class="children"><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-5">Asymmetric Merger</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-6">Equal Mass</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-7">Extreme Mass Ratio</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-8">Massive Merger</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Director Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-9">Time Scale</div><div class="widget"><div class="slider"><div class="fill" style="width: 18.367347%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-9"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-10">Cinematic Camera</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-10"></label></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-11">Focus on Black Hole 1</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-12">Focus on Black Hole 2</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-13">Focus on Center</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-14">Reset Camera</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Visual Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-15">Disk Brightness</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-15"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-16">Bloom Intensity</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-16"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-17">Show Spacetime Grid</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-17"></label></div><div class="controller boolean"><div class="name" id="lil-gui-name-18">Show Info Display</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-18"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-19">Particle Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-19"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-20">Nebula Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-20"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-21">Star Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-21"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Advanced Physics</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-22">Orbital Decay Rate</div><div class="widget"><div class="slider"><div class="fill" style="width: 25%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-22"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-23">Final BH Spin (a/M)</div><div class="widget"><div class="slider"><div class="fill" style="width: 91.836735%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-23"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-24">Camera Shake</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-24"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-25">Lensing Strength</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-25"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-26">Play Merger Sound</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-26"></label></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Post Processing</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-27">Exposure</div><div class="widget"><div class="slider"><div class="fill" style="width: 33.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-27"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-28">Contrast</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-28"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-29">Saturation</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-29"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Performance</div><div class="children"><div class="controller option"><div class="name" id="lil-gui-name-30">Quality</div><div class="widget"><select aria-labelledby="lil-gui-name-30"><option>low</option><option>medium</option><option>high</option><option>ultra</option></select><div class="display">ultra</div></div></div></div></div></div>
<div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div></div>
<div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div>
<div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div>
<div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div>
<div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div>
<div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div>
<div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div>
<div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div>
<div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div>
<div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div>
<div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div>
<div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div></div>
<div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Presets</div><div class="children"><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-5">Asymmetric Merger</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-6">Equal Mass</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-7">Extreme Mass Ratio</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-8">Massive Merger</div></button></div></div></div></div>
<div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Director Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-9">Time Scale</div><div class="widget"><div class="slider"><div class="fill" style="width: 18.367347%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-9"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-10">Cinematic Camera</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-10"></label></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-11">Focus on Black Hole 1</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-12">Focus on Black Hole 2</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-13">Focus on Center</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-14">Reset Camera</div></button></div></div></div></div>
<div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Visual Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-15">Disk Brightness</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-15"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-16">Bloom Intensity</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-16"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-17">Show Spacetime Grid</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-17"></label></div><div class="controller boolean"><div class="name" id="lil-gui-name-18">Show Info Display</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-18"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-19">Particle Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-19"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-20">Nebula Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-20"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-21">Star Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-21"></div></div></div></div>
<div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Advanced Physics</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-22">Orbital Decay Rate</div><div class="widget"><div class="slider"><div class="fill" style="width: 25%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-22"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-23">Final BH Spin (a/M)</div><div class="widget"><div class="slider"><div class="fill" style="width: 91.836735%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-23"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-24">Camera Shake</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-24"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-25">Lensing Strength</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-25"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-26">Play Merger Sound</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-26"></label></div></div></div>
<div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Post Processing</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-27">Exposure</div><div class="widget"><div class="slider"><div class="fill" style="width: 33.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-27"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-28">Contrast</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-28"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-29">Saturation</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-29"></div></div></div></div>
<div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Performance</div><div class="children"><div class="controller option"><div class="name" id="lil-gui-name-30">Quality</div><div class="widget"><select aria-labelledby="lil-gui-name-30"><option>low</option><option>medium</option><option>high</option><option>ultra</option></select><div class="display">ultra</div></div></div></div></div>
<div class="children"><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Presets</div><div class="children"><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-5">Asymmetric Merger</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-6">Equal Mass</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-7">Extreme Mass Ratio</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-8">Massive Merger</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Director Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-9">Time Scale</div><div class="widget"><div class="slider"><div class="fill" style="width: 18.367347%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-9"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-10">Cinematic Camera</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-10"></label></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-11">Focus on Black Hole 1</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-12">Focus on Black Hole 2</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-13">Focus on Center</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-14">Reset Camera</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Visual Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-15">Disk Brightness</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-15"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-16">Bloom Intensity</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-16"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-17">Show Spacetime Grid</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-17"></label></div><div class="controller boolean"><div class="name" id="lil-gui-name-18">Show Info Display</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-18"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-19">Particle Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-19"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-20">Nebula Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-20"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-21">Star Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-21"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Advanced Physics</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-22">Orbital Decay Rate</div><div class="widget"><div class="slider"><div class="fill" style="width: 25%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-22"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-23">Final BH Spin (a/M)</div><div class="widget"><div class="slider"><div class="fill" style="width: 91.836735%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-23"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-24">Camera Shake</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-24"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-25">Lensing Strength</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-25"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-26">Play Merger Sound</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-26"></label></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Post Processing</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-27">Exposure</div><div class="widget"><div class="slider"><div class="fill" style="width: 33.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-27"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-28">Contrast</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-28"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-29">Saturation</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-29"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Performance</div><div class="children"><div class="controller option"><div class="name" id="lil-gui-name-30">Quality</div><div class="widget"><select aria-labelledby="lil-gui-name-30"><option>low</option><option>medium</option><option>high</option><option>ultra</option></select><div class="display">ultra</div></div></div></div></div></div>
<div class="lil-gui allow-touch-styles root autoPlace"><div class="title" role="button" aria-expanded="true" tabindex="0">Controls</div><div class="children"><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Presets</div><div class="children"><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-5">Asymmetric Merger</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-6">Equal Mass</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-7">Extreme Mass Ratio</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-8">Massive Merger</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Director Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-9">Time Scale</div><div class="widget"><div class="slider"><div class="fill" style="width: 18.367347%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-9"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-10">Cinematic Camera</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-10"></label></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-11">Focus on Black Hole 1</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-12">Focus on Black Hole 2</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-13">Focus on Center</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-14">Reset Camera</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Visual Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-15">Disk Brightness</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-15"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-16">Bloom Intensity</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-16"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-17">Show Spacetime Grid</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-17"></label></div><div class="controller boolean"><div class="name" id="lil-gui-name-18">Show Info Display</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-18"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-19">Particle Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-19"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-20">Nebula Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-20"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-21">Star Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-21"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Advanced Physics</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-22">Orbital Decay Rate</div><div class="widget"><div class="slider"><div class="fill" style="width: 25%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-22"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-23">Final BH Spin (a/M)</div><div class="widget"><div class="slider"><div class="fill" style="width: 91.836735%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-23"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-24">Camera Shake</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-24"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-25">Lensing Strength</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-25"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-26">Play Merger Sound</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-26"></label></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Post Processing</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-27">Exposure</div><div class="widget"><div class="slider"><div class="fill" style="width: 33.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-27"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-28">Contrast</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-28"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-29">Saturation</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-29"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Performance</div><div class="children"><div class="controller option"><div class="name" id="lil-gui-name-30">Quality</div><div class="widget"><select aria-labelledby="lil-gui-name-30"><option>low</option><option>medium</option><option>high</option><option>ultra</option></select><div class="display">ultra</div></div></div></div></div></div></div>
<body class="bg-black">
    <!-- Loading overlay -->
    <div id="loader" style="opacity: 0; display: none;">Initializing Simulation...</div>

    <!-- Enhanced UI Container -->
    <div id="ui-container" class="fixed inset-0 p-4 sm:p-6 lg:p-8 pointer-events-none text-gray-200 font-mono text-sm">
        <!-- Top-left Info Panel -->
        <div id="info-panel" class="absolute top-4 left-4 sm:top-6 sm:left-6 lg:top-8 lg:left-8 bg-black/60 backdrop-blur-md p-4 rounded-lg border border-white/10 shadow-lg pointer-events-auto transition-all duration-300 opacity-100">
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">66.5 Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">1335.05 s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">-1 E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">0.001 Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">105.8 s</span>
                    </div></div>

        <!-- Bottom Controls -->
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 w-full max-w-lg px-4">
            <!-- Timeline -->
            <div id="timeline-container" class="bg-black/60 backdrop-blur-md p-3 rounded-lg border border-white/10 shadow-lg mb-4 pointer-events-auto">
                <div id="phase" class="text-center text-xs font-bold tracking-widest uppercase mb-2 text-cyan-300 transition-colors duration-500" style="color: rgb(34, 211, 238);">INSPIRAL</div>
                <div id="progress" class="w-full h-2 bg-white/10 rounded-full overflow-hidden shadow-inner">
                    <div id="progressBar" class="h-full bg-gradient-to-r from-cyan-400 to-purple-500 transition-all duration-500 ease-out" style="width: 5.066561%;"></div>
                </div>
            </div>
            <!-- Control Buttons -->
            <div id="controls" class="flex justify-center items-center gap-2 bg-black/60 backdrop-blur-md p-2 rounded-lg border border-white/10 shadow-lg pointer-events-auto">
                <!-- Buttons will be populated by JS -->
            <button id="restart-btn" title="Restart (R)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg></button><button id="pause-btn" title="Pause/Play (Space)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg></button><button id="cinematic-btn" title="Cinematic Camera (C)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg></button><button id="grid-btn" title="Toggle Grid (G)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg></button><button id="info-btn" title="Toggle Info (I)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></button></div>
        </div>
    </div>

    <!-- Audio for merger sound -->
    <audio id="mergerSound" src="https://gwosc.org/GW150914data/GW150914_H1_shifted.wav" preload="auto"></audio>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- Enhanced Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000011, 0.0003);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, // SMAA pass handles anti-aliasing
            powerPreference: "high-performance",
            alpha: false,
            stencil: false,
            depth: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Camera Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 800;
        controls.maxPolarAngle = Math.PI * 0.85;
        camera.position.set(0, 40, 90);

        // --- Ultra HD Galaxy Background ---
        const starfieldMaterial = new THREE.ShaderMaterial({
            uniforms: { 
                time: { value: 0.0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                nebulaDensity: { value: 2.0 },
                starDensity: { value: 3.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                varying vec3 vPosition;
                void main() { 
                    vUv = uv; 
                    vPosition = position;
                    gl_Position = vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                uniform float nebulaDensity;
                uniform float starDensity;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                // High quality noise functions
                float hash(vec3 p) { 
                    p = fract(p * vec3(443.8975, 397.2973, 491.1871));
                    p += dot(p, p.yxz + 19.19);
                    return fract((p.x + p.y) * p.z);
                }
                
                float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    return mix(mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
                                   mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                               mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                   mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                }
                
                float fbm(vec3 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    float frequency = 1.0;
                    for(int i = 0; i < 6; i++) {
                        value += amplitude * noise(p * frequency);
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }
                    return value;
                }
                
                void main() {
                    vec3 color = vec3(0.0);
                    vec2 uv = vUv;
                    vec3 pos = vPosition;
                    
                    // Ultra HD star field
                    for(int i = 0; i < 5; i++) {
                        float scale = 100.0 + float(i) * 200.0;
                        vec2 starUv = uv * scale;
                        float star = hash(vec3(floor(starUv), float(i)));
                        
                        if(star > 0.98 - float(i) * 0.01) {
                            vec2 starPos = fract(starUv) - 0.5;
                            float dist = length(starPos);
                            float brightness = 1.0 - smoothstep(0.0, 0.02, dist);
                            brightness *= (0.5 + 0.5 * sin(time * (1.0 + star * 5.0)));
                            
                            // Star color variation
                            vec3 starColor = vec3(1.0);
                            float colorType = hash(vec3(floor(starUv), float(i) + 100.0));
                            if(colorType < 0.3) starColor = vec3(1.0, 0.8, 0.6); // Yellow
                            else if(colorType < 0.6) starColor = vec3(0.8, 0.8, 1.0); // Blue-white
                            else if(colorType < 0.8) starColor = vec3(1.0, 0.6, 0.4); // Red
                            
                            color += starColor * brightness * starDensity / float(i + 1);
                        }
                    }
                    
                    // High detail nebula
                    vec3 nebulaPos = pos * 0.001;
                    float nebula1 = fbm(nebulaPos + vec3(time * 0.01, 0.0, 0.0));
                    float nebula2 = fbm(nebulaPos * 2.0 - vec3(0.0, time * 0.02, 0.0));
                    float nebula3 = fbm(nebulaPos * 4.0 + vec3(0.0, 0.0, time * 0.03));
                    
                    float nebulaMask = nebula1 * 0.5 + nebula2 * 0.3 + nebula3 * 0.2;
                    nebulaMask = pow(nebulaMask, 2.0) * nebulaDensity;
                    
                    // Nebula color gradients
                    vec3 nebulaColor1 = vec3(0.1, 0.0, 0.4) * nebula1;
                    vec3 nebulaColor2 = vec3(0.0, 0.1, 0.3) * nebula2;
                    vec3 nebulaColor3 = vec3(0.2, 0.0, 0.2) * nebula3;
                    vec3 nebulaColor = (nebulaColor1 + nebulaColor2 + nebulaColor3) * 0.5;
                    
                    color += nebulaColor * nebulaMask;
                    
                    // Milky way band
                    float band = 1.0 - abs(pos.y * 0.005);
                    band = pow(band, 4.0) * 0.2;
                    vec3 bandColor = mix(vec3(0.05, 0.03, 0.08), vec3(0.1, 0.08, 0.15), noise(pos * 0.01));
                    color += bandColor * band;
                    
                    // Distant galaxies
                    float galaxyNoise = hash(vec3(uv * 50.0, 0.0));
                    if(galaxyNoise > 0.999) {
                        float galaxyBrightness = pow(galaxyNoise, 10.0) * 0.5;
                        color += vec3(0.8, 0.7, 0.9) * galaxyBrightness;
                    }
                    
                    // Final color grading
                    color = pow(color, vec3(0.85));
                    color = mix(color, vec3(dot(color, vec3(0.299, 0.587, 0.114))), -0.2);
                    
                    gl_FragColor = vec4(color, 1.0);
                }`,
            side: THREE.BackSide
        });
        const starfieldSphere = new THREE.Mesh(new THREE.IcosahedronGeometry(2000, 4), starfieldMaterial);
        scene.add(starfieldSphere);

        // --- Advanced Ambient Lighting ---
        const ambientLight = new THREE.AmbientLight(0x0a0a0a, 0.5);
        scene.add(ambientLight);

        // --- High Quality Spacetime Grid ---
        class SpacetimeGrid {
            constructor() {
                this.gridSize = 300;
                this.gridDivisions = 60;
                this.group = new THREE.Group();
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        bhPositions: { value: [new THREE.Vector3(), new THREE.Vector3()] },
                        bhMasses: { value: [0, 0] },
                        time: { value: 0 },
                        opacity: { value: 0.3 },
                        waveAmplitude: { value: 0.0 },
                        waveOrigin: { value: new THREE.Vector3() },
                        waveTime: { value: 0.0 }
                    },
                    vertexShader: `
                        uniform vec3 bhPositions[2];
                        uniform float bhMasses[2];
                        uniform float time;
                        uniform float waveAmplitude;
                        uniform vec3 waveOrigin;
                        uniform float waveTime;
                        
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            vec3 pos = position;
                            float totalDistortion = 0.0;
                            
                            // Black hole warping
                            for(int i = 0; i < 2; i++) {
                                if(bhMasses[i] > 0.0) {
                                    vec3 delta = pos - bhPositions[i];
                                    delta.y = 0.0;
                                    float dist = length(delta);
                                    float warp = bhMasses[i] / (dist + 5.0);
                                    float falloff = exp(-dist * 0.05);
                                    pos.y -= warp * 3.0 * falloff;
                                    totalDistortion += warp;
                                }
                            }
                            
                            // Gravitational wave ripples
                            float waveDist = length(pos.xz - waveOrigin.xz);
                            float wave = sin(waveDist * 0.3 - waveTime * 15.0) * waveAmplitude;
                            wave *= exp(-waveDist * 0.01) * exp(-waveTime * 2.0);
                            pos.y += wave * 5.0;
                            vWave = wave;
                            
                            // Orbital motion distortion
                            float orbitalEffect = sin(time * 2.0 + length(pos.xz) * 0.05) * 0.2;
                            pos.y += orbitalEffect * totalDistortion;
                            
                            vDistortion = totalDistortion;
                            vColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.0, 0.5), totalDistortion * 0.2);
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            float intensity = 0.3 + vDistortion * 0.7 + abs(vWave) * 2.0;
                            vec3 color = vColor;
                            
                            // Pulsing effect
                            float pulse = sin(time * 3.0 + vDistortion * 10.0) * 0.1 + 0.9;
                            intensity *= pulse;
                            
                            // Wave color enhancement
                            if(abs(vWave) > 0.01) {
                                color = mix(color, vec3(0.5, 0.0, 1.0), abs(vWave) * 5.0);
                            }
                            
                            gl_FragColor = vec4(color, opacity * intensity);
                        }`,
                    transparent: true,
                    wireframe: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const geometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize, this.gridDivisions, this.gridDivisions);
                geometry.rotateX(-Math.PI / 2);
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.position.y = -10;
                this.group.add(this.mesh);
                
                scene.add(this.group);
                this.group.visible = false;
            }
            
            update(blackHoles, deltaTime) {
                if (blackHoles.length > 0) {
                    this.material.uniforms.bhPositions.value[0].copy(blackHoles[0].position);
                    this.material.uniforms.bhMasses.value[0] = blackHoles[0].mass;
                }
                if (blackHoles.length > 1) {
                    this.material.uniforms.bhPositions.value[1].copy(blackHoles[1].position);
                    this.material.uniforms.bhMasses.value[1] = blackHoles[1].mass;
                } else {
                    this.material.uniforms.bhMasses.value[1] = 0;
                }
                this.material.uniforms.time.value += deltaTime;
                this.material.uniforms.waveTime.value += deltaTime;
            }
            
            triggerWave(origin, amplitude) {
                this.material.uniforms.waveOrigin.value.copy(origin);
                this.material.uniforms.waveAmplitude.value = amplitude;
                this.material.uniforms.waveTime.value = 0;
            }
        }

        // --- Physics & Simulation State ---
        const G = 0.1;
        let blackHoles = [];
        let massStream = null;
        let jets = [];
        let simulationActive = true;
        let spacetimeGrid = new SpacetimeGrid();
        let particleSystems = [];
        let initialDistance = 70;
        let simulationTime = 0;
        let mergerTime = -1;
        
        const params = {
            mass1: 40, 
            mass2: 25, 
            distance: 70, 
            timeScale: 1.0, 
            isPaused: false,
            orbitalDecay: 0.005,
            diskEmissivity: 3.0, 
            bloomIntensity: 1.5, 
            finalSpin: 0.9, 
            cameraShake: true, 
            cinematicCamera: false,
            showGrid: false, 
            showInfo: true, 
            quality: 'ultra',
            particleDensity: 1.5, 
            lensingStrength: 1.0,
            playSound: true, // New parameter for sound
            focusBH1: () => setCameraFocus(0),
            focusBH2: () => setCameraFocus(1),
            focusCenter: () => setCameraFocus(-1),
            resetCamera: () => {
                setCameraFocus(-1);
                controls.reset();
                camera.position.set(0, 40, 90);
            },
            start: () => initSimulation(),
            preset1: () => applyPreset(40, 25, 70),
            preset2: () => applyPreset(30, 30, 80),
            preset3: () => applyPreset(50, 10, 100),
            preset4: () => applyPreset(140, 100, 120) // New 2025 massive merger preset
        };
        
        let cameraTarget = new THREE.Object3D();
        scene.add(cameraTarget);

        // --- Ultra HD BlackHole Class (with enhanced Doppler shift) ---
        class BlackHole {
            constructor(mass, position, velocity, isPrimary = false) {
                this.mass = mass; 
                this.position = position; 
                this.velocity = velocity;
                this.isPrimary = isPrimary;
                this.isMerged = false; 
                this.radius = Math.pow(mass, 1/3);
                this.spin = new THREE.Vector3(0, 1, 0).multiplyScalar(Math.random() * 0.5 + 0.5);
                this.spinMagnitude = 0;
                this.precessionAxis = new THREE.Vector3(0, 1, 0);
                
                this.group = new THREE.Group();
                
                // Schwarzschild radius event horizon
                const eventHorizonGeometry = new THREE.SphereGeometry(this.radius, 128, 64);
                this.eventHorizon = new THREE.Mesh(eventHorizonGeometry, new THREE.MeshBasicMaterial({ 
                    color: 0x000000
                }));
                this.eventHorizon.castShadow = true;
                this.eventHorizon.receiveShadow = true;
                this.group.add(this.eventHorizon);
                
                // Multi-layer glow effect
                for(let i = 0; i < 3; i++) {
                    const glowScale = 1.1 + i * 0.05;
                    const glowGeometry = new THREE.SphereGeometry(this.radius * glowScale, 64, 32);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: isPrimary ? 0xff6600 : 0x0066ff,
                        transparent: true,
                        opacity: 0.1 / (i + 1),
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.group.add(glow);
                }
                
                // Dynamic light sources
                this.light = new THREE.PointLight(isPrimary ? 0xffaa66 : 0x6699ff, 2, 300, 2);
                this.light.castShadow = true;
                this.light.shadow.mapSize.width = 1024;
                this.light.shadow.mapSize.height = 1024;
                this.group.add(this.light);
                
                // Rim lighting
                const rimLight = new THREE.PointLight(isPrimary ? 0xff6600 : 0x0066ff, 1, 200, 2);
                rimLight.position.set(0, this.radius * 2, 0);
                this.group.add(rimLight);

                // Ultra HD accretion disk with enhanced Doppler
                this.createAccretionDisk();
                
                scene.add(this.group);
                
                // HD Particle systems
                this.createParticleSystem();
                this.createPhotonSphere();
            }
            
            createAccretionDisk() {
                const diskInner = this.radius * 1.5; 
                const diskOuter = this.radius * 4;
                
                this.diskMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        innerRadius: { value: diskInner },
                        outerRadius: { value: diskOuter },
                        emissiveIntensity: { value: params.diskEmissivity },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xff8800) : new THREE.Color(0x0088ff) },
                        rotationSpeed: { value: 1.0 },
                        temperature: { value: 1.0 },
                        ringdown: { value: 0.0 },
                        tidalForce: { value: new THREE.Vector3() },
                        cameraPos: { value: new THREE.Vector3() }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float ringdown;
                        uniform vec3 tidalForce;
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;

                        void main() {
                            vUv = uv;
                            vPos = position;
                            vNormal = normal;
                            vec3 pos = position;
                            
                            // Tidal Disruption Effect
                            float tidalMagnitude = length(tidalForce);
                            if (tidalMagnitude > 0.01) {
                                vec3 dirToForce = normalize(tidalForce);
                                float alignment = dot(normalize(pos.xz), normalize(dirToForce.xz));
                                float stretch = smoothstep(0.5, 1.0, alignment) * tidalMagnitude * 5.0;
                                pos += dirToForce * stretch;
                            }

                            // Ringdown oscillation effect
                            if (ringdown > 0.0) {
                                float r = length(pos.xz);
                                float angle = atan(pos.z, pos.x);
                                float wobble = sin(r * 0.5 - time * 10.0) * sin(angle * 4.0); // Quadrupole oscillation
                                pos.y += wobble * ringdown * r * 0.1; // Amplitude proportional to radius
                            }
                            
                            vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float time;
                        uniform float innerRadius;
                        uniform float outerRadius;
                        uniform float emissiveIntensity;
                        uniform vec3 primaryColor;
                        uniform float rotationSpeed;
                        uniform float temperature;
                        uniform vec3 cameraPos;
                        
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vWorldPosition;
                        
                        // High quality noise
                        float noise(vec2 p) {
                            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                        }
                        
                        float turbulence(vec2 p) {
                            float value = 0.0;
                            float scale = 1.0;
                            for(int i = 0; i < 5; i++) {
                                value += noise(p * scale) / scale;
                                scale *= 2.0;
                            }
                            return value;
                        }
                        
                        vec3 blackbody(float temp) {
                            vec3 color;
                            float t = temp * 4000.0;
                            
                            if(t < 6600.0) {
                                color.r = 1.0;
                                color.g = 0.39 * log(t / 100.0) - 0.63;
                                color.b = 0.54 * log(t / 100.0 - 10.0) - 1.19;
                            } else {
                                color.r = 1.29 * pow(t / 100.0 - 60.0, -0.13);
                                color.g = 1.29 * pow(t / 100.0 - 60.0, -0.07);
                                color.b = 1.0;
                            }
                            
                            return clamp(color, 0.0, 1.0);
                        }
                        
                        void main() {
                            float dist = length(vPos);
                            float angle = atan(vPos.z, vPos.x);
                            
                            // Complex spiral arms
                            float spiral1 = sin(angle * 2.0 - time * rotationSpeed + dist * 0.3);
                            float spiral2 = sin(angle * 3.0 + time * rotationSpeed * 0.7 - dist * 0.2);
                            float spiralPattern = (spiral1 * 0.7 + spiral2 * 0.3) * 0.5 + 0.5;
                            
                            // Turbulence
                            float turb = turbulence(vec2(angle * 5.0, dist * 0.1) + time * 0.1);
                            spiralPattern = mix(spiralPattern, turb, 0.3);
                            
                            // Radial profile
                            float innerEdge = smoothstep(innerRadius - 1.0, innerRadius + 1.0, dist);
                            float outerEdge = 1.0 - smoothstep(outerRadius - 5.0, outerRadius, dist);
                            float radialFade = innerEdge * outerEdge;
                            
                            // Temperature gradient
                            float temp = temperature * (1.0 - (dist - innerRadius) / (outerRadius - innerRadius));
                            temp = pow(temp, 2.0);
                            
                            // Relativistic Doppler Beaming
                            vec3 tangent = normalize(vec3(-vPos.z, 0.0, vPos.x));
                            float speed = 0.3; // Relativistic speed factor
                            vec3 velocity = tangent * speed;
                            vec3 viewDir = normalize(cameraPos - vWorldPosition);
                            float dopplerFactor = dot(velocity, viewDir);
                            float brightnessBoost = pow(1.0 + dopplerFactor, 4.0);
                            temp *= (1.0 + dopplerFactor * 0.5); // Temperature shift
                            
                            // Color from temperature
                            vec3 color = blackbody(temp) * primaryColor;
                            
                            // Hot spots and flares
                            float hotSpot = pow(noise(vec2(angle * 10.0 + time, dist * 0.5)), 3.0);
                            color += color * hotSpot * 2.0;
                            
                            // Rim brightening
                            float innerRim = 1.0 - smoothstep(innerRadius, innerRadius + 2.0, dist);
                            color += primaryColor * pow(innerRim, 2.0) * 5.0;
                            
                            // Final composition
                            float intensity = radialFade * (0.6 + spiralPattern * 0.4) * emissiveIntensity * brightnessBoost;
                            color *= intensity;
                            
                            // Add glow
                            color += primaryColor * 0.1 * intensity;
                            
                            gl_FragColor = vec4(color, radialFade * 0.9);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const diskSegments = params.quality === 'ultra' ? 256 : 128;
                const diskGeometry = new THREE.RingGeometry(diskInner, diskOuter, diskSegments, 16);
                diskGeometry.rotateX(-Math.PI / 2);
                
                this.accretionDisk = new THREE.Mesh(diskGeometry, this.diskMaterial);
                this.group.add(this.accretionDisk);
            }
            
            createParticleSystem() {
                const particleCount = params.quality === 'ultra' ? 2000 : 1000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                const lifetimes = new Float32Array(particleCount);
                const sizes = new Float32Array(particleCount);
                const customColors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = this.radius * 1.5 + Math.random() * this.radius * 2.5;
                    const height = (Math.random() - 0.5) * 4;
                    
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = height * Math.exp(-radius / (this.radius * 3));
                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    const speed = Math.sqrt(G * this.mass / radius) * (0.8 + Math.random() * 0.4);
                    velocities[i * 3] = -Math.sin(angle) * speed;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                    velocities[i * 3 + 2] = Math.cos(angle) * speed;
                    
                    lifetimes[i] = Math.random();
                    sizes[i] = Math.random() * 2 + 0.5;
                    
                    const temp = 1.0 - (radius - this.radius) / (this.radius * 3);
                    customColors[i * 3] = temp;
                    customColors[i * 3 + 1] = temp * 0.5;
                    customColors[i * 3 + 2] = temp * 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xffaa66) : new THREE.Color(0x6699ff) },
                        opacity: { value: 1.0 }
                    },
                    vertexShader: `
                        attribute float lifetime;
                        attribute float size;
                        attribute vec3 customColor;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vLifetime = lifetime;
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z) * vLifetime;
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform vec3 primaryColor;
                        uniform float opacity;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * vLifetime * 0.8 * opacity;
                            vec3 finalColor = mix(primaryColor, vec3(1.0), vColor.r);
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.particles.userData.type = 'accretion';
                this.particles.userData.parentBH = this;
                this.group.add(this.particles);
                particleSystems.push(this.particles);
            }
            
            createPhotonSphere() {
                // Photon sphere at 1.5x Schwarzschild radius
                const photonRadius = this.radius * 1.5;
                const photonGeometry = new THREE.TorusGeometry(photonRadius, 0.1, 8, 64);
                const photonMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                this.photonSphere = new THREE.Mesh(photonGeometry, photonMaterial);
                this.photonSphere.rotation.x = Math.PI / 2;
                this.group.add(this.photonSphere);
            }
            
            update(deltaTime) {
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.group.position.copy(this.position);
                this.light.intensity = this.mass * 0.05 * params.diskEmissivity;
                
                // Update disk
                this.diskMaterial.uniforms.time.value += deltaTime;
                this.diskMaterial.uniforms.cameraPos.value.copy(camera.position);
                this.accretionDisk.rotation.y += deltaTime * 0.3;
                
                // Photon sphere rotation
                if(this.photonSphere) {
                    this.photonSphere.rotation.z += deltaTime * 2;
                }
                
                if (this.isMerged) {
                    this.diskMaterial.uniforms.emissiveIntensity.value = THREE.MathUtils.lerp(
                        this.diskMaterial.uniforms.emissiveIntensity.value, 
                        params.diskEmissivity, 
                        deltaTime * 0.5
                    );
                }
            }
            
            dispose() {
                // Remove associated particle systems from the global array
                particleSystems = particleSystems.filter(p => p.userData.parentBH !== this);

                // Dispose of all geometries and materials to free up GPU memory
                this.group.traverse(child => {
                    if (child.isMesh || child.isPoints) {
                        child.geometry.dispose();
                        // If material is an array, dispose each one
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                scene.remove(this.group);
            }
        }
        
        // --- Ultra HD MassStream Class ---
        class MassStream {
            constructor() {
                this.particleCount = 1000;
                this.geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particleCount * 3);
                const customColors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);
                
                for (let i = 0; i < this.particleCount; i++) {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                    
                    const t = i / this.particleCount;
                    customColors[i * 3] = 1.0;
                    customColors[i * 3 + 1] = 0.5 + t * 0.5;
                    customColors[i * 3 + 2] = t;
                    
                    sizes[i] = Math.random() * 2 + 0.5;
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 0.8 }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 customColor;
                        varying vec3 vColor;
                        
                        void main() {
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (200.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * opacity;
                            vec3 finalColor = vColor * (1.0 + 0.5 * sin(time * 10.0));
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
            }
            
            update(p1, p2, v1, distance, deltaTime) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.customColor.array;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const t = i / this.particleCount;
                    
                    // Bezier curve for stream path
                    const midPoint = new THREE.Vector3().lerpVectors(p1, p2, 0.5);
                    const offset = new THREE.Vector3().crossVectors(
                        new THREE.Vector3().subVectors(p2, p1).normalize(),
                        new THREE.Vector3(0, 1, 0)
                    ).multiplyScalar(distance * 0.1 * Math.sin(t * Math.PI));
                    midPoint.add(offset);
                    
                    // Quadratic bezier interpolation
                    const t2 = 1 - t;
                    const point = new THREE.Vector3()
                        .addScaledVector(p1, t2 * t2)
                        .addScaledVector(midPoint, 2 * t2 * t)
                        .addScaledVector(p2, t * t);
                    
                    // Add turbulence
                    const turbulence = new THREE.Vector3(
                        Math.sin(t * 10 + this.material.uniforms.time.value * 5) * 2,
                        Math.cos(t * 8 + this.material.uniforms.time.value * 3) * 2,
                        Math.sin(t * 12 + this.material.uniforms.time.value * 4) * 2
                    );
                    point.add(turbulence);
                    
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                    
                    // Dynamic coloring based on distance
                    const heat = 1.0 - distance / 100;
                    colors[i * 3] = heat;
                    colors[i * 3 + 1] = heat * 0.5;
                    colors[i * 3 + 2] = (1 - heat) * 0.5;
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.customColor.needsUpdate = true;
                
                const opacity = 1.0 - THREE.MathUtils.smoothstep(distance, 40, 100);
                this.material.uniforms.opacity.value = opacity * 0.8;
                this.material.uniforms.time.value += deltaTime;
            }
            
            hide() { 
                this.material.uniforms.opacity.value = 0; 
            }
            
            dispose() {
                this.geometry.dispose();
                this.material.dispose();
                scene.remove(this.mesh);
            }
        }

        // --- Physics & Merger Logic ---
        function updatePhysics(deltaTime) {
            if (mergerTime < 0 && blackHoles.length > 1) {
                // Pre-merger physics
                simulationTime += deltaTime;
                
                const bh1 = blackHoles[0], bh2 = blackHoles[1];
                const distanceVec = new THREE.Vector3().subVectors(bh2.position, bh1.position);
                const distance = distanceVec.length();
                
                updateInfoDisplay(distance);
                
                const progress = 1.0 - (distance / initialDistance);
                document.getElementById('progressBar').style.width = `${progress * 100}%`;
                
                const phaseEl = document.getElementById('phase');
                if (distance < 30) {
                    phaseEl.textContent = 'MERGER PHASE';
                    phaseEl.style.color = '#f472b6'; // pink-400
                } else if (distance < 50) {
                    phaseEl.textContent = 'FINAL INSPIRAL';
                    phaseEl.style.color = '#f59e0b'; // amber-500
                }
                
                if (distance < bh1.radius + bh2.radius) { 
                    mergeBlackHoles(); 
                    return; 
                }
                
                // Newtonian gravity
                const forceMag = G * (bh1.mass * bh2.mass) / (distance * distance);
                const forceVec = distanceVec.normalize().multiplyScalar(forceMag);
                
                bh1.velocity.add(forceVec.clone().divideScalar(bh1.mass).multiplyScalar(deltaTime));
                bh2.velocity.add(forceVec.clone().multiplyScalar(-1).divideScalar(bh2.mass).multiplyScalar(deltaTime));
                
                // GW energy loss (orbital decay)
                const totalMass = bh1.mass + bh2.mass;
                const v = Math.sqrt(G * totalMass / distance);
                const mu = (bh1.mass * bh2.mass) / totalMass;
                const gwLuminosity = (32/5) * Math.pow(G, 4) * Math.pow(mu, 2) * Math.pow(totalMass, 3) / Math.pow(distance, 5);
                const energyLoss = gwLuminosity * deltaTime * 0.000005;
                const decayRate = energyLoss / (mu * v * v) + params.orbitalDecay * deltaTime;
                
                const decayVec = distanceVec.clone().normalize().multiplyScalar(-decayRate);
                bh1.position.add(decayVec.clone().multiplyScalar(bh2.mass / totalMass));
                bh2.position.add(decayVec.clone().multiplyScalar(-bh1.mass / totalMass));
                
                // Update tidal forces for disk deformation
                const tidalForceOn1 = forceVec.clone().multiplyScalar(1 / (distance * distance * 1000));
                bh1.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1);
                bh2.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1.negate());

                massStream.update(bh1.position, bh2.position, bh1.velocity, distance, deltaTime);
            }
            
            blackHoles.forEach(bh => bh.update(deltaTime));
            spacetimeGrid.update(blackHoles, deltaTime);
        }
        
        function updateInfoDisplay(distance) {
            if (!params.showInfo) return;
            const infoPanel = document.getElementById('info-panel');
            if (!infoPanel) return;

            if (blackHoles.length > 1) {
                const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(distance, 3) / (G * totalMass));
                const kineticEnergy = 0.5 * blackHoles[0].mass * blackHoles[0].velocity.lengthSq() + 
                                      0.5 * blackHoles[1].mass * blackHoles[1].velocity.lengthSq();
                const potentialEnergy = -G * blackHoles[0].mass * blackHoles[1].mass / distance;
                const totalEnergy = kineticEnergy + potentialEnergy;
                const gwFrequency = 2 / orbitalPeriod;
                
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">${distance.toFixed(1)} Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">${orbitalPeriod.toFixed(2)} s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">${totalEnergy.toFixed(0)} E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">${gwFrequency.toFixed(3)} Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">${simulationTime.toFixed(1)} s</span>
                    </div>`;
            } else if (blackHoles.length === 1) {
                const bh = blackHoles[0];
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">Remnant Black Hole</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Status:</span> <span class="text-green-400 font-bold text-right">Ringdown</span>
                        <span class="text-gray-400">Mass:</span> <span class="text-cyan-300 font-bold text-right">${bh.mass.toFixed(1)} M☉</span>
                        <span class="text-gray-400">Spin:</span> <span class="text-cyan-300 font-bold text-right">${bh.spinMagnitude.toFixed(2)} a/M</span>
                        <span class="text-gray-400">Kick Vel:</span> <span class="text-cyan-300 font-bold text-right">${bh.velocity.length().toFixed(1)} km/s</span>
                    </div>`;
            }
        }
        
        function mergeBlackHoles() {
            simulationActive = false; 
            massStream.hide();
            mergerTime = simulationTime;
            
            const bh1 = blackHoles[0], bh2 = blackHoles[1];
            const newMass = (bh1.mass + bh2.mass) * 0.95; // 5% radiated as GWs
            const newPosition = new THREE.Vector3().addVectors(
                bh1.position.clone().multiplyScalar(bh1.mass), 
                bh2.position.clone().multiplyScalar(bh2.mass)
            ).divideScalar(bh1.mass + bh2.mass);
            
            // GW recoil kick
            const kickVelocity = new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5
            );
            
            triggerGravitationalWave(newPosition); 
            triggerBloomFlash(30.0);
            triggerGodRayFlash(newPosition);
            if (params.cameraShake) triggerCameraShake(1.0, newMass / 50);
            
            createMergerFlash(newPosition);
            spacetimeGrid.triggerWave(newPosition, 0.5);
            
            // Play merger sound if enabled
            if (params.playSound) {
                document.getElementById('mergerSound').play();
            }
            
            bh1.dispose();
            bh2.dispose();
            
            const mergedBH = new BlackHole(newMass, newPosition, kickVelocity, true);
            mergedBH.isMerged = true;
            mergedBH.spinMagnitude = params.finalSpin;
            mergedBH.precessionAxis = new THREE.Vector3(Math.random() - 0.5, 1, Math.random() - 0.5).normalize();
            mergedBH.diskMaterial.uniforms.emissiveIntensity.value = 10.0;
            mergedBH.diskMaterial.uniforms.temperature.value = 2.0;
            mergedBH.diskMaterial.uniforms.ringdown.value = 1.0; // Start ringdown effect
            blackHoles = [mergedBH];
            
            createJets(mergedBH);
            
            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'RINGDOWN PHASE';
            phaseEl.style.color = '#4ade80'; // green-400
            document.getElementById('progressBar').style.width = '100%';
        }
        
        function createMergerFlash(position) {
            // Particle burst
            createParticleBurst(position);
        }
        
        function createParticleBurst(position) {
            const burstCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(burstCount * 3);
            const velocities = new Float32Array(burstCount * 3);
            const customColors = new Float32Array(burstCount * 3);
            
            for(let i = 0; i < burstCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const speed = 20 + Math.random() * 30;
                
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                velocities[i * 3] = Math.sin(phi) * Math.cos(theta) * speed;
                velocities[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * speed;
                velocities[i * 3 + 2] = Math.cos(phi) * speed;
                
                const color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.6, 1.0, 0.5);
                customColors[i * 3] = color.r;
                customColors[i * 3 + 1] = color.g;
                customColors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            const burst = new THREE.Points(geometry, material);
            burst.userData.type = 'burst';
            scene.add(burst);
            particleSystems.push(burst);
        }

        // --- Ultra HD Jet Creation ---
        function createJets(parentBH) {
            const jetLength = 800;
            const jetRadius = parentBH.radius * 0.15;
            
            // Jet shader material
            const jetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 1.0 },
                    jetLength: { value: jetLength },
                    primaryColor: { value: new THREE.Color(0x4444ff) },
                    secondaryColor: { value: new THREE.Color(0xff44ff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vY = position.y;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }`,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    uniform float jetLength;
                    uniform vec3 primaryColor;
                    uniform vec3 secondaryColor;
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453);
                    }
                    
                    void main() {
                        float height = abs(vY) / jetLength;
                        
                        // Jet structure
                        float radialFade = 1.0 - smoothstep(0.0, 1.0, vUv.x);
                        float heightFade = 1.0 - smoothstep(0.3, 1.0, height);
                        
                        // Pulsing waves
                        float pulse1 = sin(vY * 0.05 - time * 5.0) * 0.5 + 0.5;
                        float pulse2 = sin(vY * 0.08 + time * 3.0) * 0.5 + 0.5;
                        float combinedPulse = pulse1 * 0.7 + pulse2 * 0.3;
                        
                        // Turbulence
                        float turb = noise(vPosition * 0.1 + time);
                        
                        // Color mixing
                        vec3 color = mix(primaryColor, secondaryColor, combinedPulse + turb * 0.2);
                        color = mix(color, vec3(1.0), heightFade * 0.3);
                        
                        // Shock fronts
                        float shock = step(0.98, sin(vY * 0.02 - time * 2.0));
                        color += vec3(0.5, 0.3, 0.8) * shock;

                        // Brighter Core
                        float coreBrightness = pow(1.0 - vUv.x, 10.0);
                        color += vec3(1.0, 1.0, 1.5) * coreBrightness * 2.0;
                        
                        float alpha = opacity * radialFade * heightFade * (0.5 + combinedPulse * 0.5);
                        
                        gl_FragColor = vec4(color, alpha);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            // Create tapered jet geometry
            const jetGeometry = new THREE.CylinderGeometry(jetRadius, jetRadius * 0.1, jetLength, 32, 32, true);
            
            // Add twist to geometry
            const positions = jetGeometry.attributes.position.array;
            for(let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                const angle = y * 0.01;
                const x = positions[i];
                const z = positions[i + 2];
                positions[i] = x * Math.cos(angle) - z * Math.sin(angle);
                positions[i + 2] = x * Math.sin(angle) + z * Math.cos(angle);
            }
            jetGeometry.attributes.position.needsUpdate = true;
            
            const jetTop = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetTop.position.y = jetLength / 2;
            
            const jetBottom = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetBottom.position.y = -jetLength / 2;
            jetBottom.rotation.x = Math.PI;
            
            parentBH.group.add(jetTop, jetBottom);
            jets = [jetTop, jetBottom];
            
            // Jet particles
            createJetParticles(parentBH, jetLength);
        }
        
        function createJetParticles(parentBH, jetLength) {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const isTop = i < particleCount / 2;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * parentBH.radius * 0.15;
                const height = Math.random() * jetLength;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = isTop ? height : -height;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                const speed = 3 + Math.random() * 2;
                velocities[i * 3] = (Math.random() - 0.5) * 0.2;
                velocities[i * 3 + 1] = isTop ? speed : -speed;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                
                lifetimes[i] = Math.random();
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    jetLength: { value: jetLength }
                },
                vertexShader: `
                    attribute float lifetime;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vLifetime = lifetime;
                        vHeight = abs(position.y) / ${jetLength.toFixed(1)};
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (1.0 + vHeight * 3.0) * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }`,
                fragmentShader: `
                    uniform float time;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        if(dist > 0.5) discard;
                        
                        float opacity = smoothstep(0.5, 0.0, dist) * vLifetime * (1.0 - vHeight * 0.5);
                        vec3 color = mix(vec3(0.4, 0.4, 1.0), vec3(1.0, 0.4, 1.0), vHeight);
                        color += vec3(0.2) * (1.0 + sin(time * 10.0 + vHeight * 20.0));
                        
                        gl_FragColor = vec4(color, opacity);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const jetParticles = new THREE.Points(geometry, material);
            jetParticles.userData.type = 'jet';
            jetParticles.userData.parentBH = parentBH;
            parentBH.group.add(jetParticles);
            particleSystems.push(jetParticles);
        }

        // --- Post-Processing Pipeline ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // Gravitational Lensing Pass
        const lensingPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null }, 
                resolution: { value: new THREE.Vector2() }, 
                aspect: { value: 1.0 },
                bhPositions: { value: Array(10).fill(0).map(() => new THREE.Vector2()) },
                bhMasses: { value: new Float32Array(10) }, 
                bhCount: { value: 0 },
                strength: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform vec2 resolution; 
                uniform float aspect;
                uniform vec2 bhPositions[10]; 
                uniform float bhMasses[10]; 
                uniform int bhCount; 
                uniform float strength;
                varying vec2 vUv;
                
                vec2 computeLensing(vec2 uv) {
                    vec2 totalOffset = vec2(0.0);
                    
                    for (int i = 0; i < 10; i++) {
                        if (i >= bhCount) break;
                        
                        vec2 pos = uv - bhPositions[i]; 
                        pos.x *= aspect;
                        float dist = length(pos);
                        
                        // Einstein ring radius approximation
                        float einsteinRadius = sqrt(bhMasses[i] * 0.0005 * strength);
                        float deflection = einsteinRadius * einsteinRadius / (dist + 0.0001);
                        
                        totalOffset += normalize(pos) * deflection;
                    }
                    
                    totalOffset.x /= aspect;
                    return totalOffset;
                }
                
                void main() {
                    vec2 offset = computeLensing(vUv);
                    
                    // Chromatic aberration for strong lensing
                    float aberration = length(offset) * 3.0;
                    
                    vec3 color;
                    color.r = texture2D(tDiffuse, vUv - offset * (1.0 + aberration * 0.1)).r;
                    color.g = texture2D(tDiffuse, vUv - offset).g;
                    color.b = texture2D(tDiffuse, vUv - offset * (1.0 - aberration * 0.1)).b;
                    
                    // Edge darkening for extreme lensing
                    float edgeDark = 1.0 - smoothstep(0.0, 0.05, length(offset));
                    color *= edgeDark;
                    
                    gl_FragColor = vec4(color, 1.0);
                }`
        });
        lensingPass.uniforms.strength.value = params.lensingStrength;
        composer.addPass(lensingPass);
        
        // Gravitational Wave Pass
        const wavePass = new ShaderPass({
             uniforms: { 
                tDiffuse: { value: null }, 
                time: { value: -1.0 }, 
                origin: { value: new THREE.Vector2() }, 
                amplitude: { value: 0.0 },
                frequency: { value: 50.0 },
                decay: { value: 2.0 }
            },
             vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
             fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform float time, amplitude, frequency, decay; 
                uniform vec2 origin; 
                varying vec2 vUv;
                
                void main() {
                    float dist = distance(vUv, origin);
                    
                    // Gravitational wave strain pattern
                    float strain = sin(dist * frequency - time * 15.0) * amplitude;
                    strain *= exp(-dist * decay) * exp(-time * 2.0);
                    strain *= smoothstep(0.0, 0.1, time) * (1.0 - smoothstep(0.7, 1.0, time));
                    
                    // Plus and cross polarizations
                    vec2 dir = normalize(vUv - origin);
                    vec2 perpDir = vec2(-dir.y, dir.x);
                    
                    vec2 plusPol = dir * strain;
                    vec2 crossPol = perpDir * strain * 0.5;
                    
                    vec2 totalOffset = plusPol + crossPol;
                    
                    vec4 color = texture2D(tDiffuse, vUv + totalOffset);
                    
                    // Wave visualization
                    float waveVis = abs(strain) * 15.0;
                    color.rgb += vec3(0.1, 0.05, 0.2) * waveVis;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(wavePass);

        // God-ray / Radial Blur pass for merger flash
        const godRayPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
                exposure: { value: 1.0 },
                decay: { value: 0.95 },
                density: { value: 0.5 },
                weight: { value: 0.4 },
                samples: { value: 60 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 lightPosition;
                uniform float exposure;
                uniform float decay;
                uniform float density;
                uniform float weight;
                uniform int samples;
                varying vec2 vUv;

                void main() {
                    vec2 delta = vUv - lightPosition;
                    delta *= 1.0 / float(samples) * density;
                    float illuminationDecay = 1.0;
                    vec4 color = texture2D(tDiffuse, vUv);

                    for (int i = 0; i < samples; i++) {
                        vUv -= delta;
                        vec4 sampleColor = texture2D(tDiffuse, vUv);
                        sampleColor *= illuminationDecay * weight;
                        color += sampleColor;
                        illuminationDecay *= decay;
                    }
                    gl_FragColor = color * exposure;
                }`
        });
        godRayPass.enabled = false;
        composer.addPass(godRayPass);
        
        // Enhanced Bloom Pass
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            params.bloomIntensity, 
            0.4, 
            0.1
        );
        bloomPass.threshold = 0.1;
        bloomPass.radius = 1.0;
        composer.addPass(bloomPass);
        
        // SMAA Anti-aliasing Pass (should be one of the last passes before final color correction)
        const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);
        composer.addPass(smaaPass);

        // Color Correction Pass
        const colorCorrectionPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                exposure: { value: 1.0 },
                contrast: { value: 1.1 },
                saturation: { value: 1.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float exposure;
                uniform float contrast;
                uniform float saturation;
                varying vec2 vUv;
                
                vec3 adjustSaturation(vec3 color, float sat) {
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    return mix(vec3(gray), color, sat);
                }
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    
                    // Exposure
                    color.rgb *= exposure;
                    
                    // Contrast
                    color.rgb = (color.rgb - 0.5) * contrast + 0.5;
                    
                    // Saturation
                    color.rgb = adjustSaturation(color.rgb, saturation);
                    
                    // Vignette
                    float vignette = smoothstep(1.0, 0.4, length(vUv - 0.5));
                    color.rgb *= vignette;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(colorCorrectionPass);

        // --- GUI Configuration ---
        const gui = new GUI();
        
        const setupFolder = gui.addFolder('System Setup');
        const mass1Controller = setupFolder.add(params, 'mass1', 10, 150).name('Mass 1 (M☉)');
        const mass2Controller = setupFolder.add(params, 'mass2', 10, 150).name('Mass 2 (M☉)');
        const distanceController = setupFolder.add(params, 'distance', 50, 200).name('Initial Distance');
        setupFolder.add(params, 'start').name('🚀 Launch Simulation');
        
        const presetsFolder = gui.addFolder('Presets');
        presetsFolder.add(params, 'preset1').name('Asymmetric Merger');
        presetsFolder.add(params, 'preset2').name('Equal Mass');
        presetsFolder.add(params, 'preset3').name('Extreme Mass Ratio');
        presetsFolder.add(params, 'preset4').name('Massive Merger');
        
        const directorFolder = gui.addFolder('Director Controls');
        const timeScaleController = directorFolder.add(params, 'timeScale', 0.1, 5.0).name('Time Scale');
        const cinematicController = directorFolder.add(params, 'cinematicCamera').name('Cinematic Camera');
        directorFolder.add(params, 'focusBH1').name('Focus on Black Hole 1');
        directorFolder.add(params, 'focusBH2').name('Focus on Black Hole 2');
        directorFolder.add(params, 'focusCenter').name('Focus on Center');
        directorFolder.add(params, 'resetCamera').name('Reset Camera');

        const visualFolder = gui.addFolder('Visual Controls');
        visualFolder.add(params, 'diskEmissivity', 0, 10).name('Disk Brightness').onChange(v => {
            blackHoles.forEach(bh => bh.diskMaterial.uniforms.emissiveIntensity.value = v);
        });
        visualFolder.add(params, 'bloomIntensity', 0, 5).name('Bloom Intensity').onChange(v => bloomPass.strength = v);
        const gridController = visualFolder.add(params, 'showGrid').name('Show Spacetime Grid').onChange(v => {
            spacetimeGrid.group.visible = v;
        });
        const infoController = visualFolder.add(params, 'showInfo').name('Show Info Display').onChange(v => {
            document.getElementById('info-panel').style.opacity = v ? '1' : '0';
        });
        visualFolder.add(params, 'particleDensity', 0, 3).name('Particle Density').onChange(v => {
             particleSystems.forEach(ps => {
                if (ps.userData.type === 'accretion') {
                    ps.material.uniforms.opacity.value = v;
                }
             });
        });
        visualFolder.add(starfieldMaterial.uniforms.nebulaDensity, 'value', 0, 5).name('Nebula Density');
        visualFolder.add(starfieldMaterial.uniforms.starDensity, 'value', 0, 5).name('Star Density');
        
        const advancedFolder = gui.addFolder('Advanced Physics');
        advancedFolder.add(params, 'orbitalDecay', 0, 0.02).name('Orbital Decay Rate');
        advancedFolder.add(params, 'finalSpin', 0, 0.98, 0.01).name('Final BH Spin (a/M)');
        advancedFolder.add(params, 'cameraShake').name('Camera Shake');
        advancedFolder.add(params, 'lensingStrength', 0, 2).name('Lensing Strength').onChange(v => {
            lensingPass.uniforms.strength.value = v;
        });
        advancedFolder.add(params, 'playSound').name('Play Merger Sound');
        
        const postProcessFolder = gui.addFolder('Post Processing');
        postProcessFolder.add(colorCorrectionPass.uniforms.exposure, 'value', 0.5, 2).name('Exposure');
        postProcessFolder.add(colorCorrectionPass.uniforms.contrast, 'value', 0.5, 2).name('Contrast');
        postProcessFolder.add(colorCorrectionPass.uniforms.saturation, 'value', 0, 2).name('Saturation');
        
        const qualityFolder = gui.addFolder('Performance');
        qualityFolder.add(params, 'quality', ['low', 'medium', 'high', 'ultra']).name('Quality').onChange(updateQuality);

        // --- UI & Controls Setup ---
        const controlsContainer = document.getElementById('controls');
        const pauseIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`;
        const playIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
        
        const controlButtons = [
            { id: 'restart-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>`, action: () => initSimulation(), title: 'Restart (R)' },
            { id: 'pause-btn', icon: pauseIcon, action: togglePause, title: 'Pause/Play (Space)' },
            { id: 'cinematic-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg>`, action: toggleCinematic, title: 'Cinematic Camera (C)' },
            { id: 'grid-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`, action: toggleGrid, title: 'Toggle Grid (G)' },
            { id: 'info-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`, action: toggleInfo, title: 'Toggle Info (I)' },
        ];

        controlButtons.forEach(btnInfo => {
            const button = document.createElement('button');
            button.id = btnInfo.id;
            button.innerHTML = btnInfo.icon;
            button.title = btnInfo.title;
            button.className = "p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all";
            button.addEventListener('click', btnInfo.action);
            controlsContainer.appendChild(button);
        });

        function togglePause() {
            params.isPaused = !params.isPaused;
            document.getElementById('pause-btn').innerHTML = params.isPaused ? playIcon : pauseIcon;
        }
        function toggleCinematic() {
            params.cinematicCamera = !params.cinematicCamera;
            cinematicController.updateDisplay();
        }
        function toggleGrid() {
            params.showGrid = !params.showGrid;
            spacetimeGrid.group.visible = params.showGrid;
            gridController.updateDisplay();
        }
        function toggleInfo() {
            params.showInfo = !params.showInfo;
            document.getElementById('info-panel').style.opacity = params.showInfo ? '1' : '0';
            infoController.updateDisplay();
        }

        function initSimulation() {
            // Clear previous simulation objects
            blackHoles.forEach(bh => bh.dispose());
            if (massStream) massStream.dispose();
            particleSystems.forEach(ps => {
                scene.remove(ps);
                ps.geometry.dispose();
                ps.material.dispose();
            });
            particleSystems = [];
            jets = [];
            blackHoles = [];
            
            simulationTime = 0;
            mergerTime = -1;
            simulationActive = true;

            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'INSPIRAL';
            phaseEl.style.color = '#22d3ee'; // cyan-400
            document.getElementById('progressBar').style.width = '0%';
            
            const m1 = params.mass1, m2 = params.mass2, dist = params.distance;
            initialDistance = dist;
            const totalMass = m1 + m2;
            
            // Circular orbit velocities
            const v = Math.sqrt(G * totalMass / dist);
            const v1 = v * m2 / totalMass;
            const v2 = v * m1 / totalMass;
            
            // Initial positions (center of mass at origin)
            const r1 = dist * m2 / totalMass;
            const r2 = dist * m1 / totalMass;
            
            const bh1 = new BlackHole(m1, new THREE.Vector3(-r1, 0, 0), new THREE.Vector3(0, 0, -v1), true);
            const bh2 = new BlackHole(m2, new THREE.Vector3(r2, 0, 0), new THREE.Vector3(0, 0, v2), false);
            
            blackHoles.push(bh1, bh2);
            massStream = new MassStream();
            wavePass.uniforms.time.value = -1.0;
            godRayPass.enabled = false;
            setCameraFocus(-1);
        }
        
        function applyPreset(m1, m2, d) {
            params.mass1 = m1;
            params.mass2 = m2;
            params.distance = d;
            mass1Controller.updateDisplay();
            mass2Controller.updateDisplay();
            distanceController.updateDisplay();
            initSimulation();
        }
        
        function updateQuality(quality) {
            let pixelRatio = 1;
            let samples = 30;
            switch(quality) {
                case 'low':
                    pixelRatio = 1;
                    samples = 30;
                    break;
                case 'medium':
                    pixelRatio = Math.min(window.devicePixelRatio, 1.5);
                    samples = 60;
                    break;
                case 'high':
                case 'ultra':
                    pixelRatio = Math.min(window.devicePixelRatio, 2);
                    samples = 80;
                    break;
            }
            renderer.setPixelRatio(pixelRatio);
            composer.setPixelRatio(pixelRatio);
            godRayPass.uniforms.samples.value = samples;
        }
        
        // --- Camera and Effects Management ---
        let shakeDuration = 0, shakeIntensity = 0;
        function triggerCameraShake(duration = 0.5, intensity = 0.5) { 
            shakeDuration = duration; 
            shakeIntensity = intensity; 
        }
        
        function updateCameraShake(deltaTime) { 
            if (shakeDuration > 0) { 
                shakeDuration -= deltaTime;
                const shake = shakeIntensity * (shakeDuration / 0.5); // Fade out
                camera.position.x += (Math.random() - 0.5) * shake; 
                camera.position.y += (Math.random() - 0.5) * shake;
                camera.position.z += (Math.random() - 0.5) * shake * 0.5;
            } 
        }
        
        function triggerGravitationalWave(origin) { 
            const screenPos = origin.clone().project(camera); 
            wavePass.uniforms.origin.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2); 
            wavePass.uniforms.time.value = 0.0; 
            wavePass.uniforms.amplitude.value = 0.04; 
        }
        
        function triggerBloomFlash(strength) { 
            let flashStrength = strength; 
            const flashInterval = setInterval(() => { 
                bloomPass.strength = flashStrength; 
                flashStrength *= 0.9;
                if (flashStrength <= params.bloomIntensity) { 
                    bloomPass.strength = params.bloomIntensity; 
                    clearInterval(flashInterval); 
                } 
            }, 16); 
        }

        function triggerGodRayFlash(origin) {
            const screenPos = origin.clone().project(camera);
            godRayPass.enabled = true;
            godRayPass.uniforms.lightPosition.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2);
            godRayPass.uniforms.exposure.value = 1.0;
        }
        
        let focusIndex = -1;
        function setCameraFocus(index) {
            focusIndex = index;
            params.cinematicCamera = false;
            cinematicController.updateDisplay();
        }

        function updateCamera(time) {
            if (params.cinematicCamera) {
                const phase = (time * 0.05) % (Math.PI * 2);
                const radius = 120 + Math.sin(phase * 2) * 30;
                const height = 50 + Math.sin(phase * 3) * 20;
                
                camera.position.x = Math.cos(phase) * radius;
                camera.position.z = Math.sin(phase) * radius;
                camera.position.y = height;
                
                const lookAhead = 0.1;
                const lookX = Math.cos(phase + lookAhead) * radius * 0.3;
                const lookZ = Math.sin(phase + lookAhead) * radius * 0.3;
                controls.target.set(lookX, 0, lookZ);
            } else {
                let targetPos = new THREE.Vector3();
                if (focusIndex === -1 && blackHoles.length > 1) {
                    const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                    targetPos.addScaledVector(blackHoles[0].position, blackHoles[0].mass / totalMass);
                    targetPos.addScaledVector(blackHoles[1].position, blackHoles[1].mass / totalMass);
                } else if (focusIndex >= 0 && blackHoles[focusIndex]) {
                    targetPos.copy(blackHoles[focusIndex].position);
                } else if (blackHoles.length === 1) {
                    targetPos.copy(blackHoles[0].position);
                }
                cameraTarget.position.lerp(targetPos, 0.1);
                controls.target.lerp(cameraTarget.position, 0.1);
            }
        }
        
        // --- Centralized Particle System Update ---
        function updateAllParticleSystems(deltaTime) {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const system = particleSystems[i];
                const type = system.userData.type;

                if (type === 'accretion') {
                    const bh = system.userData.parentBH;
                    if (!bh) continue;

                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    const lifetimes = system.geometry.attributes.lifetime.array;
                    const colors = system.geometry.attributes.customColor.array;
                    
                    for (let j = 0; j < lifetimes.length; j++) {
                        lifetimes[j] -= deltaTime * 0.1;
                        
                        if (lifetimes[j] <= 0) {
                            // Respawn
                            const angle = Math.random() * Math.PI * 2;
                            const radius = bh.radius * 1.5 + Math.random() * bh.radius * 2.5;
                            
                            positions[j * 3] = Math.cos(angle) * radius;
                            positions[j * 3 + 1] = (Math.random() - 0.5) * 2;
                            positions[j * 3 + 2] = Math.sin(angle) * radius;
                            
                            lifetimes[j] = 1.0;
                        } else {
                            // Update position with gravity
                            const x = positions[j * 3];
                            const y = positions[j * 3 + 1];
                            const z = positions[j * 3 + 2];
                            const r = Math.sqrt(x * x + z * z);
                            
                            // Gravitational acceleration
                            const accel = -G * bh.mass / (r * r);
                            velocities[j * 3] += (x / r) * accel * deltaTime;
                            velocities[j * 3 + 2] += (z / r) * accel * deltaTime;
                            
                            positions[j * 3] += velocities[j * 3] * deltaTime;
                            positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                            positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        }
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.geometry.attributes.lifetime.needsUpdate = true;
                    system.material.uniforms.opacity.value = params.particleDensity;
                } else if (type === 'jet') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for (let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                } else if (type === 'burst') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for(let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        velocities[j * 3] *= 0.99;
                        velocities[j * 3 + 1] *= 0.99;
                        velocities[j * 3 + 2] *= 0.99;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.material.opacity -= deltaTime * 0.5;
                    if (system.material.opacity <= 0) {
                        scene.remove(system);
                        system.geometry.dispose();
                        system.material.dispose();
                        particleSystems.splice(i, 1);
                    }
                }
                if (system.material.uniforms && system.material.uniforms.time) {
                    system.material.uniforms.time.value += deltaTime;
                }
            }
        }

        // --- Main Animation Loop ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const effectiveDeltaTime = clock.getDelta();
            const timeScale = params.isPaused ? 0 : params.timeScale;
            const deltaTime = effectiveDeltaTime * timeScale;
            const elapsedTime = clock.getElapsedTime();
            
            // Update simulation
            updatePhysics(deltaTime);
            if (!params.cinematicCamera) controls.update();
            updateCamera(elapsedTime);
            updateCameraShake(deltaTime);
            updateAllParticleSystems(deltaTime);
            
            // Update background
            starfieldMaterial.uniforms.time.value = elapsedTime;
            
            // Update post-merger effects
            if (mergerTime > 0 && blackHoles.length === 1) {
                const bh = blackHoles[0];
                const precessionQuaternion = new THREE.Quaternion().setFromAxisAngle(bh.precessionAxis, deltaTime * bh.spinMagnitude * 0.1);
                bh.group.quaternion.premultiply(precessionQuaternion);
                
                jets.forEach(jet => {
                    if (jet.material.uniforms.opacity.value > 0) {
                        jet.material.uniforms.opacity.value *= 0.995;
                    }
                    if (jet.material.uniforms.time) {
                        jet.material.uniforms.time.value = elapsedTime;
                    }
                });

                if (bh.diskMaterial.uniforms.ringdown.value > 0.001) {
                    bh.diskMaterial.uniforms.ringdown.value *= (1.0 - 0.8 * effectiveDeltaTime);
                } else {
                    bh.diskMaterial.uniforms.ringdown.value = 0.0;
                }
                updateInfoDisplay();
            }

            // Update lensing positions
            const screenPositions = blackHoles.map(bh => {
                const pos = bh.group.position.clone();
                pos.project(camera);
                return pos;
            });
            
            for (let i = 0; i < 10; i++) {
                if (i < blackHoles.length) {
                    lensingPass.uniforms.bhPositions.value[i].set(
                        (screenPositions[i].x + 1) / 2, 
                        (screenPositions[i].y + 1) / 2
                    );
                    lensingPass.uniforms.bhMasses.value[i] = blackHoles[i].mass;
                } else {
                    lensingPass.uniforms.bhPositions.value[i].set(-10, -10);
                    lensingPass.uniforms.bhMasses.value[i] = 0;
                }
            }
            lensingPass.uniforms.bhCount.value = blackHoles.length;
            lensingPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspect.value = window.innerWidth / window.innerHeight;
            
            // Update gravitational wave effect
            if (wavePass.uniforms.time.value >= 0) {
                wavePass.uniforms.time.value += deltaTime;
                if (wavePass.uniforms.time.value > 1.0) {
                    wavePass.uniforms.time.value = -1.0;
                }
            }

            // Update God Ray effect
            if (godRayPass.enabled) {
                godRayPass.uniforms.exposure.value *= (1.0 - 1.5 * effectiveDeltaTime);
                if (godRayPass.uniforms.exposure.value < 0.01) {
                    godRayPass.enabled = false;
                }
            }

            // Render
            composer.render();
        }
        
        // Start simulation
        const loader = document.getElementById('loader');
        initSimulation();
        animate();
        loader.style.opacity = '0';
        setTimeout(() => loader.style.display = 'none', 500);


        // --- Window Resize Handler ---
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
            composer.setSize(width, height);
            
            lensingPass.uniforms.resolution.value.set(width, height);
            lensingPass.uniforms.aspect.value = width / height;
            
            smaaPass.setSize(width, height);
            
            updateQuality(params.quality);
        });
        
        // --- Keyboard Controls ---
        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    togglePause();
                    break;
                case 'c': toggleCinematic(); break;
                case 'g': toggleGrid(); break;
                case 'i': toggleInfo(); break;
                case 'r': initSimulation(); break;
            }
        });
    </script>

<canvas data-engine="three.js r178" width="2704" height="410" style="display: block; width: 1352px; height: 205px; touch-action: none;"></canvas><div class="lil-gui allow-touch-styles root autoPlace"><div class="title" role="button" aria-expanded="true" tabindex="0">Controls</div><div class="children"><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Presets</div><div class="children"><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-5">Asymmetric Merger</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-6">Equal Mass</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-7">Extreme Mass Ratio</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-8">Massive Merger</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Director Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-9">Time Scale</div><div class="widget"><div class="slider"><div class="fill" style="width: 18.367347%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-9"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-10">Cinematic Camera</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-10"></label></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-11">Focus on Black Hole 1</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-12">Focus on Black Hole 2</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-13">Focus on Center</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-14">Reset Camera</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Visual Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-15">Disk Brightness</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-15"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-16">Bloom Intensity</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-16"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-17">Show Spacetime Grid</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-17"></label></div><div class="controller boolean"><div class="name" id="lil-gui-name-18">Show Info Display</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-18"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-19">Particle Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-19"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-20">Nebula Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-20"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-21">Star Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-21"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Advanced Physics</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-22">Orbital Decay Rate</div><div class="widget"><div class="slider"><div class="fill" style="width: 25%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-22"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-23">Final BH Spin (a/M)</div><div class="widget"><div class="slider"><div class="fill" style="width: 91.836735%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-23"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-24">Camera Shake</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-24"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-25">Lensing Strength</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-25"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-26">Play Merger Sound</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-26"></label></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Post Processing</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-27">Exposure</div><div class="widget"><div class="slider"><div class="fill" style="width: 33.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-27"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-28">Contrast</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-28"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-29">Saturation</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-29"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Performance</div><div class="children"><div class="controller option"><div class="name" id="lil-gui-name-30">Quality</div><div class="widget"><select aria-labelledby="lil-gui-name-30"><option>low</option><option>medium</option><option>high</option><option>ultra</option></select><div class="display">ultra</div></div></div></div></div></div></div></body>
<html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Black Hole Merger - Enhanced Edition v3</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a cleaner look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <style>.lil-gui{--background-color:#1f1f1f;--text-color:#ebebeb;--title-background-color:#111;--title-text-color:#ebebeb;--widget-color:#424242;--hover-color:#4f4f4f;--focus-color:#595959;--number-color:#2cc9ff;--string-color:#a2db3c;--font-size:11px;--input-font-size:11px;--font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;--font-family-mono:Menlo,Monaco,Consolas,"Droid Sans Mono",monospace;--padding:4px;--spacing:4px;--widget-height:20px;--name-width:45%;--slider-knob-width:2px;--slider-input-width:27%;--color-input-width:27%;--slider-input-min-width:45px;--color-input-min-width:45px;--folder-indent:7px;--widget-padding:0 0 0 3px;--widget-border-radius:2px;--checkbox-size:calc(var(--widget-height)*0.75);--scrollbar-width:5px;background-color:var(--background-color);color:var(--text-color);font-family:var(--font-family);font-size:var(--font-size);font-style:normal;font-weight:400;line-height:1;text-align:left;touch-action:manipulation;user-select:none;-webkit-user-select:none}.lil-gui,.lil-gui *{box-sizing:border-box;margin:0;padding:0}.lil-gui.root{display:flex;flex-direction:column;width:var(--width,245px)}.lil-gui.root>.title{background:var(--title-background-color);color:var(--title-text-color)}.lil-gui.root>.children{overflow-x:hidden;overflow-y:auto}.lil-gui.root>.children::-webkit-scrollbar{background:var(--background-color);height:var(--scrollbar-width);width:var(--scrollbar-width)}.lil-gui.root>.children::-webkit-scrollbar-thumb{background:var(--focus-color);border-radius:var(--scrollbar-width)}.lil-gui.force-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}.lil-gui.autoPlace{max-height:100%;position:fixed;right:15px;top:0;z-index:1001}.lil-gui .controller{align-items:center;display:flex;margin:var(--spacing) 0;padding:0 var(--padding)}.lil-gui .controller.disabled{opacity:.5}.lil-gui .controller.disabled,.lil-gui .controller.disabled *{pointer-events:none!important}.lil-gui .controller>.name{flex-shrink:0;line-height:var(--widget-height);min-width:var(--name-width);padding-right:var(--spacing);white-space:pre}.lil-gui .controller .widget{align-items:center;display:flex;min-height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.string input{color:var(--string-color)}.lil-gui .controller.boolean .widget{cursor:pointer}.lil-gui .controller.color .display{border-radius:var(--widget-border-radius);height:var(--widget-height);position:relative;width:100%}.lil-gui .controller.color input[type=color]{cursor:pointer;height:100%;opacity:0;width:100%}.lil-gui .controller.color input[type=text]{flex-shrink:0;font-family:var(--font-family-mono);margin-left:var(--spacing);min-width:var(--color-input-min-width);width:var(--color-input-width)}.lil-gui .controller.option select{max-width:100%;opacity:0;position:absolute;width:100%}.lil-gui .controller.option .display{background:var(--widget-color);border-radius:var(--widget-border-radius);height:var(--widget-height);line-height:var(--widget-height);max-width:100%;overflow:hidden;padding-left:.55em;padding-right:1.75em;pointer-events:none;position:relative;word-break:break-all}.lil-gui .controller.option .display.active{background:var(--focus-color)}.lil-gui .controller.option .display:after{bottom:0;content:"↕";font-family:lil-gui;padding-right:.375em;position:absolute;right:0;top:0}.lil-gui .controller.option .widget,.lil-gui .controller.option select{cursor:pointer}.lil-gui .controller.number input{color:var(--number-color)}.lil-gui .controller.number.hasSlider input{flex-shrink:0;margin-left:var(--spacing);min-width:var(--slider-input-min-width);width:var(--slider-input-width)}.lil-gui .controller.number .slider{background-color:var(--widget-color);border-radius:var(--widget-border-radius);cursor:ew-resize;height:var(--widget-height);overflow:hidden;padding-right:var(--slider-knob-width);touch-action:pan-y;width:100%}.lil-gui .controller.number .slider.active{background-color:var(--focus-color)}.lil-gui .controller.number .slider.active .fill{opacity:.95}.lil-gui .controller.number .fill{border-right:var(--slider-knob-width) solid var(--number-color);box-sizing:content-box;height:100%}.lil-gui-dragging .lil-gui{--hover-color:var(--widget-color)}.lil-gui-dragging *{cursor:ew-resize!important}.lil-gui-dragging.lil-gui-vertical *{cursor:ns-resize!important}.lil-gui .title{--title-height:calc(var(--widget-height) + var(--spacing)*1.25);-webkit-tap-highlight-color:transparent;text-decoration-skip:objects;cursor:pointer;font-weight:600;height:var(--title-height);line-height:calc(var(--title-height) - 4px);outline:none;padding:0 var(--padding)}.lil-gui .title:before{content:"▾";display:inline-block;font-family:lil-gui;padding-right:2px}.lil-gui .title:active{background:var(--title-background-color);opacity:.75}.lil-gui.root>.title:focus{text-decoration:none!important}.lil-gui.closed>.title:before{content:"▸"}.lil-gui.closed>.children{opacity:0;transform:translateY(-7px)}.lil-gui.closed:not(.transition)>.children{display:none}.lil-gui.transition>.children{overflow:hidden;pointer-events:none;transition-duration:.3s;transition-property:height,opacity,transform;transition-timing-function:cubic-bezier(.2,.6,.35,1)}.lil-gui .children:empty:before{content:"Empty";display:block;font-style:italic;height:var(--widget-height);line-height:var(--widget-height);margin:var(--spacing) 0;opacity:.5;padding:0 var(--padding)}.lil-gui.root>.children>.lil-gui>.title{border-width:0;border-bottom:1px solid var(--widget-color);border-left:0 solid var(--widget-color);border-right:0 solid var(--widget-color);border-top:1px solid var(--widget-color);transition:border-color .3s}.lil-gui.root>.children>.lil-gui.closed>.title{border-bottom-color:transparent}.lil-gui+.controller{border-top:1px solid var(--widget-color);margin-top:0;padding-top:var(--spacing)}.lil-gui .lil-gui .lil-gui>.title{border:none}.lil-gui .lil-gui .lil-gui>.children{border:none;border-left:2px solid var(--widget-color);margin-left:var(--folder-indent)}.lil-gui .lil-gui .controller{border:none}.lil-gui input{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:0;border-radius:var(--widget-border-radius);color:var(--text-color);font-family:var(--font-family);font-size:var(--input-font-size);height:var(--widget-height);outline:none;width:100%}.lil-gui input:disabled{opacity:1}.lil-gui input[type=number],.lil-gui input[type=text]{padding:var(--widget-padding)}.lil-gui input[type=number]:focus,.lil-gui input[type=text]:focus{background:var(--focus-color)}.lil-gui input::-webkit-inner-spin-button,.lil-gui input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.lil-gui input[type=number]{-moz-appearance:textfield}.lil-gui input[type=checkbox]{appearance:none;-webkit-appearance:none;border-radius:var(--widget-border-radius);cursor:pointer;height:var(--checkbox-size);text-align:center;width:var(--checkbox-size)}.lil-gui input[type=checkbox]:checked:before{content:"✓";font-family:lil-gui;font-size:var(--checkbox-size);line-height:var(--checkbox-size)}.lil-gui button{-webkit-tap-highlight-color:transparent;background:var(--widget-color);border:1px solid var(--widget-color);border-radius:var(--widget-border-radius);color:var(--text-color);cursor:pointer;font-family:var(--font-family);font-size:var(--font-size);height:var(--widget-height);line-height:calc(var(--widget-height) - 4px);outline:none;text-align:center;text-transform:none;width:100%}.lil-gui button:active{background:var(--focus-color)}@font-face{font-family:lil-gui;src:url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff")}@media (pointer:coarse){.lil-gui.allow-touch-styles{--widget-height:28px;--padding:6px;--spacing:6px;--font-size:13px;--input-font-size:16px;--folder-indent:10px;--scrollbar-width:7px;--slider-input-min-width:50px;--color-input-min-width:65px}}@media (hover:hover){.lil-gui .controller.color .display:hover:before{border:1px solid #fff9;border-radius:var(--widget-border-radius);bottom:0;content:" ";display:block;left:0;position:absolute;right:0;top:0}.lil-gui .controller.option .display.focus{background:var(--focus-color)}.lil-gui .controller.option .widget:hover .display{background:var(--hover-color)}.lil-gui .controller.number .slider:hover{background-color:var(--hover-color)}body:not(.lil-gui-dragging) .lil-gui .title:hover{background:var(--title-background-color);opacity:.85}.lil-gui .title:focus{text-decoration:underline var(--focus-color)}.lil-gui input:hover{background:var(--hover-color)}.lil-gui input:active{background:var(--focus-color)}.lil-gui input[type=checkbox]:focus{box-shadow:inset 0 0 0 1px var(--focus-color)}.lil-gui button:hover{background:var(--hover-color);border-color:var(--hover-color)}.lil-gui button:focus{border-color:var(--focus-color)}}</style><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&amp;family=Roboto+Mono:wght@400;700&amp;display=swap" rel="stylesheet">
    <style>
        /* Basic body styles */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            color: #e5e7eb;
        }
        canvas { display: block; }

        /* Custom styles for lil-gui */
        .lil-gui {
            --font-size: 14px;
            --width: 320px;
            --background-color: rgba(0, 0, 0, 0.6);
            --widget-color: #a78bfa; /* violet-400 */
            --hover-color: #c4b5fd; /* violet-300 */
            --text-color: #e5e7eb; /* gray-200 */
            --font-family: 'Roboto Mono', monospace;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.5rem;
        }
        .lil-gui.root > .title {
            color: #fff;
            background-color: rgba(255,255,255,0.05);
        }
        .lil-gui .name {
            font-weight: 500;
        }
        .lil-gui .controller.boolean .label {
            border-left-color: rgba(255,255,255,0.2);
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            font-family: 'Roboto Mono', monospace;
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }
    </style>
    <!-- Using the latest stable version of Three.js as of July 2025 -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.178.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/"
        }
    }
    </script>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.16 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.pointer-events-none{pointer-events:none}.pointer-events-auto{pointer-events:auto}.fixed{position:fixed}.absolute{position:absolute}.inset-0{inset:0px}.bottom-4{bottom:1rem}.left-1\/2{left:50%}.left-4{left:1rem}.top-4{top:1rem}.mb-2{margin-bottom:0.5rem}.mb-4{margin-bottom:1rem}.flex{display:flex}.grid{display:grid}.h-2{height:0.5rem}.h-full{height:100%}.w-full{width:100%}.max-w-lg{max-width:32rem}.-translate-x-1\/2{--tw-translate-x:-50%;transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.grid-cols-\[auto\2c 1fr\]{grid-template-columns:auto 1fr}.items-center{align-items:center}.justify-center{justify-content:center}.gap-2{gap:0.5rem}.gap-x-4{column-gap:1rem}.gap-y-1{row-gap:0.25rem}.overflow-hidden{overflow:hidden}.rounded-full{border-radius:9999px}.rounded-lg{border-radius:0.5rem}.rounded-md{border-radius:0.375rem}.border{border-width:1px}.border-white\/10{border-color:rgb(255 255 255 / 0.1)}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0 / var(--tw-bg-opacity, 1))}.bg-black\/60{background-color:rgb(0 0 0 / 0.6)}.bg-white\/10{background-color:rgb(255 255 255 / 0.1)}.bg-gradient-to-r{background-image:linear-gradient(to right, var(--tw-gradient-stops))}.from-cyan-400{--tw-gradient-from:#22d3ee var(--tw-gradient-from-position);--tw-gradient-to:rgb(34 211 238 / 0) var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-from), var(--tw-gradient-to)}.to-purple-500{--tw-gradient-to:#a855f7 var(--tw-gradient-to-position)}.p-2{padding:0.5rem}.p-3{padding:0.75rem}.p-4{padding:1rem}.px-4{padding-left:1rem;padding-right:1rem}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}.font-sans{font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"}.text-sm{font-size:0.875rem;line-height:1.25rem}.text-xs{font-size:0.75rem;line-height:1rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.font-bold{font-weight:700}.uppercase{text-transform:uppercase}.tracking-widest{letter-spacing:0.1em}.text-cyan-300{--tw-text-opacity:1;color:rgb(103 232 249 / var(--tw-text-opacity, 1))}.text-gray-200{--tw-text-opacity:1;color:rgb(229 231 235 / var(--tw-text-opacity, 1))}.text-gray-300{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity, 1))}.text-gray-400{--tw-text-opacity:1;color:rgb(156 163 175 / var(--tw-text-opacity, 1))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.opacity-100{opacity:1}.shadow-inner{--tw-shadow:inset 0 2px 4px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:inset 0 2px 4px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)}.backdrop-blur-md{--tw-backdrop-blur:blur(12px);-webkit-backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);backdrop-filter:var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)}.transition-all{transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.transition-colors{transition-property:color, background-color, border-color, fill, stroke, -webkit-text-decoration-color;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-property:color, background-color, border-color, text-decoration-color, fill, stroke, -webkit-text-decoration-color;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms}.duration-300{transition-duration:300ms}.duration-500{transition-duration:500ms}.ease-out{transition-timing-function:cubic-bezier(0, 0, 0.2, 1)}.hover\:bg-white\/10:hover{background-color:rgb(255 255 255 / 0.1)}.hover\:text-white:hover{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity, 1))}.focus\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\:ring-2:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}.focus\:ring-purple-400:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(192 132 252 / var(--tw-ring-opacity, 1))}@media (min-width: 640px){.sm\:left-6{left:1.5rem}.sm\:top-6{top:1.5rem}.sm\:p-6{padding:1.5rem}}@media (min-width: 1024px){.lg\:left-8{left:2rem}.lg\:top-8{top:2rem}.lg\:p-8{padding:2rem}}</style></head>
<body class="bg-black">
    <!-- Loading overlay -->
    <div id="loader" style="opacity: 0; display: none;">Initializing Simulation...</div>

    <!-- Enhanced UI Container -->
    <div id="ui-container" class="fixed inset-0 p-4 sm:p-6 lg:p-8 pointer-events-none text-gray-200 font-mono text-sm">
        <!-- Top-left Info Panel -->
        <div id="info-panel" class="absolute top-4 left-4 sm:top-6 sm:left-6 lg:top-8 lg:left-8 bg-black/60 backdrop-blur-md p-4 rounded-lg border border-white/10 shadow-lg pointer-events-auto transition-all duration-300 opacity-100">
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">66.5 Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">1335.05 s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">-1 E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">0.001 Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">105.8 s</span>
                    </div></div>

        <!-- Bottom Controls -->
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 w-full max-w-lg px-4">
            <!-- Timeline -->
            <div id="timeline-container" class="bg-black/60 backdrop-blur-md p-3 rounded-lg border border-white/10 shadow-lg mb-4 pointer-events-auto">
                <div id="phase" class="text-center text-xs font-bold tracking-widest uppercase mb-2 text-cyan-300 transition-colors duration-500" style="color: rgb(34, 211, 238);">INSPIRAL</div>
                <div id="progress" class="w-full h-2 bg-white/10 rounded-full overflow-hidden shadow-inner">
                    <div id="progressBar" class="h-full bg-gradient-to-r from-cyan-400 to-purple-500 transition-all duration-500 ease-out" style="width: 5.066561%;"></div>
                </div>
            </div>
            <!-- Control Buttons -->
            <div id="controls" class="flex justify-center items-center gap-2 bg-black/60 backdrop-blur-md p-2 rounded-lg border border-white/10 shadow-lg pointer-events-auto">
                <!-- Buttons will be populated by JS -->
            <button id="restart-btn" title="Restart (R)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg></button><button id="pause-btn" title="Pause/Play (Space)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg></button><button id="cinematic-btn" title="Cinematic Camera (C)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg></button><button id="grid-btn" title="Toggle Grid (G)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg></button><button id="info-btn" title="Toggle Info (I)" class="p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></button></div>
        </div>
    </div>

    <!-- Audio for merger sound -->
    <audio id="mergerSound" src="https://gwosc.org/GW150914data/GW150914_H1_shifted.wav" preload="auto"></audio>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SMAAPass } from 'three/addons/postprocessing/SMAAPass.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- Enhanced Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000011, 0.0003);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false, // SMAA pass handles anti-aliasing
            powerPreference: "high-performance",
            alpha: false,
            stencil: false,
            depth: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- Camera Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 800;
        controls.maxPolarAngle = Math.PI * 0.85;
        camera.position.set(0, 40, 90);

        // --- Ultra HD Galaxy Background ---
        const starfieldMaterial = new THREE.ShaderMaterial({
            uniforms: { 
                time: { value: 0.0 },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                nebulaDensity: { value: 2.0 },
                starDensity: { value: 3.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                varying vec3 vPosition;
                void main() { 
                    vUv = uv; 
                    vPosition = position;
                    gl_Position = vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform float time;
                uniform vec2 resolution;
                uniform float nebulaDensity;
                uniform float starDensity;
                varying vec2 vUv;
                varying vec3 vPosition;
                
                // High quality noise functions
                float hash(vec3 p) { 
                    p = fract(p * vec3(443.8975, 397.2973, 491.1871));
                    p += dot(p, p.yxz + 19.19);
                    return fract((p.x + p.y) * p.z);
                }
                
                float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    return mix(mix(mix(hash(i + vec3(0,0,0)), hash(i + vec3(1,0,0)), f.x),
                                   mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                               mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                   mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                }
                
                float fbm(vec3 p) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    float frequency = 1.0;
                    for(int i = 0; i < 6; i++) {
                        value += amplitude * noise(p * frequency);
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }
                    return value;
                }
                
                void main() {
                    vec3 color = vec3(0.0);
                    vec2 uv = vUv;
                    vec3 pos = vPosition;
                    
                    // Ultra HD star field
                    for(int i = 0; i < 5; i++) {
                        float scale = 100.0 + float(i) * 200.0;
                        vec2 starUv = uv * scale;
                        float star = hash(vec3(floor(starUv), float(i)));
                        
                        if(star > 0.98 - float(i) * 0.01) {
                            vec2 starPos = fract(starUv) - 0.5;
                            float dist = length(starPos);
                            float brightness = 1.0 - smoothstep(0.0, 0.02, dist);
                            brightness *= (0.5 + 0.5 * sin(time * (1.0 + star * 5.0)));
                            
                            // Star color variation
                            vec3 starColor = vec3(1.0);
                            float colorType = hash(vec3(floor(starUv), float(i) + 100.0));
                            if(colorType < 0.3) starColor = vec3(1.0, 0.8, 0.6); // Yellow
                            else if(colorType < 0.6) starColor = vec3(0.8, 0.8, 1.0); // Blue-white
                            else if(colorType < 0.8) starColor = vec3(1.0, 0.6, 0.4); // Red
                            
                            color += starColor * brightness * starDensity / float(i + 1);
                        }
                    }
                    
                    // High detail nebula
                    vec3 nebulaPos = pos * 0.001;
                    float nebula1 = fbm(nebulaPos + vec3(time * 0.01, 0.0, 0.0));
                    float nebula2 = fbm(nebulaPos * 2.0 - vec3(0.0, time * 0.02, 0.0));
                    float nebula3 = fbm(nebulaPos * 4.0 + vec3(0.0, 0.0, time * 0.03));
                    
                    float nebulaMask = nebula1 * 0.5 + nebula2 * 0.3 + nebula3 * 0.2;
                    nebulaMask = pow(nebulaMask, 2.0) * nebulaDensity;
                    
                    // Nebula color gradients
                    vec3 nebulaColor1 = vec3(0.1, 0.0, 0.4) * nebula1;
                    vec3 nebulaColor2 = vec3(0.0, 0.1, 0.3) * nebula2;
                    vec3 nebulaColor3 = vec3(0.2, 0.0, 0.2) * nebula3;
                    vec3 nebulaColor = (nebulaColor1 + nebulaColor2 + nebulaColor3) * 0.5;
                    
                    color += nebulaColor * nebulaMask;
                    
                    // Milky way band
                    float band = 1.0 - abs(pos.y * 0.005);
                    band = pow(band, 4.0) * 0.2;
                    vec3 bandColor = mix(vec3(0.05, 0.03, 0.08), vec3(0.1, 0.08, 0.15), noise(pos * 0.01));
                    color += bandColor * band;
                    
                    // Distant galaxies
                    float galaxyNoise = hash(vec3(uv * 50.0, 0.0));
                    if(galaxyNoise > 0.999) {
                        float galaxyBrightness = pow(galaxyNoise, 10.0) * 0.5;
                        color += vec3(0.8, 0.7, 0.9) * galaxyBrightness;
                    }
                    
                    // Final color grading
                    color = pow(color, vec3(0.85));
                    color = mix(color, vec3(dot(color, vec3(0.299, 0.587, 0.114))), -0.2);
                    
                    gl_FragColor = vec4(color, 1.0);
                }`,
            side: THREE.BackSide
        });
        const starfieldSphere = new THREE.Mesh(new THREE.IcosahedronGeometry(2000, 4), starfieldMaterial);
        scene.add(starfieldSphere);

        // --- Advanced Ambient Lighting ---
        const ambientLight = new THREE.AmbientLight(0x0a0a0a, 0.5);
        scene.add(ambientLight);

        // --- High Quality Spacetime Grid ---
        class SpacetimeGrid {
            constructor() {
                this.gridSize = 300;
                this.gridDivisions = 60;
                this.group = new THREE.Group();
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        bhPositions: { value: [new THREE.Vector3(), new THREE.Vector3()] },
                        bhMasses: { value: [0, 0] },
                        time: { value: 0 },
                        opacity: { value: 0.3 },
                        waveAmplitude: { value: 0.0 },
                        waveOrigin: { value: new THREE.Vector3() },
                        waveTime: { value: 0.0 }
                    },
                    vertexShader: `
                        uniform vec3 bhPositions[2];
                        uniform float bhMasses[2];
                        uniform float time;
                        uniform float waveAmplitude;
                        uniform vec3 waveOrigin;
                        uniform float waveTime;
                        
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            vec3 pos = position;
                            float totalDistortion = 0.0;
                            
                            // Black hole warping
                            for(int i = 0; i < 2; i++) {
                                if(bhMasses[i] > 0.0) {
                                    vec3 delta = pos - bhPositions[i];
                                    delta.y = 0.0;
                                    float dist = length(delta);
                                    float warp = bhMasses[i] / (dist + 5.0);
                                    float falloff = exp(-dist * 0.05);
                                    pos.y -= warp * 3.0 * falloff;
                                    totalDistortion += warp;
                                }
                            }
                            
                            // Gravitational wave ripples
                            float waveDist = length(pos.xz - waveOrigin.xz);
                            float wave = sin(waveDist * 0.3 - waveTime * 15.0) * waveAmplitude;
                            wave *= exp(-waveDist * 0.01) * exp(-waveTime * 2.0);
                            pos.y += wave * 5.0;
                            vWave = wave;
                            
                            // Orbital motion distortion
                            float orbitalEffect = sin(time * 2.0 + length(pos.xz) * 0.05) * 0.2;
                            pos.y += orbitalEffect * totalDistortion;
                            
                            vDistortion = totalDistortion;
                            vColor = mix(vec3(0.0, 0.5, 1.0), vec3(1.0, 0.0, 0.5), totalDistortion * 0.2);
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying float vDistortion;
                        varying vec3 vColor;
                        varying float vWave;
                        
                        void main() {
                            float intensity = 0.3 + vDistortion * 0.7 + abs(vWave) * 2.0;
                            vec3 color = vColor;
                            
                            // Pulsing effect
                            float pulse = sin(time * 3.0 + vDistortion * 10.0) * 0.1 + 0.9;
                            intensity *= pulse;
                            
                            // Wave color enhancement
                            if(abs(vWave) > 0.01) {
                                color = mix(color, vec3(0.5, 0.0, 1.0), abs(vWave) * 5.0);
                            }
                            
                            gl_FragColor = vec4(color, opacity * intensity);
                        }`,
                    transparent: true,
                    wireframe: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const geometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize, this.gridDivisions, this.gridDivisions);
                geometry.rotateX(-Math.PI / 2);
                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.position.y = -10;
                this.group.add(this.mesh);
                
                scene.add(this.group);
                this.group.visible = false;
            }
            
            update(blackHoles, deltaTime) {
                if (blackHoles.length > 0) {
                    this.material.uniforms.bhPositions.value[0].copy(blackHoles[0].position);
                    this.material.uniforms.bhMasses.value[0] = blackHoles[0].mass;
                }
                if (blackHoles.length > 1) {
                    this.material.uniforms.bhPositions.value[1].copy(blackHoles[1].position);
                    this.material.uniforms.bhMasses.value[1] = blackHoles[1].mass;
                } else {
                    this.material.uniforms.bhMasses.value[1] = 0;
                }
                this.material.uniforms.time.value += deltaTime;
                this.material.uniforms.waveTime.value += deltaTime;
            }
            
            triggerWave(origin, amplitude) {
                this.material.uniforms.waveOrigin.value.copy(origin);
                this.material.uniforms.waveAmplitude.value = amplitude;
                this.material.uniforms.waveTime.value = 0;
            }
        }

        // --- Physics & Simulation State ---
        const G = 0.1;
        let blackHoles = [];
        let massStream = null;
        let jets = [];
        let simulationActive = true;
        let spacetimeGrid = new SpacetimeGrid();
        let particleSystems = [];
        let initialDistance = 70;
        let simulationTime = 0;
        let mergerTime = -1;
        
        const params = {
            mass1: 40, 
            mass2: 25, 
            distance: 70, 
            timeScale: 1.0, 
            isPaused: false,
            orbitalDecay: 0.005,
            diskEmissivity: 3.0, 
            bloomIntensity: 1.5, 
            finalSpin: 0.9, 
            cameraShake: true, 
            cinematicCamera: false,
            showGrid: false, 
            showInfo: true, 
            quality: 'ultra',
            particleDensity: 1.5, 
            lensingStrength: 1.0,
            playSound: true, // New parameter for sound
            focusBH1: () => setCameraFocus(0),
            focusBH2: () => setCameraFocus(1),
            focusCenter: () => setCameraFocus(-1),
            resetCamera: () => {
                setCameraFocus(-1);
                controls.reset();
                camera.position.set(0, 40, 90);
            },
            start: () => initSimulation(),
            preset1: () => applyPreset(40, 25, 70),
            preset2: () => applyPreset(30, 30, 80),
            preset3: () => applyPreset(50, 10, 100),
            preset4: () => applyPreset(140, 100, 120) // New 2025 massive merger preset
        };
        
        let cameraTarget = new THREE.Object3D();
        scene.add(cameraTarget);

        // --- Ultra HD BlackHole Class (with enhanced Doppler shift) ---
        class BlackHole {
            constructor(mass, position, velocity, isPrimary = false) {
                this.mass = mass; 
                this.position = position; 
                this.velocity = velocity;
                this.isPrimary = isPrimary;
                this.isMerged = false; 
                this.radius = Math.pow(mass, 1/3);
                this.spin = new THREE.Vector3(0, 1, 0).multiplyScalar(Math.random() * 0.5 + 0.5);
                this.spinMagnitude = 0;
                this.precessionAxis = new THREE.Vector3(0, 1, 0);
                
                this.group = new THREE.Group();
                
                // Schwarzschild radius event horizon
                const eventHorizonGeometry = new THREE.SphereGeometry(this.radius, 128, 64);
                this.eventHorizon = new THREE.Mesh(eventHorizonGeometry, new THREE.MeshBasicMaterial({ 
                    color: 0x000000
                }));
                this.eventHorizon.castShadow = true;
                this.eventHorizon.receiveShadow = true;
                this.group.add(this.eventHorizon);
                
                // Multi-layer glow effect
                for(let i = 0; i < 3; i++) {
                    const glowScale = 1.1 + i * 0.05;
                    const glowGeometry = new THREE.SphereGeometry(this.radius * glowScale, 64, 32);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: isPrimary ? 0xff6600 : 0x0066ff,
                        transparent: true,
                        opacity: 0.1 / (i + 1),
                        blending: THREE.AdditiveBlending,
                        side: THREE.BackSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    this.group.add(glow);
                }
                
                // Dynamic light sources
                this.light = new THREE.PointLight(isPrimary ? 0xffaa66 : 0x6699ff, 2, 300, 2);
                this.light.castShadow = true;
                this.light.shadow.mapSize.width = 1024;
                this.light.shadow.mapSize.height = 1024;
                this.group.add(this.light);
                
                // Rim lighting
                const rimLight = new THREE.PointLight(isPrimary ? 0xff6600 : 0x0066ff, 1, 200, 2);
                rimLight.position.set(0, this.radius * 2, 0);
                this.group.add(rimLight);

                // Ultra HD accretion disk with enhanced Doppler
                this.createAccretionDisk();
                
                scene.add(this.group);
                
                // HD Particle systems
                this.createParticleSystem();
                this.createPhotonSphere();
            }
            
            createAccretionDisk() {
                const diskInner = this.radius * 1.5; 
                const diskOuter = this.radius * 4;
                
                this.diskMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        innerRadius: { value: diskInner },
                        outerRadius: { value: diskOuter },
                        emissiveIntensity: { value: params.diskEmissivity },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xff8800) : new THREE.Color(0x0088ff) },
                        rotationSpeed: { value: 1.0 },
                        temperature: { value: 1.0 },
                        ringdown: { value: 0.0 },
                        tidalForce: { value: new THREE.Vector3() },
                        cameraPos: { value: new THREE.Vector3() }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float ringdown;
                        uniform vec3 tidalForce;
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vNormal;
                        varying vec3 vWorldPosition;

                        void main() {
                            vUv = uv;
                            vPos = position;
                            vNormal = normal;
                            vec3 pos = position;
                            
                            // Tidal Disruption Effect
                            float tidalMagnitude = length(tidalForce);
                            if (tidalMagnitude > 0.01) {
                                vec3 dirToForce = normalize(tidalForce);
                                float alignment = dot(normalize(pos.xz), normalize(dirToForce.xz));
                                float stretch = smoothstep(0.5, 1.0, alignment) * tidalMagnitude * 5.0;
                                pos += dirToForce * stretch;
                            }

                            // Ringdown oscillation effect
                            if (ringdown > 0.0) {
                                float r = length(pos.xz);
                                float angle = atan(pos.z, pos.x);
                                float wobble = sin(r * 0.5 - time * 10.0) * sin(angle * 4.0); // Quadrupole oscillation
                                pos.y += wobble * ringdown * r * 0.1; // Amplitude proportional to radius
                            }
                            
                            vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }`,
                    fragmentShader: `
                        uniform float time;
                        uniform float innerRadius;
                        uniform float outerRadius;
                        uniform float emissiveIntensity;
                        uniform vec3 primaryColor;
                        uniform float rotationSpeed;
                        uniform float temperature;
                        uniform vec3 cameraPos;
                        
                        varying vec2 vUv;
                        varying vec3 vPos;
                        varying vec3 vWorldPosition;
                        
                        // High quality noise
                        float noise(vec2 p) {
                            return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
                        }
                        
                        float turbulence(vec2 p) {
                            float value = 0.0;
                            float scale = 1.0;
                            for(int i = 0; i < 5; i++) {
                                value += noise(p * scale) / scale;
                                scale *= 2.0;
                            }
                            return value;
                        }
                        
                        vec3 blackbody(float temp) {
                            vec3 color;
                            float t = temp * 4000.0;
                            
                            if(t < 6600.0) {
                                color.r = 1.0;
                                color.g = 0.39 * log(t / 100.0) - 0.63;
                                color.b = 0.54 * log(t / 100.0 - 10.0) - 1.19;
                            } else {
                                color.r = 1.29 * pow(t / 100.0 - 60.0, -0.13);
                                color.g = 1.29 * pow(t / 100.0 - 60.0, -0.07);
                                color.b = 1.0;
                            }
                            
                            return clamp(color, 0.0, 1.0);
                        }
                        
                        void main() {
                            float dist = length(vPos);
                            float angle = atan(vPos.z, vPos.x);
                            
                            // Complex spiral arms
                            float spiral1 = sin(angle * 2.0 - time * rotationSpeed + dist * 0.3);
                            float spiral2 = sin(angle * 3.0 + time * rotationSpeed * 0.7 - dist * 0.2);
                            float spiralPattern = (spiral1 * 0.7 + spiral2 * 0.3) * 0.5 + 0.5;
                            
                            // Turbulence
                            float turb = turbulence(vec2(angle * 5.0, dist * 0.1) + time * 0.1);
                            spiralPattern = mix(spiralPattern, turb, 0.3);
                            
                            // Radial profile
                            float innerEdge = smoothstep(innerRadius - 1.0, innerRadius + 1.0, dist);
                            float outerEdge = 1.0 - smoothstep(outerRadius - 5.0, outerRadius, dist);
                            float radialFade = innerEdge * outerEdge;
                            
                            // Temperature gradient
                            float temp = temperature * (1.0 - (dist - innerRadius) / (outerRadius - innerRadius));
                            temp = pow(temp, 2.0);
                            
                            // Relativistic Doppler Beaming
                            vec3 tangent = normalize(vec3(-vPos.z, 0.0, vPos.x));
                            float speed = 0.3; // Relativistic speed factor
                            vec3 velocity = tangent * speed;
                            vec3 viewDir = normalize(cameraPos - vWorldPosition);
                            float dopplerFactor = dot(velocity, viewDir);
                            float brightnessBoost = pow(1.0 + dopplerFactor, 4.0);
                            temp *= (1.0 + dopplerFactor * 0.5); // Temperature shift
                            
                            // Color from temperature
                            vec3 color = blackbody(temp) * primaryColor;
                            
                            // Hot spots and flares
                            float hotSpot = pow(noise(vec2(angle * 10.0 + time, dist * 0.5)), 3.0);
                            color += color * hotSpot * 2.0;
                            
                            // Rim brightening
                            float innerRim = 1.0 - smoothstep(innerRadius, innerRadius + 2.0, dist);
                            color += primaryColor * pow(innerRim, 2.0) * 5.0;
                            
                            // Final composition
                            float intensity = radialFade * (0.6 + spiralPattern * 0.4) * emissiveIntensity * brightnessBoost;
                            color *= intensity;
                            
                            // Add glow
                            color += primaryColor * 0.1 * intensity;
                            
                            gl_FragColor = vec4(color, radialFade * 0.9);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const diskSegments = params.quality === 'ultra' ? 256 : 128;
                const diskGeometry = new THREE.RingGeometry(diskInner, diskOuter, diskSegments, 16);
                diskGeometry.rotateX(-Math.PI / 2);
                
                this.accretionDisk = new THREE.Mesh(diskGeometry, this.diskMaterial);
                this.group.add(this.accretionDisk);
            }
            
            createParticleSystem() {
                const particleCount = params.quality === 'ultra' ? 2000 : 1000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const velocities = new Float32Array(particleCount * 3);
                const lifetimes = new Float32Array(particleCount);
                const sizes = new Float32Array(particleCount);
                const customColors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = this.radius * 1.5 + Math.random() * this.radius * 2.5;
                    const height = (Math.random() - 0.5) * 4;
                    
                    positions[i * 3] = Math.cos(angle) * radius;
                    positions[i * 3 + 1] = height * Math.exp(-radius / (this.radius * 3));
                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                    
                    const speed = Math.sqrt(G * this.mass / radius) * (0.8 + Math.random() * 0.4);
                    velocities[i * 3] = -Math.sin(angle) * speed;
                    velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                    velocities[i * 3 + 2] = Math.cos(angle) * speed;
                    
                    lifetimes[i] = Math.random();
                    sizes[i] = Math.random() * 2 + 0.5;
                    
                    const temp = 1.0 - (radius - this.radius) / (this.radius * 3);
                    customColors[i * 3] = temp;
                    customColors[i * 3 + 1] = temp * 0.5;
                    customColors[i * 3 + 2] = temp * 0.2;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
                geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        primaryColor: { value: this.isPrimary ? new THREE.Color(0xffaa66) : new THREE.Color(0x6699ff) },
                        opacity: { value: 1.0 }
                    },
                    vertexShader: `
                        attribute float lifetime;
                        attribute float size;
                        attribute vec3 customColor;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vLifetime = lifetime;
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (300.0 / -mvPosition.z) * vLifetime;
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform vec3 primaryColor;
                        uniform float opacity;
                        varying float vLifetime;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * vLifetime * 0.8 * opacity;
                            vec3 finalColor = mix(primaryColor, vec3(1.0), vColor.r);
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.particles = new THREE.Points(geometry, material);
                this.particles.userData.type = 'accretion';
                this.particles.userData.parentBH = this;
                this.group.add(this.particles);
                particleSystems.push(this.particles);
            }
            
            createPhotonSphere() {
                // Photon sphere at 1.5x Schwarzschild radius
                const photonRadius = this.radius * 1.5;
                const photonGeometry = new THREE.TorusGeometry(photonRadius, 0.1, 8, 64);
                const photonMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.3,
                    blending: THREE.AdditiveBlending
                });
                this.photonSphere = new THREE.Mesh(photonGeometry, photonMaterial);
                this.photonSphere.rotation.x = Math.PI / 2;
                this.group.add(this.photonSphere);
            }
            
            update(deltaTime) {
                this.position.add(this.velocity.clone().multiplyScalar(deltaTime));
                this.group.position.copy(this.position);
                this.light.intensity = this.mass * 0.05 * params.diskEmissivity;
                
                // Update disk
                this.diskMaterial.uniforms.time.value += deltaTime;
                this.diskMaterial.uniforms.cameraPos.value.copy(camera.position);
                this.accretionDisk.rotation.y += deltaTime * 0.3;
                
                // Photon sphere rotation
                if(this.photonSphere) {
                    this.photonSphere.rotation.z += deltaTime * 2;
                }
                
                if (this.isMerged) {
                    this.diskMaterial.uniforms.emissiveIntensity.value = THREE.MathUtils.lerp(
                        this.diskMaterial.uniforms.emissiveIntensity.value, 
                        params.diskEmissivity, 
                        deltaTime * 0.5
                    );
                }
            }
            
            dispose() {
                // Remove associated particle systems from the global array
                particleSystems = particleSystems.filter(p => p.userData.parentBH !== this);

                // Dispose of all geometries and materials to free up GPU memory
                this.group.traverse(child => {
                    if (child.isMesh || child.isPoints) {
                        child.geometry.dispose();
                        // If material is an array, dispose each one
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                scene.remove(this.group);
            }
        }
        
        // --- Ultra HD MassStream Class ---
        class MassStream {
            constructor() {
                this.particleCount = 1000;
                this.geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.particleCount * 3);
                const customColors = new Float32Array(this.particleCount * 3);
                const sizes = new Float32Array(this.particleCount);
                
                for (let i = 0; i < this.particleCount; i++) {
                    positions[i * 3] = 0;
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                    
                    const t = i / this.particleCount;
                    customColors[i * 3] = 1.0;
                    customColors[i * 3 + 1] = 0.5 + t * 0.5;
                    customColors[i * 3 + 2] = t;
                    
                    sizes[i] = Math.random() * 2 + 0.5;
                }
                
                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
                this.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        opacity: { value: 0.8 }
                    },
                    vertexShader: `
                        attribute float size;
                        attribute vec3 customColor;
                        varying vec3 vColor;
                        
                        void main() {
                            vColor = customColor;
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            gl_PointSize = size * (200.0 / -mvPosition.z);
                            gl_Position = projectionMatrix * mvPosition;
                        }`,
                    fragmentShader: `
                        uniform float opacity;
                        uniform float time;
                        varying vec3 vColor;
                        
                        void main() {
                            vec2 center = gl_PointCoord - 0.5;
                            float dist = length(center);
                            if(dist > 0.5) discard;
                            
                            float alpha = smoothstep(0.5, 0.0, dist) * opacity;
                            vec3 finalColor = vColor * (1.0 + 0.5 * sin(time * 10.0));
                            
                            gl_FragColor = vec4(finalColor, alpha);
                        }`,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                this.mesh = new THREE.Points(this.geometry, this.material);
                scene.add(this.mesh);
            }
            
            update(p1, p2, v1, distance, deltaTime) {
                const positions = this.geometry.attributes.position.array;
                const colors = this.geometry.attributes.customColor.array;
                
                for (let i = 0; i < this.particleCount; i++) {
                    const t = i / this.particleCount;
                    
                    // Bezier curve for stream path
                    const midPoint = new THREE.Vector3().lerpVectors(p1, p2, 0.5);
                    const offset = new THREE.Vector3().crossVectors(
                        new THREE.Vector3().subVectors(p2, p1).normalize(),
                        new THREE.Vector3(0, 1, 0)
                    ).multiplyScalar(distance * 0.1 * Math.sin(t * Math.PI));
                    midPoint.add(offset);
                    
                    // Quadratic bezier interpolation
                    const t2 = 1 - t;
                    const point = new THREE.Vector3()
                        .addScaledVector(p1, t2 * t2)
                        .addScaledVector(midPoint, 2 * t2 * t)
                        .addScaledVector(p2, t * t);
                    
                    // Add turbulence
                    const turbulence = new THREE.Vector3(
                        Math.sin(t * 10 + this.material.uniforms.time.value * 5) * 2,
                        Math.cos(t * 8 + this.material.uniforms.time.value * 3) * 2,
                        Math.sin(t * 12 + this.material.uniforms.time.value * 4) * 2
                    );
                    point.add(turbulence);
                    
                    positions[i * 3] = point.x;
                    positions[i * 3 + 1] = point.y;
                    positions[i * 3 + 2] = point.z;
                    
                    // Dynamic coloring based on distance
                    const heat = 1.0 - distance / 100;
                    colors[i * 3] = heat;
                    colors[i * 3 + 1] = heat * 0.5;
                    colors[i * 3 + 2] = (1 - heat) * 0.5;
                }
                
                this.geometry.attributes.position.needsUpdate = true;
                this.geometry.attributes.customColor.needsUpdate = true;
                
                const opacity = 1.0 - THREE.MathUtils.smoothstep(distance, 40, 100);
                this.material.uniforms.opacity.value = opacity * 0.8;
                this.material.uniforms.time.value += deltaTime;
            }
            
            hide() { 
                this.material.uniforms.opacity.value = 0; 
            }
            
            dispose() {
                this.geometry.dispose();
                this.material.dispose();
                scene.remove(this.mesh);
            }
        }

        // --- Physics & Merger Logic ---
        function updatePhysics(deltaTime) {
            if (mergerTime < 0 && blackHoles.length > 1) {
                // Pre-merger physics
                simulationTime += deltaTime;
                
                const bh1 = blackHoles[0], bh2 = blackHoles[1];
                const distanceVec = new THREE.Vector3().subVectors(bh2.position, bh1.position);
                const distance = distanceVec.length();
                
                updateInfoDisplay(distance);
                
                const progress = 1.0 - (distance / initialDistance);
                document.getElementById('progressBar').style.width = `${progress * 100}%`;
                
                const phaseEl = document.getElementById('phase');
                if (distance < 30) {
                    phaseEl.textContent = 'MERGER PHASE';
                    phaseEl.style.color = '#f472b6'; // pink-400
                } else if (distance < 50) {
                    phaseEl.textContent = 'FINAL INSPIRAL';
                    phaseEl.style.color = '#f59e0b'; // amber-500
                }
                
                if (distance < bh1.radius + bh2.radius) { 
                    mergeBlackHoles(); 
                    return; 
                }
                
                // Newtonian gravity
                const forceMag = G * (bh1.mass * bh2.mass) / (distance * distance);
                const forceVec = distanceVec.normalize().multiplyScalar(forceMag);
                
                bh1.velocity.add(forceVec.clone().divideScalar(bh1.mass).multiplyScalar(deltaTime));
                bh2.velocity.add(forceVec.clone().multiplyScalar(-1).divideScalar(bh2.mass).multiplyScalar(deltaTime));
                
                // GW energy loss (orbital decay)
                const totalMass = bh1.mass + bh2.mass;
                const v = Math.sqrt(G * totalMass / distance);
                const mu = (bh1.mass * bh2.mass) / totalMass;
                const gwLuminosity = (32/5) * Math.pow(G, 4) * Math.pow(mu, 2) * Math.pow(totalMass, 3) / Math.pow(distance, 5);
                const energyLoss = gwLuminosity * deltaTime * 0.000005;
                const decayRate = energyLoss / (mu * v * v) + params.orbitalDecay * deltaTime;
                
                const decayVec = distanceVec.clone().normalize().multiplyScalar(-decayRate);
                bh1.position.add(decayVec.clone().multiplyScalar(bh2.mass / totalMass));
                bh2.position.add(decayVec.clone().multiplyScalar(-bh1.mass / totalMass));
                
                // Update tidal forces for disk deformation
                const tidalForceOn1 = forceVec.clone().multiplyScalar(1 / (distance * distance * 1000));
                bh1.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1);
                bh2.diskMaterial.uniforms.tidalForce.value.copy(tidalForceOn1.negate());

                massStream.update(bh1.position, bh2.position, bh1.velocity, distance, deltaTime);
            }
            
            blackHoles.forEach(bh => bh.update(deltaTime));
            spacetimeGrid.update(blackHoles, deltaTime);
        }
        
        function updateInfoDisplay(distance) {
            if (!params.showInfo) return;
            const infoPanel = document.getElementById('info-panel');
            if (!infoPanel) return;

            if (blackHoles.length > 1) {
                const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                const orbitalPeriod = 2 * Math.PI * Math.sqrt(Math.pow(distance, 3) / (G * totalMass));
                const kineticEnergy = 0.5 * blackHoles[0].mass * blackHoles[0].velocity.lengthSq() + 
                                      0.5 * blackHoles[1].mass * blackHoles[1].velocity.lengthSq();
                const potentialEnergy = -G * blackHoles[0].mass * blackHoles[1].mass / distance;
                const totalEnergy = kineticEnergy + potentialEnergy;
                const gwFrequency = 2 / orbitalPeriod;
                
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">System State</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Separation:</span> <span class="text-cyan-300 font-bold text-right">${distance.toFixed(1)} Rs</span>
                        <span class="text-gray-400">Period:</span> <span class="text-cyan-300 font-bold text-right">${orbitalPeriod.toFixed(2)} s</span>
                        <span class="text-gray-400">Total Energy:</span> <span class="text-cyan-300 font-bold text-right">${totalEnergy.toFixed(0)} E</span>
                        <span class="text-gray-400">GW Freq:</span> <span class="text-cyan-300 font-bold text-right">${gwFrequency.toFixed(3)} Hz</span>
                        <span class="text-gray-400">Time:</span> <span class="text-cyan-300 font-bold text-right">${simulationTime.toFixed(1)} s</span>
                    </div>`;
            } else if (blackHoles.length === 1) {
                const bh = blackHoles[0];
                infoPanel.innerHTML = `
                    <h3 class="text-lg font-bold text-white mb-2 font-sans">Remnant Black Hole</h3>
                    <div class="grid grid-cols-[auto,1fr] gap-x-4 gap-y-1 text-xs">
                        <span class="text-gray-400">Status:</span> <span class="text-green-400 font-bold text-right">Ringdown</span>
                        <span class="text-gray-400">Mass:</span> <span class="text-cyan-300 font-bold text-right">${bh.mass.toFixed(1)} M☉</span>
                        <span class="text-gray-400">Spin:</span> <span class="text-cyan-300 font-bold text-right">${bh.spinMagnitude.toFixed(2)} a/M</span>
                        <span class="text-gray-400">Kick Vel:</span> <span class="text-cyan-300 font-bold text-right">${bh.velocity.length().toFixed(1)} km/s</span>
                    </div>`;
            }
        }
        
        function mergeBlackHoles() {
            simulationActive = false; 
            massStream.hide();
            mergerTime = simulationTime;
            
            const bh1 = blackHoles[0], bh2 = blackHoles[1];
            const newMass = (bh1.mass + bh2.mass) * 0.95; // 5% radiated as GWs
            const newPosition = new THREE.Vector3().addVectors(
                bh1.position.clone().multiplyScalar(bh1.mass), 
                bh2.position.clone().multiplyScalar(bh2.mass)
            ).divideScalar(bh1.mass + bh2.mass);
            
            // GW recoil kick
            const kickVelocity = new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5,
                (Math.random() - 0.5) * 5
            );
            
            triggerGravitationalWave(newPosition); 
            triggerBloomFlash(30.0);
            triggerGodRayFlash(newPosition);
            if (params.cameraShake) triggerCameraShake(1.0, newMass / 50);
            
            createMergerFlash(newPosition);
            spacetimeGrid.triggerWave(newPosition, 0.5);
            
            // Play merger sound if enabled
            if (params.playSound) {
                document.getElementById('mergerSound').play();
            }
            
            bh1.dispose();
            bh2.dispose();
            
            const mergedBH = new BlackHole(newMass, newPosition, kickVelocity, true);
            mergedBH.isMerged = true;
            mergedBH.spinMagnitude = params.finalSpin;
            mergedBH.precessionAxis = new THREE.Vector3(Math.random() - 0.5, 1, Math.random() - 0.5).normalize();
            mergedBH.diskMaterial.uniforms.emissiveIntensity.value = 10.0;
            mergedBH.diskMaterial.uniforms.temperature.value = 2.0;
            mergedBH.diskMaterial.uniforms.ringdown.value = 1.0; // Start ringdown effect
            blackHoles = [mergedBH];
            
            createJets(mergedBH);
            
            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'RINGDOWN PHASE';
            phaseEl.style.color = '#4ade80'; // green-400
            document.getElementById('progressBar').style.width = '100%';
        }
        
        function createMergerFlash(position) {
            // Particle burst
            createParticleBurst(position);
        }
        
        function createParticleBurst(position) {
            const burstCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(burstCount * 3);
            const velocities = new Float32Array(burstCount * 3);
            const customColors = new Float32Array(burstCount * 3);
            
            for(let i = 0; i < burstCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                const speed = 20 + Math.random() * 30;
                
                positions[i * 3] = position.x;
                positions[i * 3 + 1] = position.y;
                positions[i * 3 + 2] = position.z;
                
                velocities[i * 3] = Math.sin(phi) * Math.cos(theta) * speed;
                velocities[i * 3 + 1] = Math.sin(phi) * Math.sin(theta) * speed;
                velocities[i * 3 + 2] = Math.cos(phi) * speed;
                
                const color = new THREE.Color().setHSL(Math.random() * 0.2 + 0.6, 1.0, 0.5);
                customColors[i * 3] = color.r;
                customColors[i * 3 + 1] = color.g;
                customColors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(customColors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                depthWrite: false
            });
            
            const burst = new THREE.Points(geometry, material);
            burst.userData.type = 'burst';
            scene.add(burst);
            particleSystems.push(burst);
        }

        // --- Ultra HD Jet Creation ---
        function createJets(parentBH) {
            const jetLength = 800;
            const jetRadius = parentBH.radius * 0.15;
            
            // Jet shader material
            const jetMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 1.0 },
                    jetLength: { value: jetLength },
                    primaryColor: { value: new THREE.Color(0x4444ff) },
                    secondaryColor: { value: new THREE.Color(0xff44ff) }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    void main() {
                        vUv = uv;
                        vY = position.y;
                        vPosition = position;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }`,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    uniform float jetLength;
                    uniform vec3 primaryColor;
                    uniform vec3 secondaryColor;
                    varying vec2 vUv;
                    varying float vY;
                    varying vec3 vPosition;
                    
                    float noise(vec3 p) {
                        return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453);
                    }
                    
                    void main() {
                        float height = abs(vY) / jetLength;
                        
                        // Jet structure
                        float radialFade = 1.0 - smoothstep(0.0, 1.0, vUv.x);
                        float heightFade = 1.0 - smoothstep(0.3, 1.0, height);
                        
                        // Pulsing waves
                        float pulse1 = sin(vY * 0.05 - time * 5.0) * 0.5 + 0.5;
                        float pulse2 = sin(vY * 0.08 + time * 3.0) * 0.5 + 0.5;
                        float combinedPulse = pulse1 * 0.7 + pulse2 * 0.3;
                        
                        // Turbulence
                        float turb = noise(vPosition * 0.1 + time);
                        
                        // Color mixing
                        vec3 color = mix(primaryColor, secondaryColor, combinedPulse + turb * 0.2);
                        color = mix(color, vec3(1.0), heightFade * 0.3);
                        
                        // Shock fronts
                        float shock = step(0.98, sin(vY * 0.02 - time * 2.0));
                        color += vec3(0.5, 0.3, 0.8) * shock;

                        // Brighter Core
                        float coreBrightness = pow(1.0 - vUv.x, 10.0);
                        color += vec3(1.0, 1.0, 1.5) * coreBrightness * 2.0;
                        
                        float alpha = opacity * radialFade * heightFade * (0.5 + combinedPulse * 0.5);
                        
                        gl_FragColor = vec4(color, alpha);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            // Create tapered jet geometry
            const jetGeometry = new THREE.CylinderGeometry(jetRadius, jetRadius * 0.1, jetLength, 32, 32, true);
            
            // Add twist to geometry
            const positions = jetGeometry.attributes.position.array;
            for(let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                const angle = y * 0.01;
                const x = positions[i];
                const z = positions[i + 2];
                positions[i] = x * Math.cos(angle) - z * Math.sin(angle);
                positions[i + 2] = x * Math.sin(angle) + z * Math.cos(angle);
            }
            jetGeometry.attributes.position.needsUpdate = true;
            
            const jetTop = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetTop.position.y = jetLength / 2;
            
            const jetBottom = new THREE.Mesh(jetGeometry, jetMaterial.clone());
            jetBottom.position.y = -jetLength / 2;
            jetBottom.rotation.x = Math.PI;
            
            parentBH.group.add(jetTop, jetBottom);
            jets = [jetTop, jetBottom];
            
            // Jet particles
            createJetParticles(parentBH, jetLength);
        }
        
        function createJetParticles(parentBH, jetLength) {
            const particleCount = 2000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const lifetimes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                const isTop = i < particleCount / 2;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * parentBH.radius * 0.15;
                const height = Math.random() * jetLength;
                
                positions[i * 3] = Math.cos(angle) * radius;
                positions[i * 3 + 1] = isTop ? height : -height;
                positions[i * 3 + 2] = Math.sin(angle) * radius;
                
                const speed = 3 + Math.random() * 2;
                velocities[i * 3] = (Math.random() - 0.5) * 0.2;
                velocities[i * 3 + 1] = isTop ? speed : -speed;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
                
                lifetimes[i] = Math.random();
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            geometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    jetLength: { value: jetLength }
                },
                vertexShader: `
                    attribute float lifetime;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vLifetime = lifetime;
                        vHeight = abs(position.y) / ${jetLength.toFixed(1)};
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (1.0 + vHeight * 3.0) * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }`,
                fragmentShader: `
                    uniform float time;
                    varying float vLifetime;
                    varying float vHeight;
                    
                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        if(dist > 0.5) discard;
                        
                        float opacity = smoothstep(0.5, 0.0, dist) * vLifetime * (1.0 - vHeight * 0.5);
                        vec3 color = mix(vec3(0.4, 0.4, 1.0), vec3(1.0, 0.4, 1.0), vHeight);
                        color += vec3(0.2) * (1.0 + sin(time * 10.0 + vHeight * 20.0));
                        
                        gl_FragColor = vec4(color, opacity);
                    }`,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const jetParticles = new THREE.Points(geometry, material);
            jetParticles.userData.type = 'jet';
            jetParticles.userData.parentBH = parentBH;
            parentBH.group.add(jetParticles);
            particleSystems.push(jetParticles);
        }

        // --- Post-Processing Pipeline ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        // Gravitational Lensing Pass
        const lensingPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null }, 
                resolution: { value: new THREE.Vector2() }, 
                aspect: { value: 1.0 },
                bhPositions: { value: Array(10).fill(0).map(() => new THREE.Vector2()) },
                bhMasses: { value: new Float32Array(10) }, 
                bhCount: { value: 0 },
                strength: { value: 1.0 }
            },
            vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform vec2 resolution; 
                uniform float aspect;
                uniform vec2 bhPositions[10]; 
                uniform float bhMasses[10]; 
                uniform int bhCount; 
                uniform float strength;
                varying vec2 vUv;
                
                vec2 computeLensing(vec2 uv) {
                    vec2 totalOffset = vec2(0.0);
                    
                    for (int i = 0; i < 10; i++) {
                        if (i >= bhCount) break;
                        
                        vec2 pos = uv - bhPositions[i]; 
                        pos.x *= aspect;
                        float dist = length(pos);
                        
                        // Einstein ring radius approximation
                        float einsteinRadius = sqrt(bhMasses[i] * 0.0005 * strength);
                        float deflection = einsteinRadius * einsteinRadius / (dist + 0.0001);
                        
                        totalOffset += normalize(pos) * deflection;
                    }
                    
                    totalOffset.x /= aspect;
                    return totalOffset;
                }
                
                void main() {
                    vec2 offset = computeLensing(vUv);
                    
                    // Chromatic aberration for strong lensing
                    float aberration = length(offset) * 3.0;
                    
                    vec3 color;
                    color.r = texture2D(tDiffuse, vUv - offset * (1.0 + aberration * 0.1)).r;
                    color.g = texture2D(tDiffuse, vUv - offset).g;
                    color.b = texture2D(tDiffuse, vUv - offset * (1.0 - aberration * 0.1)).b;
                    
                    // Edge darkening for extreme lensing
                    float edgeDark = 1.0 - smoothstep(0.0, 0.05, length(offset));
                    color *= edgeDark;
                    
                    gl_FragColor = vec4(color, 1.0);
                }`
        });
        lensingPass.uniforms.strength.value = params.lensingStrength;
        composer.addPass(lensingPass);
        
        // Gravitational Wave Pass
        const wavePass = new ShaderPass({
             uniforms: { 
                tDiffuse: { value: null }, 
                time: { value: -1.0 }, 
                origin: { value: new THREE.Vector2() }, 
                amplitude: { value: 0.0 },
                frequency: { value: 50.0 },
                decay: { value: 2.0 }
            },
             vertexShader: `
                varying vec2 vUv; 
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
                }`,
             fragmentShader: `
                uniform sampler2D tDiffuse; 
                uniform float time, amplitude, frequency, decay; 
                uniform vec2 origin; 
                varying vec2 vUv;
                
                void main() {
                    float dist = distance(vUv, origin);
                    
                    // Gravitational wave strain pattern
                    float strain = sin(dist * frequency - time * 15.0) * amplitude;
                    strain *= exp(-dist * decay) * exp(-time * 2.0);
                    strain *= smoothstep(0.0, 0.1, time) * (1.0 - smoothstep(0.7, 1.0, time));
                    
                    // Plus and cross polarizations
                    vec2 dir = normalize(vUv - origin);
                    vec2 perpDir = vec2(-dir.y, dir.x);
                    
                    vec2 plusPol = dir * strain;
                    vec2 crossPol = perpDir * strain * 0.5;
                    
                    vec2 totalOffset = plusPol + crossPol;
                    
                    vec4 color = texture2D(tDiffuse, vUv + totalOffset);
                    
                    // Wave visualization
                    float waveVis = abs(strain) * 15.0;
                    color.rgb += vec3(0.1, 0.05, 0.2) * waveVis;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(wavePass);

        // God-ray / Radial Blur pass for merger flash
        const godRayPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
                exposure: { value: 1.0 },
                decay: { value: 0.95 },
                density: { value: 0.5 },
                weight: { value: 0.4 },
                samples: { value: 60 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 lightPosition;
                uniform float exposure;
                uniform float decay;
                uniform float density;
                uniform float weight;
                uniform int samples;
                varying vec2 vUv;

                void main() {
                    vec2 delta = vUv - lightPosition;
                    delta *= 1.0 / float(samples) * density;
                    float illuminationDecay = 1.0;
                    vec4 color = texture2D(tDiffuse, vUv);

                    for (int i = 0; i < samples; i++) {
                        vUv -= delta;
                        vec4 sampleColor = texture2D(tDiffuse, vUv);
                        sampleColor *= illuminationDecay * weight;
                        color += sampleColor;
                        illuminationDecay *= decay;
                    }
                    gl_FragColor = color * exposure;
                }`
        });
        godRayPass.enabled = false;
        composer.addPass(godRayPass);
        
        // Enhanced Bloom Pass
        const bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight), 
            params.bloomIntensity, 
            0.4, 
            0.1
        );
        bloomPass.threshold = 0.1;
        bloomPass.radius = 1.0;
        composer.addPass(bloomPass);
        
        // SMAA Anti-aliasing Pass (should be one of the last passes before final color correction)
        const smaaPass = new SMAAPass(window.innerWidth, window.innerHeight);
        composer.addPass(smaaPass);

        // Color Correction Pass
        const colorCorrectionPass = new ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                exposure: { value: 1.0 },
                contrast: { value: 1.1 },
                saturation: { value: 1.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }`,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float exposure;
                uniform float contrast;
                uniform float saturation;
                varying vec2 vUv;
                
                vec3 adjustSaturation(vec3 color, float sat) {
                    float gray = dot(color, vec3(0.299, 0.587, 0.114));
                    return mix(vec3(gray), color, sat);
                }
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    
                    // Exposure
                    color.rgb *= exposure;
                    
                    // Contrast
                    color.rgb = (color.rgb - 0.5) * contrast + 0.5;
                    
                    // Saturation
                    color.rgb = adjustSaturation(color.rgb, saturation);
                    
                    // Vignette
                    float vignette = smoothstep(1.0, 0.4, length(vUv - 0.5));
                    color.rgb *= vignette;
                    
                    gl_FragColor = color;
                }`
        });
        composer.addPass(colorCorrectionPass);

        // --- GUI Configuration ---
        const gui = new GUI();
        
        const setupFolder = gui.addFolder('System Setup');
        const mass1Controller = setupFolder.add(params, 'mass1', 10, 150).name('Mass 1 (M☉)');
        const mass2Controller = setupFolder.add(params, 'mass2', 10, 150).name('Mass 2 (M☉)');
        const distanceController = setupFolder.add(params, 'distance', 50, 200).name('Initial Distance');
        setupFolder.add(params, 'start').name('🚀 Launch Simulation');
        
        const presetsFolder = gui.addFolder('Presets');
        presetsFolder.add(params, 'preset1').name('Asymmetric Merger');
        presetsFolder.add(params, 'preset2').name('Equal Mass');
        presetsFolder.add(params, 'preset3').name('Extreme Mass Ratio');
        presetsFolder.add(params, 'preset4').name('Massive Merger');
        
        const directorFolder = gui.addFolder('Director Controls');
        const timeScaleController = directorFolder.add(params, 'timeScale', 0.1, 5.0).name('Time Scale');
        const cinematicController = directorFolder.add(params, 'cinematicCamera').name('Cinematic Camera');
        directorFolder.add(params, 'focusBH1').name('Focus on Black Hole 1');
        directorFolder.add(params, 'focusBH2').name('Focus on Black Hole 2');
        directorFolder.add(params, 'focusCenter').name('Focus on Center');
        directorFolder.add(params, 'resetCamera').name('Reset Camera');

        const visualFolder = gui.addFolder('Visual Controls');
        visualFolder.add(params, 'diskEmissivity', 0, 10).name('Disk Brightness').onChange(v => {
            blackHoles.forEach(bh => bh.diskMaterial.uniforms.emissiveIntensity.value = v);
        });
        visualFolder.add(params, 'bloomIntensity', 0, 5).name('Bloom Intensity').onChange(v => bloomPass.strength = v);
        const gridController = visualFolder.add(params, 'showGrid').name('Show Spacetime Grid').onChange(v => {
            spacetimeGrid.group.visible = v;
        });
        const infoController = visualFolder.add(params, 'showInfo').name('Show Info Display').onChange(v => {
            document.getElementById('info-panel').style.opacity = v ? '1' : '0';
        });
        visualFolder.add(params, 'particleDensity', 0, 3).name('Particle Density').onChange(v => {
             particleSystems.forEach(ps => {
                if (ps.userData.type === 'accretion') {
                    ps.material.uniforms.opacity.value = v;
                }
             });
        });
        visualFolder.add(starfieldMaterial.uniforms.nebulaDensity, 'value', 0, 5).name('Nebula Density');
        visualFolder.add(starfieldMaterial.uniforms.starDensity, 'value', 0, 5).name('Star Density');
        
        const advancedFolder = gui.addFolder('Advanced Physics');
        advancedFolder.add(params, 'orbitalDecay', 0, 0.02).name('Orbital Decay Rate');
        advancedFolder.add(params, 'finalSpin', 0, 0.98, 0.01).name('Final BH Spin (a/M)');
        advancedFolder.add(params, 'cameraShake').name('Camera Shake');
        advancedFolder.add(params, 'lensingStrength', 0, 2).name('Lensing Strength').onChange(v => {
            lensingPass.uniforms.strength.value = v;
        });
        advancedFolder.add(params, 'playSound').name('Play Merger Sound');
        
        const postProcessFolder = gui.addFolder('Post Processing');
        postProcessFolder.add(colorCorrectionPass.uniforms.exposure, 'value', 0.5, 2).name('Exposure');
        postProcessFolder.add(colorCorrectionPass.uniforms.contrast, 'value', 0.5, 2).name('Contrast');
        postProcessFolder.add(colorCorrectionPass.uniforms.saturation, 'value', 0, 2).name('Saturation');
        
        const qualityFolder = gui.addFolder('Performance');
        qualityFolder.add(params, 'quality', ['low', 'medium', 'high', 'ultra']).name('Quality').onChange(updateQuality);

        // --- UI & Controls Setup ---
        const controlsContainer = document.getElementById('controls');
        const pauseIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`;
        const playIcon = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>`;
        
        const controlButtons = [
            { id: 'restart-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>`, action: () => initSimulation(), title: 'Restart (R)' },
            { id: 'pause-btn', icon: pauseIcon, action: togglePause, title: 'Pause/Play (Space)' },
            { id: 'cinematic-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="10" rx="2" ry="2"></rect><line x1="2" y1="12" x2="22" y2="12"></line></svg>`, action: toggleCinematic, title: 'Cinematic Camera (C)' },
            { id: 'grid-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg>`, action: toggleGrid, title: 'Toggle Grid (G)' },
            { id: 'info-btn', icon: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>`, action: toggleInfo, title: 'Toggle Info (I)' },
        ];

        controlButtons.forEach(btnInfo => {
            const button = document.createElement('button');
            button.id = btnInfo.id;
            button.innerHTML = btnInfo.icon;
            button.title = btnInfo.title;
            button.className = "p-2 rounded-md text-gray-300 hover:bg-white/10 hover:text-white focus:outline-none focus:ring-2 focus:ring-purple-400 transition-all";
            button.addEventListener('click', btnInfo.action);
            controlsContainer.appendChild(button);
        });

        function togglePause() {
            params.isPaused = !params.isPaused;
            document.getElementById('pause-btn').innerHTML = params.isPaused ? playIcon : pauseIcon;
        }
        function toggleCinematic() {
            params.cinematicCamera = !params.cinematicCamera;
            cinematicController.updateDisplay();
        }
        function toggleGrid() {
            params.showGrid = !params.showGrid;
            spacetimeGrid.group.visible = params.showGrid;
            gridController.updateDisplay();
        }
        function toggleInfo() {
            params.showInfo = !params.showInfo;
            document.getElementById('info-panel').style.opacity = params.showInfo ? '1' : '0';
            infoController.updateDisplay();
        }

        function initSimulation() {
            // Clear previous simulation objects
            blackHoles.forEach(bh => bh.dispose());
            if (massStream) massStream.dispose();
            particleSystems.forEach(ps => {
                scene.remove(ps);
                ps.geometry.dispose();
                ps.material.dispose();
            });
            particleSystems = [];
            jets = [];
            blackHoles = [];
            
            simulationTime = 0;
            mergerTime = -1;
            simulationActive = true;

            const phaseEl = document.getElementById('phase');
            phaseEl.textContent = 'INSPIRAL';
            phaseEl.style.color = '#22d3ee'; // cyan-400
            document.getElementById('progressBar').style.width = '0%';
            
            const m1 = params.mass1, m2 = params.mass2, dist = params.distance;
            initialDistance = dist;
            const totalMass = m1 + m2;
            
            // Circular orbit velocities
            const v = Math.sqrt(G * totalMass / dist);
            const v1 = v * m2 / totalMass;
            const v2 = v * m1 / totalMass;
            
            // Initial positions (center of mass at origin)
            const r1 = dist * m2 / totalMass;
            const r2 = dist * m1 / totalMass;
            
            const bh1 = new BlackHole(m1, new THREE.Vector3(-r1, 0, 0), new THREE.Vector3(0, 0, -v1), true);
            const bh2 = new BlackHole(m2, new THREE.Vector3(r2, 0, 0), new THREE.Vector3(0, 0, v2), false);
            
            blackHoles.push(bh1, bh2);
            massStream = new MassStream();
            wavePass.uniforms.time.value = -1.0;
            godRayPass.enabled = false;
            setCameraFocus(-1);
        }
        
        function applyPreset(m1, m2, d) {
            params.mass1 = m1;
            params.mass2 = m2;
            params.distance = d;
            mass1Controller.updateDisplay();
            mass2Controller.updateDisplay();
            distanceController.updateDisplay();
            initSimulation();
        }
        
        function updateQuality(quality) {
            let pixelRatio = 1;
            let samples = 30;
            switch(quality) {
                case 'low':
                    pixelRatio = 1;
                    samples = 30;
                    break;
                case 'medium':
                    pixelRatio = Math.min(window.devicePixelRatio, 1.5);
                    samples = 60;
                    break;
                case 'high':
                case 'ultra':
                    pixelRatio = Math.min(window.devicePixelRatio, 2);
                    samples = 80;
                    break;
            }
            renderer.setPixelRatio(pixelRatio);
            composer.setPixelRatio(pixelRatio);
            godRayPass.uniforms.samples.value = samples;
        }
        
        // --- Camera and Effects Management ---
        let shakeDuration = 0, shakeIntensity = 0;
        function triggerCameraShake(duration = 0.5, intensity = 0.5) { 
            shakeDuration = duration; 
            shakeIntensity = intensity; 
        }
        
        function updateCameraShake(deltaTime) { 
            if (shakeDuration > 0) { 
                shakeDuration -= deltaTime;
                const shake = shakeIntensity * (shakeDuration / 0.5); // Fade out
                camera.position.x += (Math.random() - 0.5) * shake; 
                camera.position.y += (Math.random() - 0.5) * shake;
                camera.position.z += (Math.random() - 0.5) * shake * 0.5;
            } 
        }
        
        function triggerGravitationalWave(origin) { 
            const screenPos = origin.clone().project(camera); 
            wavePass.uniforms.origin.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2); 
            wavePass.uniforms.time.value = 0.0; 
            wavePass.uniforms.amplitude.value = 0.04; 
        }
        
        function triggerBloomFlash(strength) { 
            let flashStrength = strength; 
            const flashInterval = setInterval(() => { 
                bloomPass.strength = flashStrength; 
                flashStrength *= 0.9;
                if (flashStrength <= params.bloomIntensity) { 
                    bloomPass.strength = params.bloomIntensity; 
                    clearInterval(flashInterval); 
                } 
            }, 16); 
        }

        function triggerGodRayFlash(origin) {
            const screenPos = origin.clone().project(camera);
            godRayPass.enabled = true;
            godRayPass.uniforms.lightPosition.value.set((screenPos.x + 1) / 2, (screenPos.y + 1) / 2);
            godRayPass.uniforms.exposure.value = 1.0;
        }
        
        let focusIndex = -1;
        function setCameraFocus(index) {
            focusIndex = index;
            params.cinematicCamera = false;
            cinematicController.updateDisplay();
        }

        function updateCamera(time) {
            if (params.cinematicCamera) {
                const phase = (time * 0.05) % (Math.PI * 2);
                const radius = 120 + Math.sin(phase * 2) * 30;
                const height = 50 + Math.sin(phase * 3) * 20;
                
                camera.position.x = Math.cos(phase) * radius;
                camera.position.z = Math.sin(phase) * radius;
                camera.position.y = height;
                
                const lookAhead = 0.1;
                const lookX = Math.cos(phase + lookAhead) * radius * 0.3;
                const lookZ = Math.sin(phase + lookAhead) * radius * 0.3;
                controls.target.set(lookX, 0, lookZ);
            } else {
                let targetPos = new THREE.Vector3();
                if (focusIndex === -1 && blackHoles.length > 1) {
                    const totalMass = blackHoles[0].mass + blackHoles[1].mass;
                    targetPos.addScaledVector(blackHoles[0].position, blackHoles[0].mass / totalMass);
                    targetPos.addScaledVector(blackHoles[1].position, blackHoles[1].mass / totalMass);
                } else if (focusIndex >= 0 && blackHoles[focusIndex]) {
                    targetPos.copy(blackHoles[focusIndex].position);
                } else if (blackHoles.length === 1) {
                    targetPos.copy(blackHoles[0].position);
                }
                cameraTarget.position.lerp(targetPos, 0.1);
                controls.target.lerp(cameraTarget.position, 0.1);
            }
        }
        
        // --- Centralized Particle System Update ---
        function updateAllParticleSystems(deltaTime) {
            for (let i = particleSystems.length - 1; i >= 0; i--) {
                const system = particleSystems[i];
                const type = system.userData.type;

                if (type === 'accretion') {
                    const bh = system.userData.parentBH;
                    if (!bh) continue;

                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    const lifetimes = system.geometry.attributes.lifetime.array;
                    const colors = system.geometry.attributes.customColor.array;
                    
                    for (let j = 0; j < lifetimes.length; j++) {
                        lifetimes[j] -= deltaTime * 0.1;
                        
                        if (lifetimes[j] <= 0) {
                            // Respawn
                            const angle = Math.random() * Math.PI * 2;
                            const radius = bh.radius * 1.5 + Math.random() * bh.radius * 2.5;
                            
                            positions[j * 3] = Math.cos(angle) * radius;
                            positions[j * 3 + 1] = (Math.random() - 0.5) * 2;
                            positions[j * 3 + 2] = Math.sin(angle) * radius;
                            
                            lifetimes[j] = 1.0;
                        } else {
                            // Update position with gravity
                            const x = positions[j * 3];
                            const y = positions[j * 3 + 1];
                            const z = positions[j * 3 + 2];
                            const r = Math.sqrt(x * x + z * z);
                            
                            // Gravitational acceleration
                            const accel = -G * bh.mass / (r * r);
                            velocities[j * 3] += (x / r) * accel * deltaTime;
                            velocities[j * 3 + 2] += (z / r) * accel * deltaTime;
                            
                            positions[j * 3] += velocities[j * 3] * deltaTime;
                            positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                            positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        }
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.geometry.attributes.lifetime.needsUpdate = true;
                    system.material.uniforms.opacity.value = params.particleDensity;
                } else if (type === 'jet') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for (let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                } else if (type === 'burst') {
                    const positions = system.geometry.attributes.position.array;
                    const velocities = system.geometry.attributes.velocity.array;
                    for(let j = 0; j < positions.length / 3; j++) {
                        positions[j * 3] += velocities[j * 3] * deltaTime;
                        positions[j * 3 + 1] += velocities[j * 3 + 1] * deltaTime;
                        positions[j * 3 + 2] += velocities[j * 3 + 2] * deltaTime;
                        velocities[j * 3] *= 0.99;
                        velocities[j * 3 + 1] *= 0.99;
                        velocities[j * 3 + 2] *= 0.99;
                    }
                    system.geometry.attributes.position.needsUpdate = true;
                    system.material.opacity -= deltaTime * 0.5;
                    if (system.material.opacity <= 0) {
                        scene.remove(system);
                        system.geometry.dispose();
                        system.material.dispose();
                        particleSystems.splice(i, 1);
                    }
                }
                if (system.material.uniforms && system.material.uniforms.time) {
                    system.material.uniforms.time.value += deltaTime;
                }
            }
        }

        // --- Main Animation Loop ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const effectiveDeltaTime = clock.getDelta();
            const timeScale = params.isPaused ? 0 : params.timeScale;
            const deltaTime = effectiveDeltaTime * timeScale;
            const elapsedTime = clock.getElapsedTime();
            
            // Update simulation
            updatePhysics(deltaTime);
            if (!params.cinematicCamera) controls.update();
            updateCamera(elapsedTime);
            updateCameraShake(deltaTime);
            updateAllParticleSystems(deltaTime);
            
            // Update background
            starfieldMaterial.uniforms.time.value = elapsedTime;
            
            // Update post-merger effects
            if (mergerTime > 0 && blackHoles.length === 1) {
                const bh = blackHoles[0];
                const precessionQuaternion = new THREE.Quaternion().setFromAxisAngle(bh.precessionAxis, deltaTime * bh.spinMagnitude * 0.1);
                bh.group.quaternion.premultiply(precessionQuaternion);
                
                jets.forEach(jet => {
                    if (jet.material.uniforms.opacity.value > 0) {
                        jet.material.uniforms.opacity.value *= 0.995;
                    }
                    if (jet.material.uniforms.time) {
                        jet.material.uniforms.time.value = elapsedTime;
                    }
                });

                if (bh.diskMaterial.uniforms.ringdown.value > 0.001) {
                    bh.diskMaterial.uniforms.ringdown.value *= (1.0 - 0.8 * effectiveDeltaTime);
                } else {
                    bh.diskMaterial.uniforms.ringdown.value = 0.0;
                }
                updateInfoDisplay();
            }

            // Update lensing positions
            const screenPositions = blackHoles.map(bh => {
                const pos = bh.group.position.clone();
                pos.project(camera);
                return pos;
            });
            
            for (let i = 0; i < 10; i++) {
                if (i < blackHoles.length) {
                    lensingPass.uniforms.bhPositions.value[i].set(
                        (screenPositions[i].x + 1) / 2, 
                        (screenPositions[i].y + 1) / 2
                    );
                    lensingPass.uniforms.bhMasses.value[i] = blackHoles[i].mass;
                } else {
                    lensingPass.uniforms.bhPositions.value[i].set(-10, -10);
                    lensingPass.uniforms.bhMasses.value[i] = 0;
                }
            }
            lensingPass.uniforms.bhCount.value = blackHoles.length;
            lensingPass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            lensingPass.uniforms.aspect.value = window.innerWidth / window.innerHeight;
            
            // Update gravitational wave effect
            if (wavePass.uniforms.time.value >= 0) {
                wavePass.uniforms.time.value += deltaTime;
                if (wavePass.uniforms.time.value > 1.0) {
                    wavePass.uniforms.time.value = -1.0;
                }
            }

            // Update God Ray effect
            if (godRayPass.enabled) {
                godRayPass.uniforms.exposure.value *= (1.0 - 1.5 * effectiveDeltaTime);
                if (godRayPass.uniforms.exposure.value < 0.01) {
                    godRayPass.enabled = false;
                }
            }

            // Render
            composer.render();
        }
        
        // Start simulation
        const loader = document.getElementById('loader');
        initSimulation();
        animate();
        loader.style.opacity = '0';
        setTimeout(() => loader.style.display = 'none', 500);


        // --- Window Resize Handler ---
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            
            renderer.setSize(width, height);
            composer.setSize(width, height);
            
            lensingPass.uniforms.resolution.value.set(width, height);
            lensingPass.uniforms.aspect.value = width / height;
            
            smaaPass.setSize(width, height);
            
            updateQuality(params.quality);
        });
        
        // --- Keyboard Controls ---
        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;

            switch(e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    togglePause();
                    break;
                case 'c': toggleCinematic(); break;
                case 'g': toggleGrid(); break;
                case 'i': toggleInfo(); break;
                case 'r': initSimulation(); break;
            }
        });
    </script>

<canvas data-engine="three.js r178" width="2704" height="410" style="display: block; width: 1352px; height: 205px; touch-action: none;"></canvas><div class="lil-gui allow-touch-styles root autoPlace"><div class="title" role="button" aria-expanded="true" tabindex="0">Controls</div><div class="children"><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">System Setup</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-1">Mass 1 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 21.428571%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-1"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-2">Mass 2 (M☉)</div><div class="widget"><div class="slider"><div class="fill" style="width: 10.714286%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-2"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-3">Initial Distance</div><div class="widget"><div class="slider"><div class="fill" style="width: 13.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-3"></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-4">🚀 Launch Simulation</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Presets</div><div class="children"><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-5">Asymmetric Merger</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-6">Equal Mass</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-7">Extreme Mass Ratio</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-8">Massive Merger</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Director Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-9">Time Scale</div><div class="widget"><div class="slider"><div class="fill" style="width: 18.367347%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-9"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-10">Cinematic Camera</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-10"></label></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-11">Focus on Black Hole 1</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-12">Focus on Black Hole 2</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-13">Focus on Center</div></button></div></div><div class="controller function"><div class="widget"><button><div class="name" id="lil-gui-name-14">Reset Camera</div></button></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Visual Controls</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-15">Disk Brightness</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-15"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-16">Bloom Intensity</div><div class="widget"><div class="slider"><div class="fill" style="width: 30%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-16"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-17">Show Spacetime Grid</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-17"></label></div><div class="controller boolean"><div class="name" id="lil-gui-name-18">Show Info Display</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-18"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-19">Particle Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-19"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-20">Nebula Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-20"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-21">Star Density</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-21"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Advanced Physics</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-22">Orbital Decay Rate</div><div class="widget"><div class="slider"><div class="fill" style="width: 25%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-22"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-23">Final BH Spin (a/M)</div><div class="widget"><div class="slider"><div class="fill" style="width: 91.836735%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-23"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-24">Camera Shake</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-24"></label></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-25">Lensing Strength</div><div class="widget"><div class="slider"><div class="fill" style="width: 50%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-25"></div></div><div class="controller boolean"><div class="name" id="lil-gui-name-26">Play Merger Sound</div><label class="widget"><input type="checkbox" aria-labelledby="lil-gui-name-26"></label></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Post Processing</div><div class="children"><div class="controller number hasSlider"><div class="name" id="lil-gui-name-27">Exposure</div><div class="widget"><div class="slider"><div class="fill" style="width: 33.333333%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-27"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-28">Contrast</div><div class="widget"><div class="slider"><div class="fill" style="width: 40%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-28"></div></div><div class="controller number hasSlider"><div class="name" id="lil-gui-name-29">Saturation</div><div class="widget"><div class="slider"><div class="fill" style="width: 60%;"></div></div><input type="number" step="any" aria-labelledby="lil-gui-name-29"></div></div></div></div><div class="lil-gui allow-touch-styles"><div class="title" role="button" aria-expanded="true" tabindex="0">Performance</div><div class="children"><div class="controller option"><div class="name" id="lil-gui-name-30">Quality</div><div class="widget"><select aria-labelledby="lil-gui-name-30"><option>low</option><option>medium</option><option>high</option><option>ultra</option></select><div class="display">ultra</div></div></div></div></div></div></div></body></html>
